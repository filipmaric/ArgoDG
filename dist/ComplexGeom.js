/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["ComplexGeom"] = factory();
	else
		root["ComplexGeom"] = factory();
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/complex_geom.js":
/*!*****************************!*\
  !*** ./src/complex_geom.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CP1\": () => (/* reexport safe */ _complex_geom_cp1_js__WEBPACK_IMPORTED_MODULE_1__.CP1),\n/* harmony export */   \"Circline\": () => (/* reexport safe */ _complex_geom_circline_js__WEBPACK_IMPORTED_MODULE_4__.Circline),\n/* harmony export */   \"Complex\": () => (/* reexport safe */ _complex_geom_complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex),\n/* harmony export */   \"ComplexMatrix2x2\": () => (/* reexport safe */ _complex_geom_complex_matrix_js__WEBPACK_IMPORTED_MODULE_2__.ComplexMatrix2x2),\n/* harmony export */   \"INCLUDE_FICTIVE\": () => (/* reexport safe */ _complex_geom_circline_js__WEBPACK_IMPORTED_MODULE_4__.INCLUDE_FICTIVE),\n/* harmony export */   \"Moebius\": () => (/* reexport safe */ _complex_geom_moebius_js__WEBPACK_IMPORTED_MODULE_3__.Moebius),\n/* harmony export */   \"PoincareDisc\": () => (/* reexport safe */ _complex_geom_poincare_js__WEBPACK_IMPORTED_MODULE_5__.PoincareDisc),\n/* harmony export */   \"PoincareHalfPlane\": () => (/* reexport safe */ _complex_geom_poincare_js__WEBPACK_IMPORTED_MODULE_5__.PoincareHalfPlane)\n/* harmony export */ });\n/* harmony import */ var _complex_geom_complex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./complex_geom/complex.js */ \"./src/complex_geom/complex.js\");\n/* harmony import */ var _complex_geom_cp1_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./complex_geom/cp1.js */ \"./src/complex_geom/cp1.js\");\n/* harmony import */ var _complex_geom_complex_matrix_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./complex_geom/complex_matrix.js */ \"./src/complex_geom/complex_matrix.js\");\n/* harmony import */ var _complex_geom_moebius_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./complex_geom/moebius.js */ \"./src/complex_geom/moebius.js\");\n/* harmony import */ var _complex_geom_circline_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./complex_geom/circline.js */ \"./src/complex_geom/circline.js\");\n/* harmony import */ var _complex_geom_poincare_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./complex_geom/poincare.js */ \"./src/complex_geom/poincare.js\");\n\n\n\n\n\n\n\n\n//# sourceURL=webpack://ArgoDG/./src/complex_geom.js?");

/***/ }),

/***/ "./src/complex_geom/circline.js":
/*!**************************************!*\
  !*** ./src/complex_geom/circline.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Circline\": () => (/* binding */ Circline),\n/* harmony export */   \"INCLUDE_FICTIVE\": () => (/* binding */ INCLUDE_FICTIVE)\n/* harmony export */ });\n/* harmony import */ var _complex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./complex.js */ \"./src/complex_geom/complex.js\");\n/* harmony import */ var _cp1_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cp1.js */ \"./src/complex_geom/cp1.js\");\n/* harmony import */ var _complex_matrix_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./complex_matrix.js */ \"./src/complex_geom/complex_matrix.js\");\n/* harmony import */ var _moebius_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./moebius.js */ \"./src/complex_geom/moebius.js\");\n\n\n\n\n\nclass Circline {\n    // Circline is represented by a Hermitean matrix\n    constructor(A, B, C, D) {\n        if (arguments[0] instanceof _complex_matrix_js__WEBPACK_IMPORTED_MODULE_2__.ComplexMatrix2x2)\n            this.H = arguments[0];\n        else\n            this.H = new _complex_matrix_js__WEBPACK_IMPORTED_MODULE_2__.ComplexMatrix2x2(A, B, C, D);\n        this.normalize();\n    }\n\n    normalize() {\n        this.H = Circline.normalizeOriented(this.H);\n        this.H_unoriented = Circline.normalizeUnoriented(this.H);\n    }\n\n    // convert the H matrix to canonical form (used for easy circline comparison)\n    // A is set to 1 if possible,\n    // otherwise B is set to unit modulus and nonegative argument\n    // WARNING: this can change orientation\n    static normalizeUnoriented(H) {\n        if (!H.A.is_zero()) {\n            return H.multC(H.A.reciprocal());\n        } else {\n            const arg = H.B.arg();\n            if (0 <= arg && arg < Math.PI)\n                return H.multC(1 / H.B.norm());\n            else\n                return H.multC(- 1 / H.B.norm());\n        }\n    }\n\n    static normalizeOriented(H) {\n        if (!H.A.is_zero()) {\n            return H.multC(1 / H.A.norm());\n        } else {\n            return H.multC(1 / H.B.norm());\n        }\n    }\n\n\n    // Circline that represents an Euclidean circle with center in a (finite) complex number a\n    // that has a radius r\n    static mk_circle(a, r) {\n        return new Circline(_complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.one, a.uminus(),\n                            a.cnj().uminus(), a.mult(a.cnj()).sub(_complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.of_real(r*r)));\n    }\n\n    // Circline that represents an Euclidean line that joins two given (finite) complex numbers \n    static mk_line(z1, z2) {\n        const B = z2.sub(z1).mult(_complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.i);\n        return new Circline(_complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.zero, B,\n                            B.cnj(), _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.cnj_mix(B.uminus(), z1));\n    }\n\n    // Circline determined by tree points (either complex or CP1)\n    static mk_circline3(z1, z2, z3) {\n        if (!(z1 instanceof _cp1_js__WEBPACK_IMPORTED_MODULE_1__.CP1)) z1 = z1.cp1();\n        if (!(z2 instanceof _cp1_js__WEBPACK_IMPORTED_MODULE_1__.CP1)) z2 = z2.cp1();\n        if (!(z3 instanceof _cp1_js__WEBPACK_IMPORTED_MODULE_1__.CP1)) z3 = z3.cp1();\n        const M = _moebius_js__WEBPACK_IMPORTED_MODULE_3__.Moebius.moebius_01inf(z1, z2, z3);\n        return M.inv().moebius_circline(Circline.x_axis());\n    }\n\n    // oposite oriented circline\n    opposite() {\n        return new Circline(this.H.multC(-1));\n    }\n\n    // several special circlines\n    \n    static unit_circle() {\n        return new Circline(_complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.one, _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.zero, _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.zero, _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.minus_one);\n    }\n\n    static x_axis() {\n        return new Circline(_complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.zero, _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.i, _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.minus_i, _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.zero);\n    }\n\n    static y_axis() {\n        return new Circline(_complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.zero, _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.one, _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.one, _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.zero);\n    }\n\n    // check if this circline is an Euclidean line\n    is_line() {\n        return this.H.A.is_zero();\n    }\n\n    // check if this circline is an Euclidean circle\n    is_circle() {\n        return !this.is_line();\n    }\n\n    // Euclidean center of the current circline (works only if this is an Euclidean circle)\n    circle_center() {\n        return this.H.B.uminus().div(this.H.A);\n    }\n\n    // CP1 (euclidean center of infinity)\n    center() {\n        if (this.is_line())\n            return _cp1_js__WEBPACK_IMPORTED_MODULE_1__.CP1.inf;\n        else\n            return _cp1_js__WEBPACK_IMPORTED_MODULE_1__.CP1.of_complex(this.circle_center());\n    }\n\n    // Euclidean radius of the current circline (works only if this is an Euclidean circle)\n    circle_radius() {\n        return Math.sqrt(this.H.B.mult(this.H.C).sub(this.H.A.mult(this.H.D)).div(this.H.A.mult(this.H.A)).re());\n    }\n\n    // Two points on the current circline (works only if this is an Euclidean line)\n    line_points() {\n        const z1 = this.H.D.mult(this.H.B).uminus().div(this.H.B.mult(this.H.C).scale(2));\n        const z2 = z1.add(_complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.i.mult((this.H.B.arg() > 0 ? this.H.B.uminus() : this.H.B).sgn()));\n        return [z1, z2];\n    }\n\n    // precision for checking in/on/out\n    static EPS = 1e-10;\n\n    quad_form(z) {\n        if (!(z instanceof _cp1_js__WEBPACK_IMPORTED_MODULE_1__.CP1))\n            z = z.cp1();\n\n        return z.cnj().vec_mult(this.H.multCP1(z, false)).re();\n    }\n    \n    // checks if the given CP1 point lies on this circline (precision can be changed)\n    on_circline(z, eps) {\n        if (!eps)\n            eps = Circline.EPS;\n        return Math.abs(this.quad_form(z)) < eps;\n    }\n\n    // checks if the given CP1 point lines within the disc surounded by this circline (precision\n    // can be changed)\n    in_disc(z, eps) {\n        if (!eps)\n            eps = Circline.EPS;\n        return this.quad_form(z) < -eps;\n    }\n\n    static cross_ratio(w1, z1, w2, z2) {\n        if (!(z1 instanceof _cp1_js__WEBPACK_IMPORTED_MODULE_1__.CP1)) z1 = z1.cp1();\n        if (!(w1 instanceof _cp1_js__WEBPACK_IMPORTED_MODULE_1__.CP1)) w1 = w1.cp1();\n        if (!(z2 instanceof _cp1_js__WEBPACK_IMPORTED_MODULE_1__.CP1)) z2 = z2.cp1();\n        if (!(w2 instanceof _cp1_js__WEBPACK_IMPORTED_MODULE_1__.CP1)) w2 = w2.cp1();\n        return _cp1_js__WEBPACK_IMPORTED_MODULE_1__.CP1.cross_ratio(w1, z1, w2, z2);\n    }\n\n    // check if w1, z1, w2, and z2 all lie on the same circline\n    // w1, z1, w2, z2 are either all CP1 elements, or can be converted to those by means of\n    // cp1 method\n    static same_circline(w1, z1, w2, z2, eps) {\n        if (!eps)\n            eps = Circline.EPS;\n        const cr = Circline.cross_ratio(w1, z1, w2, z2);\n        return cr.is_inf() || cr.to_complex().is_real(eps);\n    }\n\n    // check if z1 and z2 lie on the same arc determined by w1 and w2 (i.e., if z2 is on the\n    // same arc as z1 between w1 and w2, on the circline determined by w1, z1 and w2)\n    // w1, z1, w2, z2 are either all CP1 elements, or can be converted to those by means of\n    // cp1 method\n    static same_arc(w1, z1, w2, z2, eps) {\n        if (!eps)\n            eps = Circline.EPS;\n        const cr = Circline.cross_ratio(w1, z1, w2, z2);\n        return !cr.is_inf() && cr.to_complex().is_real(eps) && cr.to_complex().re() >= eps;\n    }\n    \n    // check if z1 and z2 lie different arcs determined by w1 and w2 (i.e., if z2 is on the\n    // on the circline determined by w1, z1 and w2, but not on the same arc between w1 and w2\n    // as z1)\n    // w1, z1, w2, z2 are either all CP1 elements, or can be converted to those by means of\n    // cp1 method\n    static other_arc(w1, z1, w2, z2, eps) {\n        if (!eps)\n            eps = Circline.EPS;\n        const cr = Circline.cross_ratio(w1, z1, w2, z2);\n        return !cr.is_inf() && cr.to_complex().is_real(eps) && cr.to_complex().re() < -eps;\n    }\n\n    // check if w is between z1 and z2 (in Euclidean sense)\n    // w, z1, z2 are either all CP1 elements, or can be converted to those by means of\n    // cp1 method\n    static between(z1, w, z2, eps) {\n        return Circline.other_arc(_cp1_js__WEBPACK_IMPORTED_MODULE_1__.CP1.inf, z1, w, z2, eps);\n    }\n\n    // check if z1, z2, and z3 are collinear (in Euclidean sense)\n    // z1, z2, z3 are either all CP1 elements, or can be converted to those by means of\n    // cp1 method\n    static collinear(z1, z2, z3, eps) {\n        return Circline.same_circline(z1, z2, z3, _cp1_js__WEBPACK_IMPORTED_MODULE_1__.CP1.inf, eps);\n    }\n\n    // check if w1 and w2 are on the same side of z (on the same Euclidean half-line)\n    // w1, w2, z are either all CP1 elements, or can be converted to those by means of\n    // cp1 method\n    static same_side(w1, w2, z, eps) {\n        return Circline.collinear(w1, w2, z, eps) && !Circline.between(w1, z, w2, eps);\n    }\n\n    // check if w is h-betwen z1 and z2 on the Poincare line joining z1 and z2 within the unit disc\n    // z1, w, z2 are either all CP1 elements, or can be converted to those by means of\n    // cp1 method\n    static h_between(z1, w, z2, eps) {\n        if (!(w instanceof _cp1_js__WEBPACK_IMPORTED_MODULE_1__.CP1))\n            w = w.cp1();\n        return unit_circle.in_disc(w, eps) && Circline.other_arc(w, z1, w.inversion(), z2, eps) \n    }\n\n    static h_between_hp(z1, w, z2, eps) {\n        if (!(w instanceof _cp1_js__WEBPACK_IMPORTED_MODULE_1__.CP1))\n            w = w.cp1();\n        return !x_axis.in_disc(w, eps) && Circline.other_arc(w, z1, w.cnj(), z2, eps) \n    }\n\n    // cosine of the angle between two circlines\n    static cosAngle(c1, c2) {\n        function det12(H1, H2) {\n            return H1.A.mult(H2.D).add(H2.A.mult(H1.D)).sub(H1.B.mult(H2.C)).sub(H2.B.mult(H1.C));\n        }\n        return - det12(c1.H, c2.H).re() / (2 * Math.sqrt(c1.H.det().re() * c2.H.det().re()));\n    }\n\n    // random three different points on this circline\n    three_points() {\n        if (!this._three_points) {\n            if (this.is_line()) {\n                const [z1, z2] = this.line_points();\n                this._three_points = [z1, z2, z1.add(z2.sub(z1).scale(2))];\n            } else {\n                const c = this.circle_center();\n                const r = this.circle_radius();\n                this._three_points = [c.add(_complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.of_real(r)), c.add(_complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.of_real(-r)), c.add(_complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.of_imag(r))];\n            }\n        }\n        return this._three_points;\n    }\n\n    // a single random point on this circline\n    random_point() {\n        const [z1, z2, z3] = this.three_points().map(p => _cp1_js__WEBPACK_IMPORTED_MODULE_1__.CP1.of_complex(p));\n        const M = _moebius_js__WEBPACK_IMPORTED_MODULE_3__.Moebius.moebius_01inf(z1, z2, z3);\n        const part = Math.floor(Math.random() * 3);\n        let x;\n        if (part == 0)\n            // [0, 1]\n            x = Math.random();\n        else if (part == 1)\n            // [1, infty]\n            x = 1 / Math.random();\n        else\n            // [-infty, 0]\n            x = 1 - 1 / Math.random();\n\n        return M.inv().moebius_pt(_cp1_js__WEBPACK_IMPORTED_MODULE_1__.CP1.of_real(x));\n    }\n\n    // random point on this circline that lies within the given disc (usually the unit disc)\n    random_point_in_disc(disc) {\n        const [p1, p2] = this.intersect(disc, true);\n        const [z1, z2, z3] = this.three_points().map(p => _cp1_js__WEBPACK_IMPORTED_MODULE_1__.CP1.of_complex(p));\n        const M = _moebius_js__WEBPACK_IMPORTED_MODULE_3__.Moebius.moebius_01inf(z1, z2, z3);\n        const [x1, x2] = [p1, p2].map(p => M.moebius_pt(p).to_complex().re()).sort()\n        let p;\n        const MAX_ITER = 100;\n        let iter = 0;\n        do {\n            let x;\n            if (Math.random() < 0.5)\n                x = x1 + Math.random() * (x2 - x1);\n            else {\n                const k = Math.floor(5*Math.random());\n                const d = Math.pow(10, k)*Math.random();\n                x = Math.random() < 0.5 ? x1 - d : x2 + d;\n            }\n            p = M.inv().moebius_pt(_cp1_js__WEBPACK_IMPORTED_MODULE_1__.CP1.of_real(x));\n            iter++;\n        } while (!disc.in_disc(p) && iter < MAX_ITER);\n        return iter < MAX_ITER ? p : null;\n    }\n\n    // Moebius transformation that maps this circline to x-axis\n    moebius_to_x_axis() {\n        if (!this._moebius_to_x_axis) {\n            const [z1, z2, z3] = this.three_points().map(p => _cp1_js__WEBPACK_IMPORTED_MODULE_1__.CP1.of_complex(p));\n            this._moebius_to_x_axis = _moebius_js__WEBPACK_IMPORTED_MODULE_3__.Moebius.moebius_01inf(z1, z2, z3);\n        }\n        return this._moebius_to_x_axis;\n    }\n\n    // intersection of this and other circline (fictive intersections can also be returned)\n    intersect(other, includeFictive) {\n        const M = this.moebius_to_x_axis();\n        const cm = M.moebius_circline(other);\n        const [A, B, D] = [cm.H.A, cm.H.B, cm.H.D];\n        let p1, p2;\n        if (A.is_zero()) {\n            p1 = _cp1_js__WEBPACK_IMPORTED_MODULE_1__.CP1.inf;\n            if (B.is_imag())\n                return [p1, p1];\n            p2 = _cp1_js__WEBPACK_IMPORTED_MODULE_1__.CP1.of_real(- D.re() / (2 * B.re()));\n            return [p1, p2].map(p => M.moebius_inv_pt(p));\n        } else {\n            let discr = B.re() * B.re() - A.re() * D.re();\n            ////////////////////////////////////\n            if (Math.abs(discr) < 1e-12)\n                discr = 0;\n            ////////////////////////////////////\n            if (discr < 0) {\n                if (includeFictive) {\n                    // fictive intersections\n                    const sqrt = Math.sqrt(-discr);\n                    const [p1, p2] = [new _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex(-B.re() / A.re(), +sqrt / A.re()),\n                                      new _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex(-B.re() / A.re(), -sqrt / A.re())];\n                    return [p1, p2].map(p => M.moebius_inv_pt(_cp1_js__WEBPACK_IMPORTED_MODULE_1__.CP1.of_complex(p)));\n                } else\n                    return [];\n            } else {\n                const sqrt = Math.sqrt(discr);\n                const [p1, p2] = [(-B.re() + sqrt) / A.re(),\n                                  (-B.re() - sqrt) / A.re()];\n                return [p1, p2].map(p => M.moebius_inv_pt(_cp1_js__WEBPACK_IMPORTED_MODULE_1__.CP1.of_real(p)));\n            }\n        }\n    }\n\n    // apply the given Moebius transform (given by a function that acts on pairs of coordinates)\n    // to this circline\n    transform(t) {\n        let three_points = this.three_points();\n        if (three_points.some(p => isNaN(p.re())))\n            return this;\n        three_points = three_points.map(p => {\n            const [re, im] = t(p.re(), p.im());\n            return _cp1_js__WEBPACK_IMPORTED_MODULE_1__.CP1.of_complex(new _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex(re, im));\n        });\n        return Circline.mk_circline3(...three_points);\n    }\n\n    // check if this circline is equal to the other one (ignoring orientation)\n    eq(other, eps) {\n        return this.H_unoriented.eq(other.H_unoriented, eps);\n    }\n}\n\nconst unit_circle = Circline.unit_circle();\nconst x_axis = Circline.x_axis();\n\nconst INCLUDE_FICTIVE = true;\n\n\n\n\n//# sourceURL=webpack://ArgoDG/./src/complex_geom/circline.js?");

/***/ }),

/***/ "./src/complex_geom/complex.js":
/*!*************************************!*\
  !*** ./src/complex_geom/complex.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Complex\": () => (/* binding */ Complex)\n/* harmony export */ });\n/**\n * Complex number\n */\nclass Complex {\n    constructor(re, im) {\n        this._re = re;\n        this._im = im;\n    }\n\n    static of_real(re) {\n        return new Complex(re, 0);\n    }\n\n    static of_imag(im) {\n        return new Complex(0, im);\n    }\n\n    static of_xy(x, y) {\n        return new Complex(x, y);\n    }\n\n    static of_polar(rho, theta) {\n        return new Complex(rho * Math.cos(theta), rho * Math.sin(theta));\n    }\n\n    // some special complex numbers\n    \n    static get zero() {\n        return zero;\n    }\n\n    static get one() {\n        return one;\n    }\n\n    static get minus_one() {\n        return minus_one;\n    }\n\n    static get i() {\n        return i;\n    }\n    \n    static get minus_i() {\n        return minus_i;\n    }\n\n\n    // copy of this object\n    clone() {\n        return new Complex(this.re(), this.im());\n    }\n\n    // getting basic properties\n    re() {\n        return this._re;\n    }\n\n    x() {\n        return this.re();\n    }\n\n    im() {\n        return this._im;\n    }\n\n    y() {\n        return this.im();\n    }\n    \n    coords() {\n        return [this.re(), this.im()];\n    }\n\n    // precision for checking zero\n    static EPS = 1e-8;\n\n    // check if this complex number is zero (up to the given precision)\n    is_zero(eps) {\n        if (eps === undefined)\n            eps = Complex.EPS;\n        return this.norm2() < eps * eps;\n    }\n\n    // check if two numbers are equal (up to the given precision)\n    eq(other, eps) {\n        if (other == undefined)\n            return false;\n        // default relative error\n        if (eps === undefined)\n            eps = 1e-8;\n        return this.sub(other).norm() <= eps * (this.norm() + other.norm()) / 2;\n    }\n\n    // check if this complex number is real (up to the given precision)\n    is_real(eps) {\n        if (eps === undefined)\n            eps = Complex.EPS;\n        return Math.abs(this.im()) < eps;\n    }\n\n    // check if this complex number is pure imaginary (up to the given precision)\n    is_imag(eps) {\n        if (eps === undefined)\n            eps = Complex.EPS;\n        \n        return Math.abs(this.re()) < eps;\n    }\n\n    // all complex numbers are finite\n    is_inf() {\n        return false;\n    }\n\n    // just in case that a conversion to complex is called on a complex number\n    to_complex() {\n        return this;\n    }\n\n    // Arithmetic operations\n\n    // addition\n    add(other) {\n        return new Complex(this.re() + other.re(), this.im() + other.im());\n    }\n\n    // unary minus\n    uminus() {\n        return this.scale(-1);\n    }\n\n    // subtraction\n    sub(other) {\n        return this.add(other.uminus());\n    }\n\n    // multiplication\n    mult(other) {\n        if (typeof other == \"number\")\n            return this.scale(other);\n        return new Complex(this.re() * other.re() - this.im() * other.im(),\n                           this.re() * other.im() + this.im() * other.re());\n    }\n\n    // multiplication (scaling) by a real scalar\n    scale(k) {\n        return new Complex(k * this.re(), k * this.im());\n    }\n    \n    // division\n    div(other) {\n        return this.mult(other.reciprocal());\n    }\n\n\n    // Euclidean norm\n    norm() {\n        return Math.sqrt(this.norm2());\n    }\n    \n    // square of Euclidean norm\n    norm2() {\n        return this.re() * this.re() + this.im() * this.im();\n    }\n\n    // argument (angle in (-pi, pi])\n    arg() {\n        return Math.atan2(this.im(), this.re());\n    }\n\n    // signum (z -> z / |z|)\n    sgn() {\n        return this.scale(1 / this.norm());\n    }\n\n    // complex conjugate (x + iy -> x - iy)\n    cnj() {\n        return new Complex(this.re(), -this.im());\n    }\n\n    // reciprocal (z -> 1/z)\n    reciprocal() {\n        return this.cnj().scale(1 / this.norm2())\n    }\n\n    // cnj_mix(x1 + iy2, x2 + iy2) = 2*(x1*x2 + y1*y2) + 0*i\n    static cnj_mix(z1, z2) {\n        return z1.cnj().mult(z2).add(z2.cnj().mult(z1));\n    }\n\n    // scalar product when complex numbers are looked as vectors [x1, y1] [x2, y2]\n    // scalprod(x1 + iy1, x2 + iy2) = x1*x2 + y1*y2\n    static scalprod(z1, z2) {\n        return Complex.cnj_mix(z1, z2).scale(1 / 2).re();\n    }\n}\n\nconst zero      = new Complex( 0,  0);\nconst one       = new Complex( 1,  0);\nconst minus_one = new Complex(-1,  0);\nconst i         = new Complex( 0,  1);\nconst minus_i   = new Complex( 0, -1);\n\n\n\n\n//# sourceURL=webpack://ArgoDG/./src/complex_geom/complex.js?");

/***/ }),

/***/ "./src/complex_geom/complex_matrix.js":
/*!********************************************!*\
  !*** ./src/complex_geom/complex_matrix.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ComplexMatrix2x2\": () => (/* binding */ ComplexMatrix2x2)\n/* harmony export */ });\n/* harmony import */ var _complex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./complex.js */ \"./src/complex_geom/complex.js\");\n/* harmony import */ var _cp1_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cp1.js */ \"./src/complex_geom/cp1.js\");\n\n\n\nclass ComplexMatrix2x2 {\n    constructor(A, B, C, D) {\n        this.A = A;\n        this.B = B;\n        this.C = C;\n        this.D = D;\n    }\n\n    static zero() {\n        return new ComplexMatrix2x2(_complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.zero, _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.zero,\n                                    _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.zero, _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.zero);\n    }\n\n    static eye() {\n        return new ComplexMatrix2x2(_complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.one, _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.zero,\n                                    _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.zero, _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.one);\n    }\n\n    cnj() {\n        return new ComplexMatrix2x2(this.A.cnj(), this.B.cnj(),\n                                    this.C.cnj(), this.D.cnj());\n    }\n\n    transpose() {\n        return new ComplexMatrix2x2(this.A, this.C,\n                                    this.B, this.D);\n    }\n\n    adj() {\n        return this.cnj().transpose();\n    }\n\n    det() {\n        return this.A.mult(this.D).sub(this.B.mult(this.C));\n    }\n\n    inv() {\n        if (!this._inv)\n            this._inv = new ComplexMatrix2x2(this.D, this.B.uminus(),\n                                             this.C.uminus(), this.A).multC(this.det().reciprocal());\n        return this._inv;\n    }\n\n    qr() {\n        if (this._Q == undefined || this._R == undefined) {\n            const s0 = this.C.cnj();\n            const c0 = this.A.cnj();\n            const n = Math.sqrt(s0.norm2() + c0.norm2());\n            const c = c0.scale(1 / n);\n            const s = s0.scale(1 / n);\n            const Qa = new ComplexMatrix2x2(c, s,\n                                            s.cnj().uminus(), c.cnj());\n            this._Q = Qa.adj();\n            this._R = Qa.multM(this);\n        }\n        return [this._Q, this._R];\n    }\n    \n    eq(other, eps) {\n        return this.A.eq(other.A, eps) && this.B.eq(other.B, eps) &&\n               this.C.eq(other.C, eps) && this.D.eq(other.D, eps);\n    }\n\n    is_hermitean() {\n        return this.eq(this.adj());\n    }\n\n    is_zero() {\n        return this.eq(ComplexMatrix2x2.zero());\n    }\n\n    multC(obj) {\n        return new ComplexMatrix2x2(this.A.mult(obj), this.B.mult(obj),\n                                    this.C.mult(obj), this.D.mult(obj));\n    }\n\n    multCP1(obj, normalize) {\n        return new _cp1_js__WEBPACK_IMPORTED_MODULE_1__.CP1(this.A.mult(obj.z1).add(this.B.mult(obj.z2)),\n                       this.C.mult(obj.z1).add(this.D.mult(obj.z2)), normalize);\n    }\n\n    multInvCP1(obj) {\n        const [Q, R] = this.qr();\n        const rhs = Q.adj().multCP1(obj);\n        const z2 = rhs.z2.div(R.D);\n        const z1  = rhs.z1.sub(R.B.mult(z2)).div(R.A);\n        return new _cp1_js__WEBPACK_IMPORTED_MODULE_1__.CP1(z1, z2);\n    }\n\n    multM(obj) {\n        return new ComplexMatrix2x2(this.A.mult(obj.A).add(this.B.mult(obj.C)),\n                                    this.A.mult(obj.B).add(this.B.mult(obj.D)),\n                                    this.C.mult(obj.A).add(this.D.mult(obj.C)),\n                                    this.C.mult(obj.B).add(this.D.mult(obj.D)));\n    }\n\n    congruence(P) {\n        return P.adj().multM(this.multM(P));\n    }\n}\n\n\n\n/*\nclass Matrix3x3 {\n    constructor() {\n        if (arguments.length == 1)\n            this.M = arguments[0];\n        else if (arguments.length == 9)\n            this.M = [[arguments[0], arguments[1], arguments[2]],\n                      [arguments[3], arguments[4], arguments[5]],\n                      [arguments[6], arguments[7], arguments[8]]];\n    }\n\n\n    static zero() {\n        return new Matrix3x3([[0, 0, 0], [0, 0, 0], [0, 0, 0]]);\n    }\n\n    static eye() {\n        return new Matrix3x3([[1, 0, 0], [0, 1, 0], [0, 0, 1]]);\n    }\n\n    transpose() {\n        const M = Matrix3x3.zero();\n        for (let i = 0; i < 3; i++)\n            for (let j = 0; j < 3; j++)\n                M[i][j] = this.M[j][i];\n        return M;\n    }\n\n    det() {\n        const M = this.M;\n        return  M[0][0]*M[1][1]*M[2][2] + M[0][1]*M[1][2]*M[2][0] + M[0][2]*M[1][0]*M[2][1]\n              - M[2][0]*M[1][1]*M[0][2] - M[2][1]*M[1][2]*M[0][0] - M[2][2]*M[1][0]*M[0][1];\n    }\n\n    mult() {\n        if (arguments.length == 1 && typeof arguments[0] == \"number\") {\n            const M = this.M;\n            const MM = new Matrix3x3(M[0][0], M[0][1], M[0][2], M[1][0], M[1][1], M[1][2], M[2][0], M[2][1], M[2][2]);\n            for (let i = 0; i < 3; i++)\n                for (let j = 0; j < 3; j++)\n                    MM.M[i][j] *= arguments[0];\n            return MM;\n        }\n\n        if (arguments.length == 1 && arguments[0] instanceof Matrix3x3) {\n            const M = Matrix3x3.zero();\n            for (let i = 0; i < 3; i++)\n                for (let j = 0; j < 3; j++)\n                    for (let k = 0; k < 3; k++)\n                        M.M[i][j] += this.M[i][k] * arguments[0].M[k][j];\n            return M.M;\n        }\n            \n        throw \"Not supported\";\n    }\n\n    inv() {\n        function d(a, b, c, d) {\n            return a*d - b*c;\n        }\n        const M = this.M;\n        return new Matrix3x3(d(M[1][1], M[1][2], M[2][1], M[2][2]), d(M[0][2], M[0][1], M[2][2], M[2][1]), d(M[0][1], M[0][2], M[1][1], M[1][2]),\n                             d(M[1][2], M[1][0], M[2][2], M[2][0]), d(M[0][0], M[0][2], M[2][0], M[2][2]), d(M[0][2], M[0][0], M[1][2], M[1][0]),\n                             d(M[1][0], M[1][1], M[2][0], M[2][1]), d(M[0][1], M[0][0], M[2][1], M[2][0]), d(M[0][0], M[0][1], M[1][0], M[1][1])).mult(1 / this.det());\n    }\n    \n}\n*/\n\n\n//# sourceURL=webpack://ArgoDG/./src/complex_geom/complex_matrix.js?");

/***/ }),

/***/ "./src/complex_geom/cp1.js":
/*!*********************************!*\
  !*** ./src/complex_geom/cp1.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CP1\": () => (/* binding */ CP1)\n/* harmony export */ });\n/* harmony import */ var _complex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./complex.js */ \"./src/complex_geom/complex.js\");\n\n\n/**\n * Point in CP1 space (complex projective line),\n * given by its complex homogeneous coordinates\n */\nclass CP1 {\n    constructor(z1, z2, normalize) {\n        if (!z2)\n            z2 = _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.one;\n        this.z1 = z1;\n        this.z2 = z2;\n        if (normalize === undefined || normalize)\n            this.normalize();\n    }\n\n    normalize() {\n        if (!this.z2.is_zero()) {\n            this.z1 = this.z1.div(this.z2);\n            this.z2 = _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.one;\n        } else if (!this.z1.is_zero()) {\n            this.z1 = _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.one;\n            this.z2 = _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.zero;\n        }\n    }\n\n    is_valid(eps) {\n        return !this.z1.is_zero(eps) || !this.z2.is_zero(eps);\n    }\n\n    is_zero(eps) {\n        return this.z1.is_zero(eps);\n    }\n    \n    is_inf(eps) {\n        return this.z2.is_zero(eps);\n    }\n\n    static of_complex(z) {\n        return new CP1(z);\n    }\n\n    static of_real(r) {\n        return CP1.of_complex(_complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.of_real(r));\n    }\n    \n    static of_xy(x, y) {\n        return CP1.of_complex(new _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex(x, y));\n    }\n    \n    static get inf() {\n        return inf;\n    }\n    \n    static get zero() {\n        return zero;\n    }\n    \n    static get one() {\n        return one;\n    }\n\n    to_complex() {\n        return this.z1.div(this.z2);\n    }\n\n    coords() {\n        if (!this.is_inf())\n            return this.to_complex().coords();\n        else\n            return null;\n    }\n\n    x() {\n        if (!this.is_inf())\n            return this.to_complex().x();\n        else\n            return null;\n    }\n\n    y() {\n        if (!this.is_inf())\n            return this.to_complex().y();\n        else\n            return null;\n    }    \n    \n    add(other) {\n        if (!this.z2.is_zero() || !other.z2.is_zero())\n            return new CP1(this.z1.mult(other.z2).add(other.z1.mult(this.z2)),\n                           this.z2.mult(other.z2));\n        else\n            return CP1.inf;\n    }\n\n    uminus() {\n        return new CP1(this.z1.uminus(), this.z2);\n    }\n\n    sub(other) {\n        return this.add(other.uminus());\n    }\n\n    mult(other) {\n        if ((this.z1.is_zero() && other.z2.is_zero()) ||\n            (other.z1.is_zero() && this.z2.is_zero()))\n            return CP1.one;\n        else\n            return new CP1(this.z1.mult(other.z1), this.z2.mult(other.z2));\n    }\n\n    reciprocal() {\n        return new CP1(this.z2, this.z1);\n    }\n\n    div(other) {\n        return this.mult(other.reciprocal());\n    }\n\n    cnj() {\n        return new CP1(this.z1.cnj(), this.z2.cnj());\n    }\n\n    inversion() {\n        return this.reciprocal().cnj();\n    }\n\n    eq(other, eps) {\n        if (!other)\n            return false;\n        \n        if (!(other instanceof CP1))\n            other = other.cp1();\n\n        if (!other)\n            return false;\n        \n        this.normalize();\n        other.normalize();\n        \n        if (this.is_inf())\n            return other.is_inf();\n        if (other.is_inf())\n            return this.is_inf();\n        return this.sub(other).is_zero(eps);\n    }\n\n    clone() {\n        return new CP1(this.z1.clone(), this.z2.clone());\n    }\n\n    static ratio(a, b, c) {\n        return (a.sub(b)).div(a.sub(c));\n    }\n\n    static cross_ratio(z, u, v, w) {\n        const n1 = z.z1.mult(u.z2).sub(u.z1.mult(z.z2));\n        const n2 = v.z1.mult(w.z2).sub(w.z1.mult(v.z2));\n        const d1 = z.z1.mult(w.z2).sub(w.z1.mult(z.z2));\n        const d2 = v.z1.mult(u.z2).sub(u.z1.mult(v.z2));\n        if (!n1.mult(n2).is_zero() || !d1.mult(d2).is_zero())\n            return new CP1(n1.mult(n2), d1.mult(d2));\n        else\n            return CP1.one;\n    }\n\n    vec_mult(other) {\n        return this.z1.mult(other.z1).add(this.z2.mult(other.z2));\n    }\n}\n\nconst inf  = new CP1(_complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.one, _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.zero);\nconst zero = CP1.of_real(0);\nconst one  = CP1.of_real(1);\n\n_complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.prototype.cp1 = function() {\n    return CP1.of_complex(this);\n}\n      \n\n\n\n//# sourceURL=webpack://ArgoDG/./src/complex_geom/cp1.js?");

/***/ }),

/***/ "./src/complex_geom/moebius.js":
/*!*************************************!*\
  !*** ./src/complex_geom/moebius.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Moebius\": () => (/* binding */ Moebius)\n/* harmony export */ });\n/* harmony import */ var _complex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./complex.js */ \"./src/complex_geom/complex.js\");\n/* harmony import */ var _complex_matrix_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./complex_matrix.js */ \"./src/complex_geom/complex_matrix.js\");\n/* harmony import */ var _circline_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./circline.js */ \"./src/complex_geom/circline.js\");\n/* harmony import */ var _cp1_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./cp1.js */ \"./src/complex_geom/cp1.js\");\n\n\n\n\n\n/**\n * Moebius transform (az + b) / (cz + d) acting on points of CP1\n */\nclass Moebius {\n    constructor(A, B, C, D) {\n        if (arguments.length == 1 && A instanceof _complex_matrix_js__WEBPACK_IMPORTED_MODULE_1__.ComplexMatrix2x2) {\n            this.construct(A.A, A.B, A.C, A.D);\n        } else {\n            this.construct(A, B, C, D);\n        }\n    }\n\n    construct(A, B, C, D) {\n        if (!A.is_zero()) {\n            B = B.div(A);\n            C = C.div(A);\n            D = D.div(A);\n            A = A.div(A); // must be last\n        }\n        else {\n            const b = B.norm();\n            A = A.scale(1 / b);\n            B = B.scale(1 / b);\n            C = C.scale(1 / b);\n            D = D.scale(1 / b);\n        }\n        this.M = new _complex_matrix_js__WEBPACK_IMPORTED_MODULE_1__.ComplexMatrix2x2(A, B, C, D);\n    }\n\n    moebius_pt(z) {\n        if (!(z instanceof _cp1_js__WEBPACK_IMPORTED_MODULE_3__.CP1))\n            z = z.cp1();\n        return this.M.multCP1(z);\n    }\n\n    moebius_inv_pt(z) {\n        if (!(z instanceof _cp1_js__WEBPACK_IMPORTED_MODULE_3__.CP1))\n            z = z.cp1();\n        return this.M.multInvCP1(z);\n    }\n\n    moebius_circline(c) {\n        return new _circline_js__WEBPACK_IMPORTED_MODULE_2__.Circline(c.H.congruence(this.M.inv()));\n    }\n\n    static id() {\n        return new Moebius(_complex_matrix_js__WEBPACK_IMPORTED_MODULE_1__.ComplexMatrix2x2.eye());\n    }\n\n    inv() {\n        return new Moebius(this.M.inv());\n    }\n\n    comp(other) {\n        return new Moebius(this.M.multM(other.M));\n    }\n\n    static moebius_01inf(w1, w2, w3) {\n        const m23 = w2.z1.mult(w3.z2).sub(w3.z1.mult(w2.z2));\n        const m21 = w2.z1.mult(w1.z2).sub(w1.z1.mult(w2.z2));\n        const m13 = w1.z1.mult(w3.z2).sub(w3.z1.mult(w1.z2));\n        return new Moebius(w1.z2.mult(m23), w1.z1.mult(m23).uminus(),\n                           w3.z2.mult(m21), w3.z1.mult(m21).uminus());\n    }\n}\n\n\n\n\n//# sourceURL=webpack://ArgoDG/./src/complex_geom/moebius.js?");

/***/ }),

/***/ "./src/complex_geom/poincare.js":
/*!**************************************!*\
  !*** ./src/complex_geom/poincare.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"PoincareDisc\": () => (/* binding */ PoincareDisc),\n/* harmony export */   \"PoincareHalfPlane\": () => (/* binding */ PoincareHalfPlane)\n/* harmony export */ });\n/* harmony import */ var _complex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./complex.js */ \"./src/complex_geom/complex.js\");\n/* harmony import */ var _cp1_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cp1.js */ \"./src/complex_geom/cp1.js\");\n/* harmony import */ var _circline_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./circline.js */ \"./src/complex_geom/circline.js\");\n/* harmony import */ var _moebius_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./moebius.js */ \"./src/complex_geom/moebius.js\");\n\n\n\n\n\nclass PoincareDisc {\n    // hyperbolic distance between two given (finite) complex numbers inside the disc\n    static hdist(u, v) {\n        return Math.acosh(1 + (2 * u.sub(v).norm2()) / ((1 - u.norm2()) * (1 - v.norm2())));\n    }\n\n    // cosine of the hyperbolic angle ABC given by three (finite) complex numbers inside the disc\n    static cosPhi(A, B, C) {\n        const l1 = PoincareDisc.mk_line(A, B);\n        const l2 = PoincareDisc.mk_line(C, B);\n        return _circline_js__WEBPACK_IMPORTED_MODULE_2__.Circline.cosAngle(l1, l2);\n    }\n    \n    // Circline that represents a Poincare disc line that joins two given (finite) complex numbers\n    // inside the disc\n    static mk_line(z1, z2) {\n        const A = _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.i.mult((z1.mult(z2.cnj())).sub(z2.mult(z1.cnj())));\n        const B = _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.i.mult(z2.scale(z1.norm2() + 1).sub(z1.scale(z2.norm2() + 1)));\n        return new _circline_js__WEBPACK_IMPORTED_MODULE_2__.Circline(A, B, B.cnj(), A);\n    }\n\n    // Circline that represents a Poincare circle that is centered in a (finite) complex number a\n    // and has the radius r\n    static mk_circle(a, r) {\n        const ae = a.scale(1 / ((1 - a.norm2())*(Math.cosh(r) - 1)/2 + 1));\n        const re = ((1 - a.norm2()) * Math.sinh(r)) / ((1 - a.norm2()) * (Math.cosh(r) - 1) + 2);\n        return _circline_js__WEBPACK_IMPORTED_MODULE_2__.Circline.mk_circle(ae, re);\n    }\n}\n\nconst half_plane_to_disc = new _moebius_js__WEBPACK_IMPORTED_MODULE_3__.Moebius(_complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.one, _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.i.uminus(), _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.one, _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.i);\nconst disc_to_half_plane = half_plane_to_disc.inv();\n\nclass PoincareHalfPlane {\n    // hyperbolic distance between two given (finite) complex numbers inside the upper half plane\n    static hdist(u, v) {\n        return Math.acosh(1 + (u.sub(v).norm2()) / (2*u.im()*v.im()));\n    }\n\n    // cosine of the hyperbolic angle ABC given by three (finite) complex numbers inside the disc\n    static cosPhi(A, B, C) {\n        const l1 = PoincareHalfPlane.mk_line(A, B);\n        const l2 = PoincareHalfPlane.mk_line(C, B);\n        return _circline_js__WEBPACK_IMPORTED_MODULE_2__.Circline.cosAngle(l1, l2);\n    }\n    \n    // Circline that represents a Poincare half plane line that joins\n    // two given (finite) complex numbers inside the disc\n    static mk_line(z1, z2) {\n        // FIXME: find a direct formula\n        const zz1 = half_plane_to_disc.moebius_pt(z1);\n        const zz2 = half_plane_to_disc.moebius_pt(z2);\n        const ll = PoincareDisc.mk_line(zz1.to_complex(), zz2.to_complex());\n        return disc_to_half_plane.moebius_circline(ll);\n    }\n\n    // Circline that represents a Poincare circle that is centered in a (finite) complex number a\n    // and has the radius r\n    static mk_circle(a, r) {\n        // FIXME: find a direct formula\n        const aa = half_plane_to_disc.moebius_pt(a);\n        const cc = PoincareDisc.mk_circle(aa.to_complex(), r);\n        return disc_to_half_plane.moebius_circline(cc);\n    }\n}\n\n\n\n\n//# sourceURL=webpack://ArgoDG/./src/complex_geom/poincare.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/complex_geom.js");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});