/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["DG"] = factory();
	else
		root["DG"] = factory();
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/canvas2svg/canvas2svg.js":
/*!***********************************************!*\
  !*** ./node_modules/canvas2svg/canvas2svg.js ***!
  \***********************************************/
/***/ ((module) => {

eval("/*!!\n *  Canvas 2 Svg v1.0.19\n *  A low level canvas to SVG converter. Uses a mock canvas context to build an SVG document.\n *\n *  Licensed under the MIT license:\n *  http://www.opensource.org/licenses/mit-license.php\n *\n *  Author:\n *  Kerry Liu\n *\n *  Copyright (c) 2014 Gliffy Inc.\n */\n\n;(function () {\n    \"use strict\";\n\n    var STYLES, ctx, CanvasGradient, CanvasPattern, namedEntities;\n\n    //helper function to format a string\n    function format(str, args) {\n        var keys = Object.keys(args), i;\n        for (i=0; i<keys.length; i++) {\n            str = str.replace(new RegExp(\"\\\\{\" + keys[i] + \"\\\\}\", \"gi\"), args[keys[i]]);\n        }\n        return str;\n    }\n\n    //helper function that generates a random string\n    function randomString(holder) {\n        var chars, randomstring, i;\n        if (!holder) {\n            throw new Error(\"cannot create a random attribute name for an undefined object\");\n        }\n        chars = \"ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz\";\n        randomstring = \"\";\n        do {\n            randomstring = \"\";\n            for (i = 0; i < 12; i++) {\n                randomstring += chars[Math.floor(Math.random() * chars.length)];\n            }\n        } while (holder[randomstring]);\n        return randomstring;\n    }\n\n    //helper function to map named to numbered entities\n    function createNamedToNumberedLookup(items, radix) {\n        var i, entity, lookup = {}, base10, base16;\n        items = items.split(',');\n        radix = radix || 10;\n        // Map from named to numbered entities.\n        for (i = 0; i < items.length; i += 2) {\n            entity = '&' + items[i + 1] + ';';\n            base10 = parseInt(items[i], radix);\n            lookup[entity] = '&#'+base10+';';\n        }\n        //FF and IE need to create a regex from hex values ie &nbsp; == \\xa0\n        lookup[\"\\\\xa0\"] = '&#160;';\n        return lookup;\n    }\n\n    //helper function to map canvas-textAlign to svg-textAnchor\n    function getTextAnchor(textAlign) {\n        //TODO: support rtl languages\n        var mapping = {\"left\":\"start\", \"right\":\"end\", \"center\":\"middle\", \"start\":\"start\", \"end\":\"end\"};\n        return mapping[textAlign] || mapping.start;\n    }\n\n    //helper function to map canvas-textBaseline to svg-dominantBaseline\n    function getDominantBaseline(textBaseline) {\n        //INFO: not supported in all browsers\n        var mapping = {\"alphabetic\": \"alphabetic\", \"hanging\": \"hanging\", \"top\":\"text-before-edge\", \"bottom\":\"text-after-edge\", \"middle\":\"central\"};\n        return mapping[textBaseline] || mapping.alphabetic;\n    }\n\n    // Unpack entities lookup where the numbers are in radix 32 to reduce the size\n    // entity mapping courtesy of tinymce\n    namedEntities = createNamedToNumberedLookup(\n        '50,nbsp,51,iexcl,52,cent,53,pound,54,curren,55,yen,56,brvbar,57,sect,58,uml,59,copy,' +\n            '5a,ordf,5b,laquo,5c,not,5d,shy,5e,reg,5f,macr,5g,deg,5h,plusmn,5i,sup2,5j,sup3,5k,acute,' +\n            '5l,micro,5m,para,5n,middot,5o,cedil,5p,sup1,5q,ordm,5r,raquo,5s,frac14,5t,frac12,5u,frac34,' +\n            '5v,iquest,60,Agrave,61,Aacute,62,Acirc,63,Atilde,64,Auml,65,Aring,66,AElig,67,Ccedil,' +\n            '68,Egrave,69,Eacute,6a,Ecirc,6b,Euml,6c,Igrave,6d,Iacute,6e,Icirc,6f,Iuml,6g,ETH,6h,Ntilde,' +\n            '6i,Ograve,6j,Oacute,6k,Ocirc,6l,Otilde,6m,Ouml,6n,times,6o,Oslash,6p,Ugrave,6q,Uacute,' +\n            '6r,Ucirc,6s,Uuml,6t,Yacute,6u,THORN,6v,szlig,70,agrave,71,aacute,72,acirc,73,atilde,74,auml,' +\n            '75,aring,76,aelig,77,ccedil,78,egrave,79,eacute,7a,ecirc,7b,euml,7c,igrave,7d,iacute,7e,icirc,' +\n            '7f,iuml,7g,eth,7h,ntilde,7i,ograve,7j,oacute,7k,ocirc,7l,otilde,7m,ouml,7n,divide,7o,oslash,' +\n            '7p,ugrave,7q,uacute,7r,ucirc,7s,uuml,7t,yacute,7u,thorn,7v,yuml,ci,fnof,sh,Alpha,si,Beta,' +\n            'sj,Gamma,sk,Delta,sl,Epsilon,sm,Zeta,sn,Eta,so,Theta,sp,Iota,sq,Kappa,sr,Lambda,ss,Mu,' +\n            'st,Nu,su,Xi,sv,Omicron,t0,Pi,t1,Rho,t3,Sigma,t4,Tau,t5,Upsilon,t6,Phi,t7,Chi,t8,Psi,' +\n            't9,Omega,th,alpha,ti,beta,tj,gamma,tk,delta,tl,epsilon,tm,zeta,tn,eta,to,theta,tp,iota,' +\n            'tq,kappa,tr,lambda,ts,mu,tt,nu,tu,xi,tv,omicron,u0,pi,u1,rho,u2,sigmaf,u3,sigma,u4,tau,' +\n            'u5,upsilon,u6,phi,u7,chi,u8,psi,u9,omega,uh,thetasym,ui,upsih,um,piv,812,bull,816,hellip,' +\n            '81i,prime,81j,Prime,81u,oline,824,frasl,88o,weierp,88h,image,88s,real,892,trade,89l,alefsym,' +\n            '8cg,larr,8ch,uarr,8ci,rarr,8cj,darr,8ck,harr,8dl,crarr,8eg,lArr,8eh,uArr,8ei,rArr,8ej,dArr,' +\n            '8ek,hArr,8g0,forall,8g2,part,8g3,exist,8g5,empty,8g7,nabla,8g8,isin,8g9,notin,8gb,ni,8gf,prod,' +\n            '8gh,sum,8gi,minus,8gn,lowast,8gq,radic,8gt,prop,8gu,infin,8h0,ang,8h7,and,8h8,or,8h9,cap,8ha,cup,' +\n            '8hb,int,8hk,there4,8hs,sim,8i5,cong,8i8,asymp,8j0,ne,8j1,equiv,8j4,le,8j5,ge,8k2,sub,8k3,sup,8k4,' +\n            'nsub,8k6,sube,8k7,supe,8kl,oplus,8kn,otimes,8l5,perp,8m5,sdot,8o8,lceil,8o9,rceil,8oa,lfloor,8ob,' +\n            'rfloor,8p9,lang,8pa,rang,9ea,loz,9j0,spades,9j3,clubs,9j5,hearts,9j6,diams,ai,OElig,aj,oelig,b0,' +\n            'Scaron,b1,scaron,bo,Yuml,m6,circ,ms,tilde,802,ensp,803,emsp,809,thinsp,80c,zwnj,80d,zwj,80e,lrm,' +\n            '80f,rlm,80j,ndash,80k,mdash,80o,lsquo,80p,rsquo,80q,sbquo,80s,ldquo,80t,rdquo,80u,bdquo,810,dagger,' +\n            '811,Dagger,81g,permil,81p,lsaquo,81q,rsaquo,85c,euro', 32);\n\n\n    //Some basic mappings for attributes and default values.\n    STYLES = {\n        \"strokeStyle\":{\n            svgAttr : \"stroke\", //corresponding svg attribute\n            canvas : \"#000000\", //canvas default\n            svg : \"none\",       //svg default\n            apply : \"stroke\"    //apply on stroke() or fill()\n        },\n        \"fillStyle\":{\n            svgAttr : \"fill\",\n            canvas : \"#000000\",\n            svg : null, //svg default is black, but we need to special case this to handle canvas stroke without fill\n            apply : \"fill\"\n        },\n        \"lineCap\":{\n            svgAttr : \"stroke-linecap\",\n            canvas : \"butt\",\n            svg : \"butt\",\n            apply : \"stroke\"\n        },\n        \"lineJoin\":{\n            svgAttr : \"stroke-linejoin\",\n            canvas : \"miter\",\n            svg : \"miter\",\n            apply : \"stroke\"\n        },\n        \"miterLimit\":{\n            svgAttr : \"stroke-miterlimit\",\n            canvas : 10,\n            svg : 4,\n            apply : \"stroke\"\n        },\n        \"lineWidth\":{\n            svgAttr : \"stroke-width\",\n            canvas : 1,\n            svg : 1,\n            apply : \"stroke\"\n        },\n        \"globalAlpha\": {\n            svgAttr : \"opacity\",\n            canvas : 1,\n            svg : 1,\n            apply :  \"fill stroke\"\n        },\n        \"font\":{\n            //font converts to multiple svg attributes, there is custom logic for this\n            canvas : \"10px sans-serif\"\n        },\n        \"shadowColor\":{\n            canvas : \"#000000\"\n        },\n        \"shadowOffsetX\":{\n            canvas : 0\n        },\n        \"shadowOffsetY\":{\n            canvas : 0\n        },\n        \"shadowBlur\":{\n            canvas : 0\n        },\n        \"textAlign\":{\n            canvas : \"start\"\n        },\n        \"textBaseline\":{\n            canvas : \"alphabetic\"\n        },\n        \"lineDash\" : {\n            svgAttr : \"stroke-dasharray\",\n            canvas : [],\n            svg : null,\n            apply : \"stroke\"\n        }\n    };\n\n    /**\n     *\n     * @param gradientNode - reference to the gradient\n     * @constructor\n     */\n    CanvasGradient = function (gradientNode, ctx) {\n        this.__root = gradientNode;\n        this.__ctx = ctx;\n    };\n\n    /**\n     * Adds a color stop to the gradient root\n     */\n    CanvasGradient.prototype.addColorStop = function (offset, color) {\n        var stop = this.__ctx.__createElement(\"stop\"), regex, matches;\n        stop.setAttribute(\"offset\", offset);\n        if (color.indexOf(\"rgba\") !== -1) {\n            //separate alpha value, since webkit can't handle it\n            regex = /rgba\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d?\\.?\\d*)\\s*\\)/gi;\n            matches = regex.exec(color);\n            stop.setAttribute(\"stop-color\", format(\"rgb({r},{g},{b})\", {r:matches[1], g:matches[2], b:matches[3]}));\n            stop.setAttribute(\"stop-opacity\", matches[4]);\n        } else {\n            stop.setAttribute(\"stop-color\", color);\n        }\n        this.__root.appendChild(stop);\n    };\n\n    CanvasPattern = function (pattern, ctx) {\n        this.__root = pattern;\n        this.__ctx = ctx;\n    };\n\n    /**\n     * The mock canvas context\n     * @param o - options include:\n     * ctx - existing Context2D to wrap around\n     * width - width of your canvas (defaults to 500)\n     * height - height of your canvas (defaults to 500)\n     * enableMirroring - enables canvas mirroring (get image data) (defaults to false)\n     * document - the document object (defaults to the current document)\n     */\n    ctx = function (o) {\n        var defaultOptions = { width:500, height:500, enableMirroring : false}, options;\n\n        //keep support for this way of calling C2S: new C2S(width,height)\n        if (arguments.length > 1) {\n            options = defaultOptions;\n            options.width = arguments[0];\n            options.height = arguments[1];\n        } else if ( !o ) {\n            options = defaultOptions;\n        } else {\n            options = o;\n        }\n\n        if (!(this instanceof ctx)) {\n            //did someone call this without new?\n            return new ctx(options);\n        }\n\n        //setup options\n        this.width = options.width || defaultOptions.width;\n        this.height = options.height || defaultOptions.height;\n        this.enableMirroring = options.enableMirroring !== undefined ? options.enableMirroring : defaultOptions.enableMirroring;\n\n        this.canvas = this;   ///point back to this instance!\n        this.__document = options.document || document;\n\n        // allow passing in an existing context to wrap around\n        // if a context is passed in, we know a canvas already exist\n        if (options.ctx) {\n            this.__ctx = options.ctx;\n        } else {\n            this.__canvas = this.__document.createElement(\"canvas\");\n            this.__ctx = this.__canvas.getContext(\"2d\");\n        }\n\n        this.__setDefaultStyles();\n        this.__stack = [this.__getStyleState()];\n        this.__groupStack = [];\n\n        //the root svg element\n        this.__root = this.__document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n        this.__root.setAttribute(\"version\", 1.1);\n        this.__root.setAttribute(\"xmlns\", \"http://www.w3.org/2000/svg\");\n        this.__root.setAttributeNS(\"http://www.w3.org/2000/xmlns/\", \"xmlns:xlink\", \"http://www.w3.org/1999/xlink\");\n        this.__root.setAttribute(\"width\", this.width);\n        this.__root.setAttribute(\"height\", this.height);\n\n        //make sure we don't generate the same ids in defs\n        this.__ids = {};\n\n        //defs tag\n        this.__defs = this.__document.createElementNS(\"http://www.w3.org/2000/svg\", \"defs\");\n        this.__root.appendChild(this.__defs);\n\n        //also add a group child. the svg element can't use the transform attribute\n        this.__currentElement = this.__document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\");\n        this.__root.appendChild(this.__currentElement);\n    };\n\n\n    /**\n     * Creates the specified svg element\n     * @private\n     */\n    ctx.prototype.__createElement = function (elementName, properties, resetFill) {\n        if (typeof properties === \"undefined\") {\n            properties = {};\n        }\n\n        var element = this.__document.createElementNS(\"http://www.w3.org/2000/svg\", elementName),\n            keys = Object.keys(properties), i, key;\n        if (resetFill) {\n            //if fill or stroke is not specified, the svg element should not display. By default SVG's fill is black.\n            element.setAttribute(\"fill\", \"none\");\n            element.setAttribute(\"stroke\", \"none\");\n        }\n        for (i=0; i<keys.length; i++) {\n            key = keys[i];\n            element.setAttribute(key, properties[key]);\n        }\n        return element;\n    };\n\n    /**\n     * Applies default canvas styles to the context\n     * @private\n     */\n    ctx.prototype.__setDefaultStyles = function () {\n        //default 2d canvas context properties see:http://www.w3.org/TR/2dcontext/\n        var keys = Object.keys(STYLES), i, key;\n        for (i=0; i<keys.length; i++) {\n            key = keys[i];\n            this[key] = STYLES[key].canvas;\n        }\n    };\n\n    /**\n     * Applies styles on restore\n     * @param styleState\n     * @private\n     */\n    ctx.prototype.__applyStyleState = function (styleState) {\n        var keys = Object.keys(styleState), i, key;\n        for (i=0; i<keys.length; i++) {\n            key = keys[i];\n            this[key] = styleState[key];\n        }\n    };\n\n    /**\n     * Gets the current style state\n     * @return {Object}\n     * @private\n     */\n    ctx.prototype.__getStyleState = function () {\n        var i, styleState = {}, keys = Object.keys(STYLES), key;\n        for (i=0; i<keys.length; i++) {\n            key = keys[i];\n            styleState[key] = this[key];\n        }\n        return styleState;\n    };\n\n    /**\n     * Apples the current styles to the current SVG element. On \"ctx.fill\" or \"ctx.stroke\"\n     * @param type\n     * @private\n     */\n    ctx.prototype.__applyStyleToCurrentElement = function (type) {\n    \tvar currentElement = this.__currentElement;\n    \tvar currentStyleGroup = this.__currentElementsToStyle;\n    \tif (currentStyleGroup) {\n    \t\tcurrentElement.setAttribute(type, \"\");\n    \t\tcurrentElement = currentStyleGroup.element;\n    \t\tcurrentStyleGroup.children.forEach(function (node) {\n    \t\t\tnode.setAttribute(type, \"\");\n    \t\t})\n    \t}\n\n        var keys = Object.keys(STYLES), i, style, value, id, regex, matches;\n        for (i = 0; i < keys.length; i++) {\n            style = STYLES[keys[i]];\n            value = this[keys[i]];\n            if (style.apply) {\n                //is this a gradient or pattern?\n                if (value instanceof CanvasPattern) {\n                    //pattern\n                    if (value.__ctx) {\n                        //copy over defs\n                        while(value.__ctx.__defs.childNodes.length) {\n                            id = value.__ctx.__defs.childNodes[0].getAttribute(\"id\");\n                            this.__ids[id] = id;\n                            this.__defs.appendChild(value.__ctx.__defs.childNodes[0]);\n                        }\n                    }\n                    currentElement.setAttribute(style.apply, format(\"url(#{id})\", {id:value.__root.getAttribute(\"id\")}));\n                }\n                else if (value instanceof CanvasGradient) {\n                    //gradient\n                    currentElement.setAttribute(style.apply, format(\"url(#{id})\", {id:value.__root.getAttribute(\"id\")}));\n                } else if (style.apply.indexOf(type)!==-1 && style.svg !== value) {\n                    if ((style.svgAttr === \"stroke\" || style.svgAttr === \"fill\") && value.indexOf(\"rgba\") !== -1) {\n                        //separate alpha value, since illustrator can't handle it\n                        regex = /rgba\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d?\\.?\\d*)\\s*\\)/gi;\n                        matches = regex.exec(value);\n                        currentElement.setAttribute(style.svgAttr, format(\"rgb({r},{g},{b})\", {r:matches[1], g:matches[2], b:matches[3]}));\n                        //should take globalAlpha here\n                        var opacity = matches[4];\n                        var globalAlpha = this.globalAlpha;\n                        if (globalAlpha != null) {\n                            opacity *= globalAlpha;\n                        }\n                        currentElement.setAttribute(style.svgAttr+\"-opacity\", opacity);\n                    } else {\n                        var attr = style.svgAttr;\n                        if (keys[i] === 'globalAlpha') {\n                            attr = type+'-'+style.svgAttr;\n                            if (currentElement.getAttribute(attr)) {\n                                 //fill-opacity or stroke-opacity has already been set by stroke or fill.\n                                continue;\n                            }\n                        }\n                        //otherwise only update attribute if right type, and not svg default\n                        currentElement.setAttribute(attr, value);\n                    }\n                }\n            }\n        }\n    };\n\n    /**\n     * Will return the closest group or svg node. May return the current element.\n     * @private\n     */\n    ctx.prototype.__closestGroupOrSvg = function (node) {\n        node = node || this.__currentElement;\n        if (node.nodeName === \"g\" || node.nodeName === \"svg\") {\n            return node;\n        } else {\n            return this.__closestGroupOrSvg(node.parentNode);\n        }\n    };\n\n    /**\n     * Returns the serialized value of the svg so far\n     * @param fixNamedEntities - Standalone SVG doesn't support named entities, which document.createTextNode encodes.\n     *                           If true, we attempt to find all named entities and encode it as a numeric entity.\n     * @return serialized svg\n     */\n    ctx.prototype.getSerializedSvg = function (fixNamedEntities) {\n        var serialized = new XMLSerializer().serializeToString(this.__root),\n            keys, i, key, value, regexp, xmlns;\n\n        //IE search for a duplicate xmnls because they didn't implement setAttributeNS correctly\n        xmlns = /xmlns=\"http:\\/\\/www\\.w3\\.org\\/2000\\/svg\".+xmlns=\"http:\\/\\/www\\.w3\\.org\\/2000\\/svg/gi;\n        if (xmlns.test(serialized)) {\n            serialized = serialized.replace('xmlns=\"http://www.w3.org/2000/svg','xmlns:xlink=\"http://www.w3.org/1999/xlink');\n        }\n\n        if (fixNamedEntities) {\n            keys = Object.keys(namedEntities);\n            //loop over each named entity and replace with the proper equivalent.\n            for (i=0; i<keys.length; i++) {\n                key = keys[i];\n                value = namedEntities[key];\n                regexp = new RegExp(key, \"gi\");\n                if (regexp.test(serialized)) {\n                    serialized = serialized.replace(regexp, value);\n                }\n            }\n        }\n\n        return serialized;\n    };\n\n\n    /**\n     * Returns the root svg\n     * @return\n     */\n    ctx.prototype.getSvg = function () {\n        return this.__root;\n    };\n    /**\n     * Will generate a group tag.\n     */\n    ctx.prototype.save = function () {\n        var group = this.__createElement(\"g\");\n        var parent = this.__closestGroupOrSvg();\n        this.__groupStack.push(parent);\n        parent.appendChild(group);\n        this.__currentElement = group;\n        this.__stack.push(this.__getStyleState());\n    };\n    /**\n     * Sets current element to parent, or just root if already root\n     */\n    ctx.prototype.restore = function () {\n        this.__currentElement = this.__groupStack.pop();\n        this.__currentElementsToStyle = null;\n        //Clearing canvas will make the poped group invalid, currentElement is set to the root group node.\n        if (!this.__currentElement) {\n            this.__currentElement = this.__root.childNodes[1];\n        }\n        var state = this.__stack.pop();\n        this.__applyStyleState(state);\n    };\n\n    /**\n     * Helper method to add transform\n     * @private\n     */\n    ctx.prototype.__addTransform = function (t) {\n        //if the current element has siblings, add another group\n        var parent = this.__closestGroupOrSvg();\n        if (parent.childNodes.length > 0) {\n        \tif (this.__currentElement.nodeName === \"path\") {\n        \t\tif (!this.__currentElementsToStyle) this.__currentElementsToStyle = {element: parent, children: []};\n        \t\tthis.__currentElementsToStyle.children.push(this.__currentElement)\n        \t\tthis.__applyCurrentDefaultPath();\n        \t}\n\n            var group = this.__createElement(\"g\");\n            parent.appendChild(group);\n            this.__currentElement = group;\n        }\n\n        var transform = this.__currentElement.getAttribute(\"transform\");\n        if (transform) {\n            transform += \" \";\n        } else {\n            transform = \"\";\n        }\n        transform += t;\n        this.__currentElement.setAttribute(\"transform\", transform);\n    };\n\n    /**\n     *  scales the current element\n     */\n    ctx.prototype.scale = function (x, y) {\n        if (y === undefined) {\n            y = x;\n        }\n        this.__addTransform(format(\"scale({x},{y})\", {x:x, y:y}));\n    };\n\n    /**\n     * rotates the current element\n     */\n    ctx.prototype.rotate = function (angle) {\n        var degrees = (angle * 180 / Math.PI);\n        this.__addTransform(format(\"rotate({angle},{cx},{cy})\", {angle:degrees, cx:0, cy:0}));\n    };\n\n    /**\n     * translates the current element\n     */\n    ctx.prototype.translate = function (x, y) {\n        this.__addTransform(format(\"translate({x},{y})\", {x:x,y:y}));\n    };\n\n    /**\n     * applies a transform to the current element\n     */\n    ctx.prototype.transform = function (a, b, c, d, e, f) {\n        this.__addTransform(format(\"matrix({a},{b},{c},{d},{e},{f})\", {a:a, b:b, c:c, d:d, e:e, f:f}));\n    };\n\n    /**\n     * Create a new Path Element\n     */\n    ctx.prototype.beginPath = function () {\n        var path, parent;\n\n        // Note that there is only one current default path, it is not part of the drawing state.\n        // See also: https://html.spec.whatwg.org/multipage/scripting.html#current-default-path\n        this.__currentDefaultPath = \"\";\n        this.__currentPosition = {};\n\n        path = this.__createElement(\"path\", {}, true);\n        parent = this.__closestGroupOrSvg();\n        parent.appendChild(path);\n        this.__currentElement = path;\n    };\n\n    /**\n     * Helper function to apply currentDefaultPath to current path element\n     * @private\n     */\n    ctx.prototype.__applyCurrentDefaultPath = function () {\n    \tvar currentElement = this.__currentElement;\n        if (currentElement.nodeName === \"path\") {\n\t\t\tcurrentElement.setAttribute(\"d\", this.__currentDefaultPath);\n        } else {\n\t\t\tconsole.error(\"Attempted to apply path command to node\", currentElement.nodeName);\n        }\n    };\n\n    /**\n     * Helper function to add path command\n     * @private\n     */\n    ctx.prototype.__addPathCommand = function (command) {\n        this.__currentDefaultPath += \" \";\n        this.__currentDefaultPath += command;\n    };\n\n    /**\n     * Adds the move command to the current path element,\n     * if the currentPathElement is not empty create a new path element\n     */\n    ctx.prototype.moveTo = function (x,y) {\n        if (this.__currentElement.nodeName !== \"path\") {\n            this.beginPath();\n        }\n\n        // creates a new subpath with the given point\n        this.__currentPosition = {x: x, y: y};\n        this.__addPathCommand(format(\"M {x} {y}\", {x:x, y:y}));\n    };\n\n    /**\n     * Closes the current path\n     */\n    ctx.prototype.closePath = function () {\n        if (this.__currentDefaultPath) {\n            this.__addPathCommand(\"Z\");\n        }\n    };\n\n    /**\n     * Adds a line to command\n     */\n    ctx.prototype.lineTo = function (x, y) {\n        this.__currentPosition = {x: x, y: y};\n        if (this.__currentDefaultPath.indexOf('M') > -1) {\n            this.__addPathCommand(format(\"L {x} {y}\", {x:x, y:y}));\n        } else {\n            this.__addPathCommand(format(\"M {x} {y}\", {x:x, y:y}));\n        }\n    };\n\n    /**\n     * Add a bezier command\n     */\n    ctx.prototype.bezierCurveTo = function (cp1x, cp1y, cp2x, cp2y, x, y) {\n        this.__currentPosition = {x: x, y: y};\n        this.__addPathCommand(format(\"C {cp1x} {cp1y} {cp2x} {cp2y} {x} {y}\",\n            {cp1x:cp1x, cp1y:cp1y, cp2x:cp2x, cp2y:cp2y, x:x, y:y}));\n    };\n\n    /**\n     * Adds a quadratic curve to command\n     */\n    ctx.prototype.quadraticCurveTo = function (cpx, cpy, x, y) {\n        this.__currentPosition = {x: x, y: y};\n        this.__addPathCommand(format(\"Q {cpx} {cpy} {x} {y}\", {cpx:cpx, cpy:cpy, x:x, y:y}));\n    };\n\n\n    /**\n     * Return a new normalized vector of given vector\n     */\n    var normalize = function (vector) {\n        var len = Math.sqrt(vector[0] * vector[0] + vector[1] * vector[1]);\n        return [vector[0] / len, vector[1] / len];\n    };\n\n    /**\n     * Adds the arcTo to the current path\n     *\n     * @see http://www.w3.org/TR/2015/WD-2dcontext-20150514/#dom-context-2d-arcto\n     */\n    ctx.prototype.arcTo = function (x1, y1, x2, y2, radius) {\n        // Let the point (x0, y0) be the last point in the subpath.\n        var x0 = this.__currentPosition && this.__currentPosition.x;\n        var y0 = this.__currentPosition && this.__currentPosition.y;\n\n        // First ensure there is a subpath for (x1, y1).\n        if (typeof x0 == \"undefined\" || typeof y0 == \"undefined\") {\n            return;\n        }\n\n        // Negative values for radius must cause the implementation to throw an IndexSizeError exception.\n        if (radius < 0) {\n            throw new Error(\"IndexSizeError: The radius provided (\" + radius + \") is negative.\");\n        }\n\n        // If the point (x0, y0) is equal to the point (x1, y1),\n        // or if the point (x1, y1) is equal to the point (x2, y2),\n        // or if the radius radius is zero,\n        // then the method must add the point (x1, y1) to the subpath,\n        // and connect that point to the previous point (x0, y0) by a straight line.\n        if (((x0 === x1) && (y0 === y1))\n            || ((x1 === x2) && (y1 === y2))\n            || (radius === 0)) {\n            this.lineTo(x1, y1);\n            return;\n        }\n\n        // Otherwise, if the points (x0, y0), (x1, y1), and (x2, y2) all lie on a single straight line,\n        // then the method must add the point (x1, y1) to the subpath,\n        // and connect that point to the previous point (x0, y0) by a straight line.\n        var unit_vec_p1_p0 = normalize([x0 - x1, y0 - y1]);\n        var unit_vec_p1_p2 = normalize([x2 - x1, y2 - y1]);\n        if (unit_vec_p1_p0[0] * unit_vec_p1_p2[1] === unit_vec_p1_p0[1] * unit_vec_p1_p2[0]) {\n            this.lineTo(x1, y1);\n            return;\n        }\n\n        // Otherwise, let The Arc be the shortest arc given by circumference of the circle that has radius radius,\n        // and that has one point tangent to the half-infinite line that crosses the point (x0, y0) and ends at the point (x1, y1),\n        // and that has a different point tangent to the half-infinite line that ends at the point (x1, y1), and crosses the point (x2, y2).\n        // The points at which this circle touches these two lines are called the start and end tangent points respectively.\n\n        // note that both vectors are unit vectors, so the length is 1\n        var cos = (unit_vec_p1_p0[0] * unit_vec_p1_p2[0] + unit_vec_p1_p0[1] * unit_vec_p1_p2[1]);\n        var theta = Math.acos(Math.abs(cos));\n\n        // Calculate origin\n        var unit_vec_p1_origin = normalize([\n            unit_vec_p1_p0[0] + unit_vec_p1_p2[0],\n            unit_vec_p1_p0[1] + unit_vec_p1_p2[1]\n        ]);\n        var len_p1_origin = radius / Math.sin(theta / 2);\n        var x = x1 + len_p1_origin * unit_vec_p1_origin[0];\n        var y = y1 + len_p1_origin * unit_vec_p1_origin[1];\n\n        // Calculate start angle and end angle\n        // rotate 90deg clockwise (note that y axis points to its down)\n        var unit_vec_origin_start_tangent = [\n            -unit_vec_p1_p0[1],\n            unit_vec_p1_p0[0]\n        ];\n        // rotate 90deg counter clockwise (note that y axis points to its down)\n        var unit_vec_origin_end_tangent = [\n            unit_vec_p1_p2[1],\n            -unit_vec_p1_p2[0]\n        ];\n        var getAngle = function (vector) {\n            // get angle (clockwise) between vector and (1, 0)\n            var x = vector[0];\n            var y = vector[1];\n            if (y >= 0) { // note that y axis points to its down\n                return Math.acos(x);\n            } else {\n                return -Math.acos(x);\n            }\n        };\n        var startAngle = getAngle(unit_vec_origin_start_tangent);\n        var endAngle = getAngle(unit_vec_origin_end_tangent);\n\n        // Connect the point (x0, y0) to the start tangent point by a straight line\n        this.lineTo(x + unit_vec_origin_start_tangent[0] * radius,\n                    y + unit_vec_origin_start_tangent[1] * radius);\n\n        // Connect the start tangent point to the end tangent point by arc\n        // and adding the end tangent point to the subpath.\n        this.arc(x, y, radius, startAngle, endAngle);\n    };\n\n    /**\n     * Sets the stroke property on the current element\n     */\n    ctx.prototype.stroke = function () {\n        if (this.__currentElement.nodeName === \"path\") {\n            this.__currentElement.setAttribute(\"paint-order\", \"fill stroke markers\");\n        }\n        this.__applyCurrentDefaultPath();\n        this.__applyStyleToCurrentElement(\"stroke\");\n    };\n\n    /**\n     * Sets fill properties on the current element\n     */\n    ctx.prototype.fill = function () {\n        if (this.__currentElement.nodeName === \"path\") {\n            this.__currentElement.setAttribute(\"paint-order\", \"stroke fill markers\");\n        }\n        this.__applyCurrentDefaultPath();\n        this.__applyStyleToCurrentElement(\"fill\");\n    };\n\n    /**\n     *  Adds a rectangle to the path.\n     */\n    ctx.prototype.rect = function (x, y, width, height) {\n        if (this.__currentElement.nodeName !== \"path\") {\n            this.beginPath();\n        }\n        this.moveTo(x, y);\n        this.lineTo(x+width, y);\n        this.lineTo(x+width, y+height);\n        this.lineTo(x, y+height);\n        this.lineTo(x, y);\n        this.closePath();\n    };\n\n\n    /**\n     * adds a rectangle element\n     */\n    ctx.prototype.fillRect = function (x, y, width, height) {\n        var rect, parent;\n        rect = this.__createElement(\"rect\", {\n            x : x,\n            y : y,\n            width : width,\n            height : height\n        }, true);\n        parent = this.__closestGroupOrSvg();\n        parent.appendChild(rect);\n        this.__currentElement = rect;\n        this.__applyStyleToCurrentElement(\"fill\");\n    };\n\n    /**\n     * Draws a rectangle with no fill\n     * @param x\n     * @param y\n     * @param width\n     * @param height\n     */\n    ctx.prototype.strokeRect = function (x, y, width, height) {\n        var rect, parent;\n        rect = this.__createElement(\"rect\", {\n            x : x,\n            y : y,\n            width : width,\n            height : height\n        }, true);\n        parent = this.__closestGroupOrSvg();\n        parent.appendChild(rect);\n        this.__currentElement = rect;\n        this.__applyStyleToCurrentElement(\"stroke\");\n    };\n\n\n    /**\n     * Clear entire canvas:\n     * 1. save current transforms\n     * 2. remove all the childNodes of the root g element\n     */\n    ctx.prototype.__clearCanvas = function () {\n        var current = this.__closestGroupOrSvg(),\n            transform = current.getAttribute(\"transform\");\n        var rootGroup = this.__root.childNodes[1];\n        var childNodes = rootGroup.childNodes;\n        for (var i = childNodes.length - 1; i >= 0; i--) {\n            if (childNodes[i]) {\n                rootGroup.removeChild(childNodes[i]);\n            }\n        }\n        this.__currentElement = rootGroup;\n        //reset __groupStack as all the child group nodes are all removed.\n        this.__groupStack = [];\n        if (transform) {\n            this.__addTransform(transform);\n        }\n    };\n\n    /**\n     * \"Clears\" a canvas by just drawing a white rectangle in the current group.\n     */\n    ctx.prototype.clearRect = function (x, y, width, height) {\n        //clear entire canvas\n        if (x === 0 && y === 0 && width === this.width && height === this.height) {\n            this.__clearCanvas();\n            return;\n        }\n        var rect, parent = this.__closestGroupOrSvg();\n        rect = this.__createElement(\"rect\", {\n            x : x,\n            y : y,\n            width : width,\n            height : height,\n            fill : \"#FFFFFF\"\n        }, true);\n        parent.appendChild(rect);\n    };\n\n    /**\n     * Adds a linear gradient to a defs tag.\n     * Returns a canvas gradient object that has a reference to it's parent def\n     */\n    ctx.prototype.createLinearGradient = function (x1, y1, x2, y2) {\n        var grad = this.__createElement(\"linearGradient\", {\n            id : randomString(this.__ids),\n            x1 : x1+\"px\",\n            x2 : x2+\"px\",\n            y1 : y1+\"px\",\n            y2 : y2+\"px\",\n            \"gradientUnits\" : \"userSpaceOnUse\"\n        }, false);\n        this.__defs.appendChild(grad);\n        return new CanvasGradient(grad, this);\n    };\n\n    /**\n     * Adds a radial gradient to a defs tag.\n     * Returns a canvas gradient object that has a reference to it's parent def\n     */\n    ctx.prototype.createRadialGradient = function (x0, y0, r0, x1, y1, r1) {\n        var grad = this.__createElement(\"radialGradient\", {\n            id : randomString(this.__ids),\n            cx : x1+\"px\",\n            cy : y1+\"px\",\n            r  : r1+\"px\",\n            fx : x0+\"px\",\n            fy : y0+\"px\",\n            \"gradientUnits\" : \"userSpaceOnUse\"\n        }, false);\n        this.__defs.appendChild(grad);\n        return new CanvasGradient(grad, this);\n\n    };\n\n    /**\n     * Parses the font string and returns svg mapping\n     * @private\n     */\n    ctx.prototype.__parseFont = function () {\n        var regex = /^\\s*(?=(?:(?:[-a-z]+\\s*){0,2}(italic|oblique))?)(?=(?:(?:[-a-z]+\\s*){0,2}(small-caps))?)(?=(?:(?:[-a-z]+\\s*){0,2}(bold(?:er)?|lighter|[1-9]00))?)(?:(?:normal|\\1|\\2|\\3)\\s*){0,3}((?:xx?-)?(?:small|large)|medium|smaller|larger|[.\\d]+(?:\\%|in|[cem]m|ex|p[ctx]))(?:\\s*\\/\\s*(normal|[.\\d]+(?:\\%|in|[cem]m|ex|p[ctx])))?\\s*([-,\\'\\\"\\sa-z0-9]+?)\\s*$/i;\n        var fontPart = regex.exec( this.font );\n        var data = {\n            style : fontPart[1] || 'normal',\n            size : fontPart[4] || '10px',\n            family : fontPart[6] || 'sans-serif',\n            weight: fontPart[3] || 'normal',\n            decoration : fontPart[2] || 'normal',\n            href : null\n        };\n\n        //canvas doesn't support underline natively, but we can pass this attribute\n        if (this.__fontUnderline === \"underline\") {\n            data.decoration = \"underline\";\n        }\n\n        //canvas also doesn't support linking, but we can pass this as well\n        if (this.__fontHref) {\n            data.href = this.__fontHref;\n        }\n\n        return data;\n    };\n\n    /**\n     * Helper to link text fragments\n     * @param font\n     * @param element\n     * @return {*}\n     * @private\n     */\n    ctx.prototype.__wrapTextLink = function (font, element) {\n        if (font.href) {\n            var a = this.__createElement(\"a\");\n            a.setAttributeNS(\"http://www.w3.org/1999/xlink\", \"xlink:href\", font.href);\n            a.appendChild(element);\n            return a;\n        }\n        return element;\n    };\n\n    /**\n     * Fills or strokes text\n     * @param text\n     * @param x\n     * @param y\n     * @param action - stroke or fill\n     * @private\n     */\n    ctx.prototype.__applyText = function (text, x, y, action) {\n        var font = this.__parseFont(),\n            parent = this.__closestGroupOrSvg(),\n            textElement = this.__createElement(\"text\", {\n                \"font-family\" : font.family,\n                \"font-size\" : font.size,\n                \"font-style\" : font.style,\n                \"font-weight\" : font.weight,\n                \"text-decoration\" : font.decoration,\n                \"x\" : x,\n                \"y\" : y,\n                \"text-anchor\": getTextAnchor(this.textAlign),\n                \"dominant-baseline\": getDominantBaseline(this.textBaseline)\n            }, true);\n\n        textElement.appendChild(this.__document.createTextNode(text));\n        this.__currentElement = textElement;\n        this.__applyStyleToCurrentElement(action);\n        parent.appendChild(this.__wrapTextLink(font,textElement));\n    };\n\n    /**\n     * Creates a text element\n     * @param text\n     * @param x\n     * @param y\n     */\n    ctx.prototype.fillText = function (text, x, y) {\n        this.__applyText(text, x, y, \"fill\");\n    };\n\n    /**\n     * Strokes text\n     * @param text\n     * @param x\n     * @param y\n     */\n    ctx.prototype.strokeText = function (text, x, y) {\n        this.__applyText(text, x, y, \"stroke\");\n    };\n\n    /**\n     * No need to implement this for svg.\n     * @param text\n     * @return {TextMetrics}\n     */\n    ctx.prototype.measureText = function (text) {\n        this.__ctx.font = this.font;\n        return this.__ctx.measureText(text);\n    };\n\n    /**\n     *  Arc command!\n     */\n    ctx.prototype.arc = function (x, y, radius, startAngle, endAngle, counterClockwise) {\n        // in canvas no circle is drawn if no angle is provided.\n        if (startAngle === endAngle) {\n            return;\n        }\n        startAngle = startAngle % (2*Math.PI);\n        endAngle = endAngle % (2*Math.PI);\n        if (startAngle === endAngle) {\n            //circle time! subtract some of the angle so svg is happy (svg elliptical arc can't draw a full circle)\n            endAngle = ((endAngle + (2*Math.PI)) - 0.001 * (counterClockwise ? -1 : 1)) % (2*Math.PI);\n        }\n        var endX = x+radius*Math.cos(endAngle),\n            endY = y+radius*Math.sin(endAngle),\n            startX = x+radius*Math.cos(startAngle),\n            startY = y+radius*Math.sin(startAngle),\n            sweepFlag = counterClockwise ? 0 : 1,\n            largeArcFlag = 0,\n            diff = endAngle - startAngle;\n\n        // https://github.com/gliffy/canvas2svg/issues/4\n        if (diff < 0) {\n            diff += 2*Math.PI;\n        }\n\n        if (counterClockwise) {\n            largeArcFlag = diff > Math.PI ? 0 : 1;\n        } else {\n            largeArcFlag = diff > Math.PI ? 1 : 0;\n        }\n\n        this.lineTo(startX, startY);\n        this.__addPathCommand(format(\"A {rx} {ry} {xAxisRotation} {largeArcFlag} {sweepFlag} {endX} {endY}\",\n            {rx:radius, ry:radius, xAxisRotation:0, largeArcFlag:largeArcFlag, sweepFlag:sweepFlag, endX:endX, endY:endY}));\n\n        this.__currentPosition = {x: endX, y: endY};\n    };\n\n    /**\n     * Generates a ClipPath from the clip command.\n     */\n    ctx.prototype.clip = function () {\n        var group = this.__closestGroupOrSvg(),\n            clipPath = this.__createElement(\"clipPath\"),\n            id =  randomString(this.__ids),\n            newGroup = this.__createElement(\"g\");\n\n        this.__applyCurrentDefaultPath();\n        group.removeChild(this.__currentElement);\n        clipPath.setAttribute(\"id\", id);\n        clipPath.appendChild(this.__currentElement);\n\n        this.__defs.appendChild(clipPath);\n\n        //set the clip path to this group\n        group.setAttribute(\"clip-path\", format(\"url(#{id})\", {id:id}));\n\n        //clip paths can be scaled and transformed, we need to add another wrapper group to avoid later transformations\n        // to this path\n        group.appendChild(newGroup);\n\n        this.__currentElement = newGroup;\n\n    };\n\n    /**\n     * Draws a canvas, image or mock context to this canvas.\n     * Note that all svg dom manipulation uses node.childNodes rather than node.children for IE support.\n     * http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-drawimage\n     */\n    ctx.prototype.drawImage = function () {\n        //convert arguments to a real array\n        var args = Array.prototype.slice.call(arguments),\n            image=args[0],\n            dx, dy, dw, dh, sx=0, sy=0, sw, sh, parent, svg, defs, group,\n            currentElement, svgImage, canvas, context, id;\n\n        if (args.length === 3) {\n            dx = args[1];\n            dy = args[2];\n            sw = image.width;\n            sh = image.height;\n            dw = sw;\n            dh = sh;\n        } else if (args.length === 5) {\n            dx = args[1];\n            dy = args[2];\n            dw = args[3];\n            dh = args[4];\n            sw = image.width;\n            sh = image.height;\n        } else if (args.length === 9) {\n            sx = args[1];\n            sy = args[2];\n            sw = args[3];\n            sh = args[4];\n            dx = args[5];\n            dy = args[6];\n            dw = args[7];\n            dh = args[8];\n        } else {\n            throw new Error(\"Invalid number of arguments passed to drawImage: \" + arguments.length);\n        }\n\n        parent = this.__closestGroupOrSvg();\n        currentElement = this.__currentElement;\n        var translateDirective = \"translate(\" + dx + \", \" + dy + \")\";\n        if (image instanceof ctx) {\n            //canvas2svg mock canvas context. In the future we may want to clone nodes instead.\n            //also I'm currently ignoring dw, dh, sw, sh, sx, sy for a mock context.\n            svg = image.getSvg().cloneNode(true);\n            if (svg.childNodes && svg.childNodes.length > 1) {\n                defs = svg.childNodes[0];\n                while(defs.childNodes.length) {\n                    id = defs.childNodes[0].getAttribute(\"id\");\n                    this.__ids[id] = id;\n                    this.__defs.appendChild(defs.childNodes[0]);\n                }\n                group = svg.childNodes[1];\n                if (group) {\n                    //save original transform\n                    var originTransform = group.getAttribute(\"transform\");\n                    var transformDirective;\n                    if (originTransform) {\n                        transformDirective = originTransform+\" \"+translateDirective;\n                    } else {\n                        transformDirective = translateDirective;\n                    }\n                    group.setAttribute(\"transform\", transformDirective);\n                    parent.appendChild(group);\n                }\n            }\n        } else if (image.nodeName === \"CANVAS\" || image.nodeName === \"IMG\") {\n            //canvas or image\n            svgImage = this.__createElement(\"image\");\n            svgImage.setAttribute(\"width\", dw);\n            svgImage.setAttribute(\"height\", dh);\n            svgImage.setAttribute(\"preserveAspectRatio\", \"none\");\n\n            if (sx || sy || sw !== image.width || sh !== image.height) {\n                //crop the image using a temporary canvas\n                canvas = this.__document.createElement(\"canvas\");\n                canvas.width = dw;\n                canvas.height = dh;\n                context = canvas.getContext(\"2d\");\n                context.drawImage(image, sx, sy, sw, sh, 0, 0, dw, dh);\n                image = canvas;\n            }\n            svgImage.setAttribute(\"transform\", translateDirective);\n            svgImage.setAttributeNS(\"http://www.w3.org/1999/xlink\", \"xlink:href\",\n                image.nodeName === \"CANVAS\" ? image.toDataURL() : image.getAttribute(\"src\"));\n            parent.appendChild(svgImage);\n        }\n    };\n\n    /**\n     * Generates a pattern tag\n     */\n    ctx.prototype.createPattern = function (image, repetition) {\n        var pattern = this.__document.createElementNS(\"http://www.w3.org/2000/svg\", \"pattern\"), id = randomString(this.__ids),\n            img;\n        pattern.setAttribute(\"id\", id);\n        pattern.setAttribute(\"width\", image.width);\n        pattern.setAttribute(\"height\", image.height);\n        if (image.nodeName === \"CANVAS\" || image.nodeName === \"IMG\") {\n            img = this.__document.createElementNS(\"http://www.w3.org/2000/svg\", \"image\");\n            img.setAttribute(\"width\", image.width);\n            img.setAttribute(\"height\", image.height);\n            img.setAttributeNS(\"http://www.w3.org/1999/xlink\", \"xlink:href\",\n                image.nodeName === \"CANVAS\" ? image.toDataURL() : image.getAttribute(\"src\"));\n            pattern.appendChild(img);\n            this.__defs.appendChild(pattern);\n        } else if (image instanceof ctx) {\n            pattern.appendChild(image.__root.childNodes[1]);\n            this.__defs.appendChild(pattern);\n        }\n        return new CanvasPattern(pattern, this);\n    };\n\n    ctx.prototype.setLineDash = function (dashArray) {\n        if (dashArray && dashArray.length > 0) {\n            this.lineDash = dashArray.join(\",\");\n        } else {\n            this.lineDash = null;\n        }\n    };\n\n    /**\n     * Not yet implemented\n     */\n    ctx.prototype.drawFocusRing = function () {};\n    ctx.prototype.createImageData = function () {};\n    ctx.prototype.getImageData = function () {};\n    ctx.prototype.putImageData = function () {};\n    ctx.prototype.globalCompositeOperation = function () {};\n    ctx.prototype.setTransform = function () {};\n\n    //add options for alternative namespace\n    if (typeof window === \"object\") {\n        window.C2S = ctx;\n    }\n\n    // CommonJS/Browserify\n    if ( true && typeof module.exports === \"object\") {\n        module.exports = ctx;\n    }\n\n}());\n\n\n//# sourceURL=webpack://ArgoDG/./node_modules/canvas2svg/canvas2svg.js?");

/***/ }),

/***/ "./src/complex_geom.js":
/*!*****************************!*\
  !*** ./src/complex_geom.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CP1\": () => (/* reexport safe */ _complex_geom_cp1_js__WEBPACK_IMPORTED_MODULE_1__.CP1),\n/* harmony export */   \"Circline\": () => (/* reexport safe */ _complex_geom_circline_js__WEBPACK_IMPORTED_MODULE_4__.Circline),\n/* harmony export */   \"Complex\": () => (/* reexport safe */ _complex_geom_complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex),\n/* harmony export */   \"ComplexMatrix2x2\": () => (/* reexport safe */ _complex_geom_complex_matrix_js__WEBPACK_IMPORTED_MODULE_2__.ComplexMatrix2x2),\n/* harmony export */   \"INCLUDE_FICTIVE\": () => (/* reexport safe */ _complex_geom_circline_js__WEBPACK_IMPORTED_MODULE_4__.INCLUDE_FICTIVE),\n/* harmony export */   \"Moebius\": () => (/* reexport safe */ _complex_geom_moebius_js__WEBPACK_IMPORTED_MODULE_3__.Moebius),\n/* harmony export */   \"PoincareDisc\": () => (/* reexport safe */ _complex_geom_poincare_js__WEBPACK_IMPORTED_MODULE_5__.PoincareDisc),\n/* harmony export */   \"PoincareHalfPlane\": () => (/* reexport safe */ _complex_geom_poincare_js__WEBPACK_IMPORTED_MODULE_5__.PoincareHalfPlane)\n/* harmony export */ });\n/* harmony import */ var _complex_geom_complex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./complex_geom/complex.js */ \"./src/complex_geom/complex.js\");\n/* harmony import */ var _complex_geom_cp1_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./complex_geom/cp1.js */ \"./src/complex_geom/cp1.js\");\n/* harmony import */ var _complex_geom_complex_matrix_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./complex_geom/complex_matrix.js */ \"./src/complex_geom/complex_matrix.js\");\n/* harmony import */ var _complex_geom_moebius_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./complex_geom/moebius.js */ \"./src/complex_geom/moebius.js\");\n/* harmony import */ var _complex_geom_circline_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./complex_geom/circline.js */ \"./src/complex_geom/circline.js\");\n/* harmony import */ var _complex_geom_poincare_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./complex_geom/poincare.js */ \"./src/complex_geom/poincare.js\");\n\n\n\n\n\n\n\n\n//# sourceURL=webpack://ArgoDG/./src/complex_geom.js?");

/***/ }),

/***/ "./src/complex_geom/circline.js":
/*!**************************************!*\
  !*** ./src/complex_geom/circline.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Circline\": () => (/* binding */ Circline),\n/* harmony export */   \"INCLUDE_FICTIVE\": () => (/* binding */ INCLUDE_FICTIVE)\n/* harmony export */ });\n/* harmony import */ var _complex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./complex.js */ \"./src/complex_geom/complex.js\");\n/* harmony import */ var _cp1_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cp1.js */ \"./src/complex_geom/cp1.js\");\n/* harmony import */ var _complex_matrix_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./complex_matrix.js */ \"./src/complex_geom/complex_matrix.js\");\n/* harmony import */ var _moebius_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./moebius.js */ \"./src/complex_geom/moebius.js\");\n\n\n\n\n\nclass Circline {\n    // Circline is represented by a Hermitean matrix\n    constructor(A, B, C, D) {\n        if (arguments[0] instanceof _complex_matrix_js__WEBPACK_IMPORTED_MODULE_2__.ComplexMatrix2x2)\n            this.H = arguments[0];\n        else\n            this.H = new _complex_matrix_js__WEBPACK_IMPORTED_MODULE_2__.ComplexMatrix2x2(A, B, C, D);\n        this.normalize();\n    }\n\n    normalize() {\n        this.H = Circline.normalizeOriented(this.H);\n        this.H_unoriented = Circline.normalizeUnoriented(this.H);\n    }\n\n    // convert the H matrix to canonical form (used for easy circline comparison)\n    // A is set to 1 if possible,\n    // otherwise B is set to unit modulus and nonegative argument\n    // WARNING: this can change orientation\n    static normalizeUnoriented(H) {\n        if (!H.A.is_zero()) {\n            return H.multC(H.A.reciprocal());\n        } else {\n            const arg = H.B.arg();\n            if (0 <= arg && arg < Math.PI)\n                return H.multC(1 / H.B.norm());\n            else\n                return H.multC(- 1 / H.B.norm());\n        }\n    }\n\n    static normalizeOriented(H) {\n        if (!H.A.is_zero()) {\n            return H.multC(1 / H.A.norm());\n        } else {\n            return H.multC(1 / H.B.norm());\n        }\n    }\n\n\n    // Circline that represents an Euclidean circle with center in a (finite) complex number a\n    // that has a radius r\n    static mk_circle(a, r) {\n        return new Circline(_complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.one, a.uminus(),\n                            a.cnj().uminus(), a.mult(a.cnj()).sub(_complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.of_real(r*r)));\n    }\n\n    // Circline that represents an Euclidean line that joins two given (finite) complex numbers \n    static mk_line(z1, z2) {\n        const B = z2.sub(z1).mult(_complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.i);\n        return new Circline(_complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.zero, B,\n                            B.cnj(), _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.cnj_mix(B.uminus(), z1));\n    }\n\n    // Circline determined by tree points (either complex or CP1)\n    static mk_circline3(z1, z2, z3) {\n        if (!(z1 instanceof _cp1_js__WEBPACK_IMPORTED_MODULE_1__.CP1)) z1 = z1.cp1();\n        if (!(z2 instanceof _cp1_js__WEBPACK_IMPORTED_MODULE_1__.CP1)) z2 = z2.cp1();\n        if (!(z3 instanceof _cp1_js__WEBPACK_IMPORTED_MODULE_1__.CP1)) z3 = z3.cp1();\n        const M = _moebius_js__WEBPACK_IMPORTED_MODULE_3__.Moebius.moebius_01inf(z1, z2, z3);\n        return M.inv().moebius_circline(Circline.x_axis());\n    }\n\n    // oposite oriented circline\n    opposite() {\n        return new Circline(this.H.multC(-1));\n    }\n\n    // several special circlines\n    \n    static unit_circle() {\n        return new Circline(_complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.one, _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.zero, _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.zero, _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.minus_one);\n    }\n\n    static x_axis() {\n        return new Circline(_complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.zero, _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.i, _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.minus_i, _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.zero);\n    }\n\n    static y_axis() {\n        return new Circline(_complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.zero, _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.one, _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.one, _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.zero);\n    }\n\n    // check if this circline is an Euclidean line\n    is_line() {\n        return this.H.A.is_zero();\n    }\n\n    // check if this circline is an Euclidean circle\n    is_circle() {\n        return !this.is_line();\n    }\n\n    // Euclidean center of the current circline (works only if this is an Euclidean circle)\n    circle_center() {\n        return this.H.B.uminus().div(this.H.A);\n    }\n\n    // CP1 (euclidean center of infinity)\n    center() {\n        if (this.is_line())\n            return _cp1_js__WEBPACK_IMPORTED_MODULE_1__.CP1.inf;\n        else\n            return _cp1_js__WEBPACK_IMPORTED_MODULE_1__.CP1.of_complex(this.circle_center());\n    }\n\n    // Euclidean radius of the current circline (works only if this is an Euclidean circle)\n    circle_radius() {\n        return Math.sqrt(this.H.B.mult(this.H.C).sub(this.H.A.mult(this.H.D)).div(this.H.A.mult(this.H.A)).re());\n    }\n\n    // Two points on the current circline (works only if this is an Euclidean line)\n    line_points() {\n        const z1 = this.H.D.mult(this.H.B).uminus().div(this.H.B.mult(this.H.C).scale(2));\n        const z2 = z1.add(_complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.i.mult((this.H.B.arg() > 0 ? this.H.B.uminus() : this.H.B).sgn()));\n        return [z1, z2];\n    }\n\n    // precision for checking in/on/out\n    static EPS = 1e-7;\n\n    quad_form(z) {\n        if (!(z instanceof _cp1_js__WEBPACK_IMPORTED_MODULE_1__.CP1))\n            z = z.cp1();\n\n        return z.cnj().vec_mult(this.H.multCP1(z, false)).re();\n    }\n    \n    // checks if the given CP1 point lies on this circline (precision can be changed)\n    on_circline(z, eps) {\n        if (!eps)\n            eps = Circline.EPS;\n        return Math.abs(this.quad_form(z)) < eps;\n    }\n\n    // checks if the given CP1 point lines within the disc surounded by this circline (precision\n    // can be changed)\n    in_disc(z, eps) {\n        if (!eps)\n            eps = Circline.EPS;\n        return this.quad_form(z) < -eps;\n    }\n\n    static cross_ratio(w1, z1, w2, z2) {\n        if (!(z1 instanceof _cp1_js__WEBPACK_IMPORTED_MODULE_1__.CP1)) z1 = z1.cp1();\n        if (!(w1 instanceof _cp1_js__WEBPACK_IMPORTED_MODULE_1__.CP1)) w1 = w1.cp1();\n        if (!(z2 instanceof _cp1_js__WEBPACK_IMPORTED_MODULE_1__.CP1)) z2 = z2.cp1();\n        if (!(w2 instanceof _cp1_js__WEBPACK_IMPORTED_MODULE_1__.CP1)) w2 = w2.cp1();\n        return _cp1_js__WEBPACK_IMPORTED_MODULE_1__.CP1.cross_ratio(w1, z1, w2, z2);\n    }\n\n    // check if w1, z1, w2, and z2 all lie on the same circline\n    // w1, z1, w2, z2 are either all CP1 elements, or can be converted to those by means of\n    // cp1 method\n    static same_circline(w1, z1, w2, z2, eps) {\n        if (!eps)\n            eps = Circline.EPS;\n        const cr = Circline.cross_ratio(w1, z1, w2, z2);\n        return cr.is_inf() || cr.to_complex().is_real(eps);\n    }\n\n    // check if z1 and z2 lie on the same arc determined by w1 and w2 (i.e., if z2 is on the\n    // same arc as z1 between w1 and w2, on the circline determined by w1, z1 and w2)\n    // w1, z1, w2, z2 are either all CP1 elements, or can be converted to those by means of\n    // cp1 method\n    static same_arc(w1, z1, w2, z2, eps) {\n        if (!eps)\n            eps = Circline.EPS;\n        const cr = Circline.cross_ratio(w1, z1, w2, z2);\n        return !cr.is_inf() && cr.to_complex().is_real(eps) && cr.to_complex().re() >= eps;\n    }\n    \n    // check if z1 and z2 lie different arcs determined by w1 and w2 (i.e., if z2 is on the\n    // on the circline determined by w1, z1 and w2, but not on the same arc between w1 and w2\n    // as z1)\n    // w1, z1, w2, z2 are either all CP1 elements, or can be converted to those by means of\n    // cp1 method\n    static other_arc(w1, z1, w2, z2, eps) {\n        if (!eps)\n            eps = Circline.EPS;\n        const cr = Circline.cross_ratio(w1, z1, w2, z2);\n        return !cr.is_inf() && cr.to_complex().is_real(eps) && cr.to_complex().re() < -eps;\n    }\n\n    // check if w is between z1 and z2 (in Euclidean sense)\n    // w, z1, z2 are either all CP1 elements, or can be converted to those by means of\n    // cp1 method\n    static between(z1, w, z2, eps) {\n        return Circline.other_arc(_cp1_js__WEBPACK_IMPORTED_MODULE_1__.CP1.inf, z1, w, z2, eps);\n    }\n\n    // check if z1, z2, and z3 are collinear (in Euclidean sense)\n    // z1, z2, z3 are either all CP1 elements, or can be converted to those by means of\n    // cp1 method\n    static collinear(z1, z2, z3, eps) {\n        return Circline.same_circline(z1, z2, z3, _cp1_js__WEBPACK_IMPORTED_MODULE_1__.CP1.inf, eps);\n    }\n\n    // check if w1 and w2 are on the same side of z (on the same Euclidean half-line)\n    // w1, w2, z are either all CP1 elements, or can be converted to those by means of\n    // cp1 method\n    static same_side(w1, w2, z, eps) {\n        return Circline.between(z, w1, w2, eps) ||\n               Circline.between(z, w2, w1, eps) ||\n               w1.eq(w2, eps);\n    }\n\n    // check if w is h-betwen z1 and z2 on the Poincare line joining z1 and z2 within the unit disc\n    // z1, w, z2 are either all CP1 elements, or can be converted to those by means of\n    // cp1 method\n    static h_between(z1, w, z2, eps) {\n        if (!(w instanceof _cp1_js__WEBPACK_IMPORTED_MODULE_1__.CP1))\n            w = w.cp1();\n        return unit_circle.in_disc(w, eps) && Circline.other_arc(w, z1, w.inversion(), z2, eps) \n    }\n\n    static h_between_hp(z1, w, z2, eps) {\n        if (!(w instanceof _cp1_js__WEBPACK_IMPORTED_MODULE_1__.CP1))\n            w = w.cp1();\n        return !x_axis.in_disc(w, eps) && Circline.other_arc(w, z1, w.cnj(), z2, eps) \n    }\n\n    // cosine of the angle between two circlines\n    static cosAngle(c1, c2) {\n        function det12(H1, H2) {\n            return H1.A.mult(H2.D).add(H2.A.mult(H1.D)).sub(H1.B.mult(H2.C)).sub(H2.B.mult(H1.C));\n        }\n        return - det12(c1.H, c2.H).re() / (2 * Math.sqrt(c1.H.det().re() * c2.H.det().re()));\n    }\n\n    // random three different points on this circline\n    three_points() {\n        if (!this._three_points) {\n            if (this.is_line()) {\n                const [z1, z2] = this.line_points();\n                this._three_points = [z1, z2, z1.add(z2.sub(z1).scale(2))];\n            } else {\n                const c = this.circle_center();\n                const r = this.circle_radius();\n                this._three_points = [c.add(_complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.of_real(r)), c.add(_complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.of_real(-r)), c.add(_complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.of_imag(r))];\n            }\n        }\n        return this._three_points;\n    }\n\n    // a single random point on this circline\n    random_point() {\n        const [z1, z2, z3] = this.three_points().map(p => _cp1_js__WEBPACK_IMPORTED_MODULE_1__.CP1.of_complex(p));\n        const M = _moebius_js__WEBPACK_IMPORTED_MODULE_3__.Moebius.moebius_01inf(z1, z2, z3);\n        const part = Math.floor(Math.random() * 3);\n        let x;\n        if (part == 0)\n            // [0, 1]\n            x = Math.random();\n        else if (part == 1)\n            // [1, infty]\n            x = 1 / Math.random();\n        else\n            // [-infty, 0]\n            x = 1 - 1 / Math.random();\n\n        return M.inv().moebius_pt(_cp1_js__WEBPACK_IMPORTED_MODULE_1__.CP1.of_real(x));\n    }\n\n    // random point on this circline that lies within the given disc (usually the unit disc)\n    random_point_in_disc(disc) {\n        const [p1, p2] = this.intersect(disc, true);\n        const [z1, z2, z3] = this.three_points().map(p => _cp1_js__WEBPACK_IMPORTED_MODULE_1__.CP1.of_complex(p));\n        const M = _moebius_js__WEBPACK_IMPORTED_MODULE_3__.Moebius.moebius_01inf(z1, z2, z3);\n        const [x1, x2] = [p1, p2].map(p => M.moebius_pt(p).to_complex().re()).sort()\n        let p;\n        const MAX_ITER = 100;\n        let iter = 0;\n        do {\n            let x;\n            if (Math.random() < 0.5)\n                x = x1 + Math.random() * (x2 - x1);\n            else {\n                const k = Math.floor(5*Math.random());\n                const d = Math.pow(10, k)*Math.random();\n                x = Math.random() < 0.5 ? x1 - d : x2 + d;\n            }\n            p = M.inv().moebius_pt(_cp1_js__WEBPACK_IMPORTED_MODULE_1__.CP1.of_real(x));\n            iter++;\n        } while (!disc.in_disc(p) && iter < MAX_ITER);\n        return iter < MAX_ITER ? p : null;\n    }\n\n    // Moebius transformation that maps this circline to x-axis\n    moebius_to_x_axis() {\n        if (!this._moebius_to_x_axis) {\n            const [z1, z2, z3] = this.three_points().map(p => _cp1_js__WEBPACK_IMPORTED_MODULE_1__.CP1.of_complex(p));\n            this._moebius_to_x_axis = _moebius_js__WEBPACK_IMPORTED_MODULE_3__.Moebius.moebius_01inf(z1, z2, z3);\n        }\n        return this._moebius_to_x_axis;\n    }\n\n    // intersection of this and other circline (fictive intersections can also be returned)\n    intersect(other, includeFictive) {\n        const M = this.moebius_to_x_axis();\n        const cm = M.moebius_circline(other);\n        const [A, B, D] = [cm.H.A, cm.H.B, cm.H.D];\n        let p1, p2;\n        if (A.is_zero()) {\n            p1 = _cp1_js__WEBPACK_IMPORTED_MODULE_1__.CP1.inf;\n            if (B.is_imag())\n                return [p1, p1];\n            p2 = _cp1_js__WEBPACK_IMPORTED_MODULE_1__.CP1.of_real(- D.re() / (2 * B.re()));\n            return [p1, p2].map(p => M.moebius_inv_pt(p));\n        } else {\n            let discr = B.re() * B.re() - A.re() * D.re();\n            ////////////////////////////////////\n            if (Math.abs(discr) < 1e-12)\n                discr = 0;\n            ////////////////////////////////////\n            if (discr < 0) {\n                if (includeFictive) {\n                    // fictive intersections\n                    const sqrt = Math.sqrt(-discr);\n                    const [p1, p2] = [new _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex(-B.re() / A.re(), +sqrt / A.re()),\n                                      new _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex(-B.re() / A.re(), -sqrt / A.re())];\n                    return [p1, p2].map(p => M.moebius_inv_pt(_cp1_js__WEBPACK_IMPORTED_MODULE_1__.CP1.of_complex(p)));\n                } else\n                    return [];\n            } else {\n                const sqrt = Math.sqrt(discr);\n                const [p1, p2] = [(-B.re() + sqrt) / A.re(),\n                                  (-B.re() - sqrt) / A.re()];\n                return [p1, p2].map(p => M.moebius_inv_pt(_cp1_js__WEBPACK_IMPORTED_MODULE_1__.CP1.of_real(p)));\n            }\n        }\n    }\n\n    // apply the given Moebius transform (given by a function that acts on pairs of coordinates)\n    // to this circline\n    transform(t) {\n        let three_points = this.three_points();\n        if (three_points.some(p => isNaN(p.re())))\n            return this;\n        three_points = three_points.map(p => {\n            const [re, im] = t(p.re(), p.im());\n            return _cp1_js__WEBPACK_IMPORTED_MODULE_1__.CP1.of_complex(new _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex(re, im));\n        });\n        return Circline.mk_circline3(...three_points);\n    }\n\n    // check if this circline is equal to the other one (ignoring orientation)\n    eq(other, eps) {\n        return this.H_unoriented.eq(other.H_unoriented, eps);\n    }\n}\n\nconst unit_circle = Circline.unit_circle();\nconst x_axis = Circline.x_axis();\n\nconst INCLUDE_FICTIVE = true;\n\n\n\n\n//# sourceURL=webpack://ArgoDG/./src/complex_geom/circline.js?");

/***/ }),

/***/ "./src/complex_geom/complex.js":
/*!*************************************!*\
  !*** ./src/complex_geom/complex.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Complex\": () => (/* binding */ Complex)\n/* harmony export */ });\n/**\n * Complex number\n */\nclass Complex {\n    constructor(re, im) {\n        this._re = re;\n        this._im = im;\n    }\n\n    static of_real(re) {\n        return new Complex(re, 0);\n    }\n\n    static of_imag(im) {\n        return new Complex(0, im);\n    }\n\n    static of_xy(x, y) {\n        return new Complex(x, y);\n    }\n\n    static of_polar(rho, theta) {\n        return new Complex(rho * Math.cos(theta), rho * Math.sin(theta));\n    }\n\n    // some special complex numbers\n    \n    static get zero() {\n        return zero;\n    }\n\n    static get one() {\n        return one;\n    }\n\n    static get minus_one() {\n        return minus_one;\n    }\n\n    static get i() {\n        return i;\n    }\n    \n    static get minus_i() {\n        return minus_i;\n    }\n\n\n    // copy of this object\n    clone() {\n        return new Complex(this.re(), this.im());\n    }\n\n    // getting basic properties\n    re() {\n        return this._re;\n    }\n\n    x() {\n        return this.re();\n    }\n\n    im() {\n        return this._im;\n    }\n\n    y() {\n        return this.im();\n    }\n    \n    coords() {\n        return [this.re(), this.im()];\n    }\n\n    // precision for checking zero\n    static EPS = 1e-8;\n\n    // check if this complex number is zero (up to the given precision)\n    is_zero(eps) {\n        if (eps === undefined)\n            eps = Complex.EPS;\n        return this.norm2() < eps * eps;\n    }\n\n    // check if two numbers are equal (up to the given precision)\n    eq(other, eps) {\n        if (other == undefined)\n            return false;\n        // default relative error\n        if (eps === undefined)\n            eps = 1e-8;\n        return this.sub(other).norm() <= eps * (this.norm() + other.norm()) / 2;\n    }\n\n    // check if this complex number is real (up to the given precision)\n    is_real(eps) {\n        if (eps === undefined)\n            eps = Complex.EPS;\n        return Math.abs(this.im()) < eps;\n    }\n\n    // check if this complex number is pure imaginary (up to the given precision)\n    is_imag(eps) {\n        if (eps === undefined)\n            eps = Complex.EPS;\n        \n        return Math.abs(this.re()) < eps;\n    }\n\n    // all complex numbers are finite\n    is_inf() {\n        return false;\n    }\n\n    // just in case that a conversion to complex is called on a complex number\n    to_complex() {\n        return this;\n    }\n\n    // Arithmetic operations\n\n    // addition\n    add(other) {\n        return new Complex(this.re() + other.re(), this.im() + other.im());\n    }\n\n    // unary minus\n    uminus() {\n        return this.scale(-1);\n    }\n\n    // subtraction\n    sub(other) {\n        return this.add(other.uminus());\n    }\n\n    // multiplication\n    mult(other) {\n        if (typeof other == \"number\")\n            return this.scale(other);\n        return new Complex(this.re() * other.re() - this.im() * other.im(),\n                           this.re() * other.im() + this.im() * other.re());\n    }\n\n    // multiplication (scaling) by a real scalar\n    scale(k) {\n        return new Complex(k * this.re(), k * this.im());\n    }\n    \n    // division\n    div(other) {\n        return this.mult(other.reciprocal());\n    }\n\n\n    // Euclidean norm\n    norm() {\n        return Math.sqrt(this.norm2());\n    }\n    \n    // square of Euclidean norm\n    norm2() {\n        return this.re() * this.re() + this.im() * this.im();\n    }\n\n    // argument (angle in (-pi, pi])\n    arg() {\n        return Math.atan2(this.im(), this.re());\n    }\n\n    // signum (z -> z / |z|)\n    sgn() {\n        return this.scale(1 / this.norm());\n    }\n\n    // complex conjugate (x + iy -> x - iy)\n    cnj() {\n        return new Complex(this.re(), -this.im());\n    }\n\n    // reciprocal (z -> 1/z)\n    reciprocal() {\n        return this.cnj().scale(1 / this.norm2())\n    }\n\n    // cnj_mix(x1 + iy2, x2 + iy2) = 2*(x1*x2 + y1*y2) + 0*i\n    static cnj_mix(z1, z2) {\n        return z1.cnj().mult(z2).add(z2.cnj().mult(z1));\n    }\n\n    // scalar product when complex numbers are looked as vectors [x1, y1] [x2, y2]\n    // scalprod(x1 + iy1, x2 + iy2) = x1*x2 + y1*y2\n    static scalprod(z1, z2) {\n        return Complex.cnj_mix(z1, z2).scale(1 / 2).re();\n    }\n}\n\nconst zero      = new Complex( 0,  0);\nconst one       = new Complex( 1,  0);\nconst minus_one = new Complex(-1,  0);\nconst i         = new Complex( 0,  1);\nconst minus_i   = new Complex( 0, -1);\n\n\n\n\n//# sourceURL=webpack://ArgoDG/./src/complex_geom/complex.js?");

/***/ }),

/***/ "./src/complex_geom/complex_matrix.js":
/*!********************************************!*\
  !*** ./src/complex_geom/complex_matrix.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ComplexMatrix2x2\": () => (/* binding */ ComplexMatrix2x2)\n/* harmony export */ });\n/* harmony import */ var _complex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./complex.js */ \"./src/complex_geom/complex.js\");\n/* harmony import */ var _cp1_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cp1.js */ \"./src/complex_geom/cp1.js\");\n\n\n\nclass ComplexMatrix2x2 {\n    constructor(A, B, C, D) {\n        this.A = A;\n        this.B = B;\n        this.C = C;\n        this.D = D;\n    }\n\n    static zero() {\n        return new ComplexMatrix2x2(_complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.zero, _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.zero,\n                                    _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.zero, _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.zero);\n    }\n\n    static eye() {\n        return new ComplexMatrix2x2(_complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.one, _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.zero,\n                                    _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.zero, _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.one);\n    }\n\n    cnj() {\n        return new ComplexMatrix2x2(this.A.cnj(), this.B.cnj(),\n                                    this.C.cnj(), this.D.cnj());\n    }\n\n    transpose() {\n        return new ComplexMatrix2x2(this.A, this.C,\n                                    this.B, this.D);\n    }\n\n    adj() {\n        return this.cnj().transpose();\n    }\n\n    det() {\n        return this.A.mult(this.D).sub(this.B.mult(this.C));\n    }\n\n    inv() {\n        if (!this._inv)\n            this._inv = new ComplexMatrix2x2(this.D, this.B.uminus(),\n                                             this.C.uminus(), this.A).multC(this.det().reciprocal());\n        return this._inv;\n    }\n\n    qr() {\n        if (this._Q == undefined || this._R == undefined) {\n            const s0 = this.C.cnj();\n            const c0 = this.A.cnj();\n            const n = Math.sqrt(s0.norm2() + c0.norm2());\n            const c = c0.scale(1 / n);\n            const s = s0.scale(1 / n);\n            const Qa = new ComplexMatrix2x2(c, s,\n                                            s.cnj().uminus(), c.cnj());\n            this._Q = Qa.adj();\n            this._R = Qa.multM(this);\n        }\n        return [this._Q, this._R];\n    }\n    \n    eq(other, eps) {\n        return this.A.eq(other.A, eps) && this.B.eq(other.B, eps) &&\n               this.C.eq(other.C, eps) && this.D.eq(other.D, eps);\n    }\n\n    is_hermitean() {\n        return this.eq(this.adj());\n    }\n\n    is_zero() {\n        return this.eq(ComplexMatrix2x2.zero());\n    }\n\n    multC(obj) {\n        return new ComplexMatrix2x2(this.A.mult(obj), this.B.mult(obj),\n                                    this.C.mult(obj), this.D.mult(obj));\n    }\n\n    multCP1(obj, normalize) {\n        return new _cp1_js__WEBPACK_IMPORTED_MODULE_1__.CP1(this.A.mult(obj.z1).add(this.B.mult(obj.z2)),\n                       this.C.mult(obj.z1).add(this.D.mult(obj.z2)), normalize);\n    }\n\n    multInvCP1(obj) {\n        const [Q, R] = this.qr();\n        const rhs = Q.adj().multCP1(obj);\n        const z2 = rhs.z2.div(R.D);\n        const z1  = rhs.z1.sub(R.B.mult(z2)).div(R.A);\n        return new _cp1_js__WEBPACK_IMPORTED_MODULE_1__.CP1(z1, z2);\n    }\n\n    multM(obj) {\n        return new ComplexMatrix2x2(this.A.mult(obj.A).add(this.B.mult(obj.C)),\n                                    this.A.mult(obj.B).add(this.B.mult(obj.D)),\n                                    this.C.mult(obj.A).add(this.D.mult(obj.C)),\n                                    this.C.mult(obj.B).add(this.D.mult(obj.D)));\n    }\n\n    congruence(P) {\n        return P.adj().multM(this.multM(P));\n    }\n}\n\n\n\n/*\nclass Matrix3x3 {\n    constructor() {\n        if (arguments.length == 1)\n            this.M = arguments[0];\n        else if (arguments.length == 9)\n            this.M = [[arguments[0], arguments[1], arguments[2]],\n                      [arguments[3], arguments[4], arguments[5]],\n                      [arguments[6], arguments[7], arguments[8]]];\n    }\n\n\n    static zero() {\n        return new Matrix3x3([[0, 0, 0], [0, 0, 0], [0, 0, 0]]);\n    }\n\n    static eye() {\n        return new Matrix3x3([[1, 0, 0], [0, 1, 0], [0, 0, 1]]);\n    }\n\n    transpose() {\n        const M = Matrix3x3.zero();\n        for (let i = 0; i < 3; i++)\n            for (let j = 0; j < 3; j++)\n                M[i][j] = this.M[j][i];\n        return M;\n    }\n\n    det() {\n        const M = this.M;\n        return  M[0][0]*M[1][1]*M[2][2] + M[0][1]*M[1][2]*M[2][0] + M[0][2]*M[1][0]*M[2][1]\n              - M[2][0]*M[1][1]*M[0][2] - M[2][1]*M[1][2]*M[0][0] - M[2][2]*M[1][0]*M[0][1];\n    }\n\n    mult() {\n        if (arguments.length == 1 && typeof arguments[0] == \"number\") {\n            const M = this.M;\n            const MM = new Matrix3x3(M[0][0], M[0][1], M[0][2], M[1][0], M[1][1], M[1][2], M[2][0], M[2][1], M[2][2]);\n            for (let i = 0; i < 3; i++)\n                for (let j = 0; j < 3; j++)\n                    MM.M[i][j] *= arguments[0];\n            return MM;\n        }\n\n        if (arguments.length == 1 && arguments[0] instanceof Matrix3x3) {\n            const M = Matrix3x3.zero();\n            for (let i = 0; i < 3; i++)\n                for (let j = 0; j < 3; j++)\n                    for (let k = 0; k < 3; k++)\n                        M.M[i][j] += this.M[i][k] * arguments[0].M[k][j];\n            return M.M;\n        }\n            \n        throw \"Not supported\";\n    }\n\n    inv() {\n        function d(a, b, c, d) {\n            return a*d - b*c;\n        }\n        const M = this.M;\n        return new Matrix3x3(d(M[1][1], M[1][2], M[2][1], M[2][2]), d(M[0][2], M[0][1], M[2][2], M[2][1]), d(M[0][1], M[0][2], M[1][1], M[1][2]),\n                             d(M[1][2], M[1][0], M[2][2], M[2][0]), d(M[0][0], M[0][2], M[2][0], M[2][2]), d(M[0][2], M[0][0], M[1][2], M[1][0]),\n                             d(M[1][0], M[1][1], M[2][0], M[2][1]), d(M[0][1], M[0][0], M[2][1], M[2][0]), d(M[0][0], M[0][1], M[1][0], M[1][1])).mult(1 / this.det());\n    }\n    \n}\n*/\n\n\n//# sourceURL=webpack://ArgoDG/./src/complex_geom/complex_matrix.js?");

/***/ }),

/***/ "./src/complex_geom/cp1.js":
/*!*********************************!*\
  !*** ./src/complex_geom/cp1.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CP1\": () => (/* binding */ CP1)\n/* harmony export */ });\n/* harmony import */ var _complex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./complex.js */ \"./src/complex_geom/complex.js\");\n\n\n/**\n * Point in CP1 space (complex projective line),\n * given by its complex homogeneous coordinates\n */\nclass CP1 {\n    constructor(z1, z2, normalize) {\n        if (!z2)\n            z2 = _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.one;\n        this.z1 = z1;\n        this.z2 = z2;\n        if (normalize === undefined || normalize)\n            this.normalize();\n    }\n\n    normalize() {\n        if (!this.z2.is_zero()) {\n            this.z1 = this.z1.div(this.z2);\n            this.z2 = _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.one;\n        } else if (!this.z1.is_zero()) {\n            this.z1 = _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.one;\n            this.z2 = _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.zero;\n        }\n    }\n\n    is_valid(eps) {\n        return !this.z1.is_zero(eps) || !this.z2.is_zero(eps);\n    }\n\n    is_zero(eps) {\n        return this.z1.is_zero(eps);\n    }\n    \n    is_inf(eps) {\n        return this.z2.is_zero(eps);\n    }\n\n    static of_complex(z) {\n        return new CP1(z);\n    }\n\n    static of_real(r) {\n        return CP1.of_complex(_complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.of_real(r));\n    }\n    \n    static of_xy(x, y) {\n        return CP1.of_complex(new _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex(x, y));\n    }\n    \n    static get inf() {\n        return inf;\n    }\n    \n    static get zero() {\n        return zero;\n    }\n    \n    static get one() {\n        return one;\n    }\n\n    to_complex() {\n        return this.z1.div(this.z2);\n    }\n\n    coords() {\n        if (!this.is_inf())\n            return this.to_complex().coords();\n        else\n            return null;\n    }\n\n    x() {\n        if (!this.is_inf())\n            return this.to_complex().x();\n        else\n            return null;\n    }\n\n    y() {\n        if (!this.is_inf())\n            return this.to_complex().y();\n        else\n            return null;\n    }    \n    \n    add(other) {\n        if (!this.z2.is_zero() || !other.z2.is_zero())\n            return new CP1(this.z1.mult(other.z2).add(other.z1.mult(this.z2)),\n                           this.z2.mult(other.z2));\n        else\n            return CP1.inf;\n    }\n\n    uminus() {\n        return new CP1(this.z1.uminus(), this.z2);\n    }\n\n    sub(other) {\n        return this.add(other.uminus());\n    }\n\n    mult(other) {\n        if ((this.z1.is_zero() && other.z2.is_zero()) ||\n            (other.z1.is_zero() && this.z2.is_zero()))\n            return CP1.one;\n        else\n            return new CP1(this.z1.mult(other.z1), this.z2.mult(other.z2));\n    }\n\n    reciprocal() {\n        return new CP1(this.z2, this.z1);\n    }\n\n    div(other) {\n        return this.mult(other.reciprocal());\n    }\n\n    cnj() {\n        return new CP1(this.z1.cnj(), this.z2.cnj());\n    }\n\n    inversion() {\n        return this.reciprocal().cnj();\n    }\n\n    eq(other, eps) {\n        if (!other)\n            return false;\n        \n        if (!(other instanceof CP1))\n            other = other.cp1();\n\n        if (!other)\n            return false;\n        \n        this.normalize();\n        other.normalize();\n        \n        if (this.is_inf())\n            return other.is_inf();\n        if (other.is_inf())\n            return this.is_inf();\n        return this.sub(other).is_zero(eps);\n    }\n\n    clone() {\n        return new CP1(this.z1.clone(), this.z2.clone());\n    }\n\n    static ratio(a, b, c) {\n        return (a.sub(b)).div(a.sub(c));\n    }\n\n    static cross_ratio(z, u, v, w) {\n        const n1 = z.z1.mult(u.z2).sub(u.z1.mult(z.z2));\n        const n2 = v.z1.mult(w.z2).sub(w.z1.mult(v.z2));\n        const d1 = z.z1.mult(w.z2).sub(w.z1.mult(z.z2));\n        const d2 = v.z1.mult(u.z2).sub(u.z1.mult(v.z2));\n        if (!n1.mult(n2).is_zero() || !d1.mult(d2).is_zero())\n            return new CP1(n1.mult(n2), d1.mult(d2));\n        else\n            return CP1.one;\n    }\n\n    vec_mult(other) {\n        return this.z1.mult(other.z1).add(this.z2.mult(other.z2));\n    }\n}\n\nconst inf  = new CP1(_complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.one, _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.zero);\nconst zero = CP1.of_real(0);\nconst one  = CP1.of_real(1);\n\n_complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.prototype.cp1 = function() {\n    return CP1.of_complex(this);\n}\n      \n\n\n\n//# sourceURL=webpack://ArgoDG/./src/complex_geom/cp1.js?");

/***/ }),

/***/ "./src/complex_geom/moebius.js":
/*!*************************************!*\
  !*** ./src/complex_geom/moebius.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Moebius\": () => (/* binding */ Moebius)\n/* harmony export */ });\n/* harmony import */ var _complex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./complex.js */ \"./src/complex_geom/complex.js\");\n/* harmony import */ var _complex_matrix_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./complex_matrix.js */ \"./src/complex_geom/complex_matrix.js\");\n/* harmony import */ var _circline_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./circline.js */ \"./src/complex_geom/circline.js\");\n/* harmony import */ var _cp1_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./cp1.js */ \"./src/complex_geom/cp1.js\");\n\n\n\n\n\n/**\n * Moebius transform (az + b) / (cz + d) acting on points of CP1\n */\nclass Moebius {\n    constructor(A, B, C, D) {\n        if (arguments.length == 1 && A instanceof _complex_matrix_js__WEBPACK_IMPORTED_MODULE_1__.ComplexMatrix2x2) {\n            this.construct(A.A, A.B, A.C, A.D);\n        } else {\n            this.construct(A, B, C, D);\n        }\n    }\n\n    construct(A, B, C, D) {\n        if (!A.is_zero()) {\n            B = B.div(A);\n            C = C.div(A);\n            D = D.div(A);\n            A = A.div(A); // must be last\n        }\n        else {\n            const b = B.norm();\n            A = A.scale(1 / b);\n            B = B.scale(1 / b);\n            C = C.scale(1 / b);\n            D = D.scale(1 / b);\n        }\n        this.M = new _complex_matrix_js__WEBPACK_IMPORTED_MODULE_1__.ComplexMatrix2x2(A, B, C, D);\n    }\n\n    moebius_pt(z) {\n        if (!(z instanceof _cp1_js__WEBPACK_IMPORTED_MODULE_3__.CP1))\n            z = z.cp1();\n        return this.M.multCP1(z);\n    }\n\n    moebius_inv_pt(z) {\n        if (!(z instanceof _cp1_js__WEBPACK_IMPORTED_MODULE_3__.CP1))\n            z = z.cp1();\n        return this.M.multInvCP1(z);\n    }\n\n    moebius_circline(c) {\n        return new _circline_js__WEBPACK_IMPORTED_MODULE_2__.Circline(c.H.congruence(this.M.inv()));\n    }\n\n    static id() {\n        return new Moebius(_complex_matrix_js__WEBPACK_IMPORTED_MODULE_1__.ComplexMatrix2x2.eye());\n    }\n\n    inv() {\n        return new Moebius(this.M.inv());\n    }\n\n    comp(other) {\n        return new Moebius(this.M.multM(other.M));\n    }\n\n    static moebius_01inf(w1, w2, w3) {\n        const m23 = w2.z1.mult(w3.z2).sub(w3.z1.mult(w2.z2));\n        const m21 = w2.z1.mult(w1.z2).sub(w1.z1.mult(w2.z2));\n        const m13 = w1.z1.mult(w3.z2).sub(w3.z1.mult(w1.z2));\n        return new Moebius(w1.z2.mult(m23), w1.z1.mult(m23).uminus(),\n                           w3.z2.mult(m21), w3.z1.mult(m21).uminus());\n    }\n}\n\n\n\n\n//# sourceURL=webpack://ArgoDG/./src/complex_geom/moebius.js?");

/***/ }),

/***/ "./src/complex_geom/poincare.js":
/*!**************************************!*\
  !*** ./src/complex_geom/poincare.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"PoincareDisc\": () => (/* binding */ PoincareDisc),\n/* harmony export */   \"PoincareHalfPlane\": () => (/* binding */ PoincareHalfPlane)\n/* harmony export */ });\n/* harmony import */ var _complex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./complex.js */ \"./src/complex_geom/complex.js\");\n/* harmony import */ var _cp1_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cp1.js */ \"./src/complex_geom/cp1.js\");\n/* harmony import */ var _circline_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./circline.js */ \"./src/complex_geom/circline.js\");\n/* harmony import */ var _moebius_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./moebius.js */ \"./src/complex_geom/moebius.js\");\n\n\n\n\n\nclass PoincareDisc {\n    // hyperbolic distance between two given (finite) complex numbers inside the disc\n    static hdist(u, v) {\n        return Math.acosh(1 + (2 * u.sub(v).norm2()) / ((1 - u.norm2()) * (1 - v.norm2())));\n    }\n\n    // cosine of the hyperbolic angle ABC given by three (finite) complex numbers inside the disc\n    static cosPhi(A, B, C) {\n        const l1 = PoincareDisc.mk_line(A, B);\n        const l2 = PoincareDisc.mk_line(C, B);\n        return _circline_js__WEBPACK_IMPORTED_MODULE_2__.Circline.cosAngle(l1, l2);\n    }\n    \n    // Circline that represents a Poincare disc line that joins two given (finite) complex numbers\n    // inside the disc\n    static mk_line(z1, z2) {\n        const A = _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.i.mult((z1.mult(z2.cnj())).sub(z2.mult(z1.cnj())));\n        const B = _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.i.mult(z2.scale(z1.norm2() + 1).sub(z1.scale(z2.norm2() + 1)));\n        return new _circline_js__WEBPACK_IMPORTED_MODULE_2__.Circline(A, B, B.cnj(), A);\n    }\n\n    // Circline that represents a Poincare circle that is centered in a (finite) complex number a\n    // and has the radius r\n    static mk_circle(a, r) {\n        const ae = a.scale(1 / ((1 - a.norm2())*(Math.cosh(r) - 1)/2 + 1));\n        const re = ((1 - a.norm2()) * Math.sinh(r)) / ((1 - a.norm2()) * (Math.cosh(r) - 1) + 2);\n        return _circline_js__WEBPACK_IMPORTED_MODULE_2__.Circline.mk_circle(ae, re);\n    }\n}\n\nconst half_plane_to_disc = new _moebius_js__WEBPACK_IMPORTED_MODULE_3__.Moebius(_complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.one, _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.i.uminus(), _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.one, _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.i);\nconst disc_to_half_plane = half_plane_to_disc.inv();\n\nclass PoincareHalfPlane {\n    // hyperbolic distance between two given (finite) complex numbers inside the upper half plane\n    static hdist(u, v) {\n        return Math.acosh(1 + (u.sub(v).norm2()) / (2*u.im()*v.im()));\n    }\n\n    // cosine of the hyperbolic angle ABC given by three (finite) complex numbers inside the disc\n    static cosPhi(A, B, C) {\n        const l1 = PoincareHalfPlane.mk_line(A, B);\n        const l2 = PoincareHalfPlane.mk_line(C, B);\n        return _circline_js__WEBPACK_IMPORTED_MODULE_2__.Circline.cosAngle(l1, l2);\n    }\n    \n    // Circline that represents a Poincare half plane line that joins\n    // two given (finite) complex numbers inside the disc\n    static mk_line(z1, z2) {\n        // FIXME: find a direct formula\n        const zz1 = half_plane_to_disc.moebius_pt(z1);\n        const zz2 = half_plane_to_disc.moebius_pt(z2);\n        const ll = PoincareDisc.mk_line(zz1.to_complex(), zz2.to_complex());\n        return disc_to_half_plane.moebius_circline(ll);\n    }\n\n    // Circline that represents a Poincare circle that is centered in a (finite) complex number a\n    // and has the radius r\n    static mk_circle(a, r) {\n        // FIXME: find a direct formula\n        const aa = half_plane_to_disc.moebius_pt(a);\n        const cc = PoincareDisc.mk_circle(aa.to_complex(), r);\n        return disc_to_half_plane.moebius_circline(cc);\n    }\n}\n\n\n\n\n//# sourceURL=webpack://ArgoDG/./src/complex_geom/poincare.js?");

/***/ }),

/***/ "./src/dg.js":
/*!*******************!*\
  !*** ./src/dg.js ***!
  \*******************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AnimationButtons\": () => (/* reexport safe */ _dg_animation_buttons_js__WEBPACK_IMPORTED_MODULE_2__.AnimationButtons),\n/* harmony export */   \"ConstructionToolbar\": () => (/* reexport safe */ _dg_tools_js__WEBPACK_IMPORTED_MODULE_3__.ConstructionToolbar),\n/* harmony export */   \"If\": () => (/* reexport safe */ _dg_dg_js__WEBPACK_IMPORTED_MODULE_0__.If),\n/* harmony export */   \"ListView\": () => (/* reexport safe */ _dg_list_view_js__WEBPACK_IMPORTED_MODULE_4__.ListView),\n/* harmony export */   \"NO_REDRAW\": () => (/* reexport safe */ _dg_objects_js__WEBPACK_IMPORTED_MODULE_1__.NO_REDRAW),\n/* harmony export */   \"REDRAW\": () => (/* reexport safe */ _dg_objects_js__WEBPACK_IMPORTED_MODULE_1__.REDRAW),\n/* harmony export */   \"Vector2\": () => (/* reexport safe */ _dg_dg_js__WEBPACK_IMPORTED_MODULE_0__.Vector2),\n/* harmony export */   \"addObject\": () => (/* reexport safe */ _dg_dg_js__WEBPACK_IMPORTED_MODULE_0__.addObject),\n/* harmony export */   \"animate\": () => (/* reexport safe */ _dg_dg_js__WEBPACK_IMPORTED_MODULE_0__.animate),\n/* harmony export */   \"animationButtons\": () => (/* reexport safe */ _dg_dg_js__WEBPACK_IMPORTED_MODULE_0__.animationButtons),\n/* harmony export */   \"arc\": () => (/* reexport safe */ _dg_dg_js__WEBPACK_IMPORTED_MODULE_0__.arc),\n/* harmony export */   \"between\": () => (/* reexport safe */ _dg_dg_js__WEBPACK_IMPORTED_MODULE_0__.between),\n/* harmony export */   \"center\": () => (/* reexport safe */ _dg_dg_js__WEBPACK_IMPORTED_MODULE_0__.center),\n/* harmony export */   \"circle\": () => (/* reexport safe */ _dg_dg_js__WEBPACK_IMPORTED_MODULE_0__.circle),\n/* harmony export */   \"clone\": () => (/* reexport safe */ _dg_dg_js__WEBPACK_IMPORTED_MODULE_0__.clone),\n/* harmony export */   \"constant\": () => (/* reexport safe */ _dg_dg_js__WEBPACK_IMPORTED_MODULE_0__.constant),\n/* harmony export */   \"construction\": () => (/* reexport safe */ _dg_dg_js__WEBPACK_IMPORTED_MODULE_0__.construction),\n/* harmony export */   \"constructionToolbar\": () => (/* reexport safe */ _dg_dg_js__WEBPACK_IMPORTED_MODULE_0__.constructionToolbar),\n/* harmony export */   \"container\": () => (/* reexport safe */ _dg_dg_js__WEBPACK_IMPORTED_MODULE_0__.container),\n/* harmony export */   \"convexAngle\": () => (/* reexport safe */ _dg_dg_js__WEBPACK_IMPORTED_MODULE_0__.convexAngle),\n/* harmony export */   \"convexArc\": () => (/* reexport safe */ _dg_dg_js__WEBPACK_IMPORTED_MODULE_0__.convexArc),\n/* harmony export */   \"distance\": () => (/* reexport safe */ _dg_dg_js__WEBPACK_IMPORTED_MODULE_0__.distance),\n/* harmony export */   \"findCircleAt\": () => (/* reexport safe */ _dg_dg_js__WEBPACK_IMPORTED_MODULE_0__.findCircleAt),\n/* harmony export */   \"findFreePointAt\": () => (/* reexport safe */ _dg_dg_js__WEBPACK_IMPORTED_MODULE_0__.findFreePointAt),\n/* harmony export */   \"findLineAt\": () => (/* reexport safe */ _dg_dg_js__WEBPACK_IMPORTED_MODULE_0__.findLineAt),\n/* harmony export */   \"findObjectsAt\": () => (/* reexport safe */ _dg_dg_js__WEBPACK_IMPORTED_MODULE_0__.findObjectsAt),\n/* harmony export */   \"findPointAt\": () => (/* reexport safe */ _dg_dg_js__WEBPACK_IMPORTED_MODULE_0__.findPointAt),\n/* harmony export */   \"intersectCC_any\": () => (/* reexport safe */ _dg_dg_js__WEBPACK_IMPORTED_MODULE_0__.intersectCC_any),\n/* harmony export */   \"intersectCC_both\": () => (/* reexport safe */ _dg_dg_js__WEBPACK_IMPORTED_MODULE_0__.intersectCC_both),\n/* harmony export */   \"intersectCC_select\": () => (/* reexport safe */ _dg_dg_js__WEBPACK_IMPORTED_MODULE_0__.intersectCC_select),\n/* harmony export */   \"intersectLC_any\": () => (/* reexport safe */ _dg_dg_js__WEBPACK_IMPORTED_MODULE_0__.intersectLC_any),\n/* harmony export */   \"intersectLC_both\": () => (/* reexport safe */ _dg_dg_js__WEBPACK_IMPORTED_MODULE_0__.intersectLC_both),\n/* harmony export */   \"intersectLC_select\": () => (/* reexport safe */ _dg_dg_js__WEBPACK_IMPORTED_MODULE_0__.intersectLC_select),\n/* harmony export */   \"intersectLL\": () => (/* reexport safe */ _dg_dg_js__WEBPACK_IMPORTED_MODULE_0__.intersectLL),\n/* harmony export */   \"line\": () => (/* reexport safe */ _dg_dg_js__WEBPACK_IMPORTED_MODULE_0__.line),\n/* harmony export */   \"midpoint\": () => (/* reexport safe */ _dg_dg_js__WEBPACK_IMPORTED_MODULE_0__.midpoint),\n/* harmony export */   \"nextAnimationStep\": () => (/* reexport safe */ _dg_dg_js__WEBPACK_IMPORTED_MODULE_0__.nextAnimationStep),\n/* harmony export */   \"num\": () => (/* reexport safe */ _dg_dg_js__WEBPACK_IMPORTED_MODULE_0__.num),\n/* harmony export */   \"orientedAngle\": () => (/* reexport safe */ _dg_dg_js__WEBPACK_IMPORTED_MODULE_0__.orientedAngle),\n/* harmony export */   \"poincareDiscCircle\": () => (/* reexport safe */ _dg_dg_js__WEBPACK_IMPORTED_MODULE_0__.poincareDiscCircle),\n/* harmony export */   \"poincareDiscCircleR\": () => (/* reexport safe */ _dg_dg_js__WEBPACK_IMPORTED_MODULE_0__.poincareDiscCircleR),\n/* harmony export */   \"poincareDiscLine\": () => (/* reexport safe */ _dg_dg_js__WEBPACK_IMPORTED_MODULE_0__.poincareDiscLine),\n/* harmony export */   \"poincareHalfPlaneCircle\": () => (/* reexport safe */ _dg_dg_js__WEBPACK_IMPORTED_MODULE_0__.poincareHalfPlaneCircle),\n/* harmony export */   \"poincareHalfPlaneCircleR\": () => (/* reexport safe */ _dg_dg_js__WEBPACK_IMPORTED_MODULE_0__.poincareHalfPlaneCircleR),\n/* harmony export */   \"poincareHalfPlaneLine\": () => (/* reexport safe */ _dg_dg_js__WEBPACK_IMPORTED_MODULE_0__.poincareHalfPlaneLine),\n/* harmony export */   \"point\": () => (/* reexport safe */ _dg_dg_js__WEBPACK_IMPORTED_MODULE_0__.point),\n/* harmony export */   \"pointFun\": () => (/* reexport safe */ _dg_dg_js__WEBPACK_IMPORTED_MODULE_0__.pointFun),\n/* harmony export */   \"polygon\": () => (/* reexport safe */ _dg_dg_js__WEBPACK_IMPORTED_MODULE_0__.polygon),\n/* harmony export */   \"prevAnimationStep\": () => (/* reexport safe */ _dg_dg_js__WEBPACK_IMPORTED_MODULE_0__.prevAnimationStep),\n/* harmony export */   \"randomPoint\": () => (/* reexport safe */ _dg_dg_js__WEBPACK_IMPORTED_MODULE_0__.randomPoint),\n/* harmony export */   \"randomPointOnCircle\": () => (/* reexport safe */ _dg_dg_js__WEBPACK_IMPORTED_MODULE_0__.randomPointOnCircle),\n/* harmony export */   \"randomPointOnLine\": () => (/* reexport safe */ _dg_dg_js__WEBPACK_IMPORTED_MODULE_0__.randomPointOnLine),\n/* harmony export */   \"ray\": () => (/* reexport safe */ _dg_dg_js__WEBPACK_IMPORTED_MODULE_0__.ray),\n/* harmony export */   \"redraw\": () => (/* reexport safe */ _dg_dg_js__WEBPACK_IMPORTED_MODULE_0__.redraw),\n/* harmony export */   \"removeAll\": () => (/* reexport safe */ _dg_dg_js__WEBPACK_IMPORTED_MODULE_0__.removeAll),\n/* harmony export */   \"removeObject\": () => (/* reexport safe */ _dg_dg_js__WEBPACK_IMPORTED_MODULE_0__.removeObject),\n/* harmony export */   \"segment\": () => (/* reexport safe */ _dg_dg_js__WEBPACK_IMPORTED_MODULE_0__.segment),\n/* harmony export */   \"setConstruction\": () => (/* reexport safe */ _dg_dg_js__WEBPACK_IMPORTED_MODULE_0__.setConstruction),\n/* harmony export */   \"setup\": () => (/* reexport safe */ _dg_dg_js__WEBPACK_IMPORTED_MODULE_0__.setup),\n/* harmony export */   \"svg\": () => (/* reexport safe */ _dg_dg_js__WEBPACK_IMPORTED_MODULE_0__.svg),\n/* harmony export */   \"text\": () => (/* reexport safe */ _dg_dg_js__WEBPACK_IMPORTED_MODULE_0__.text),\n/* harmony export */   \"vector\": () => (/* reexport safe */ _dg_dg_js__WEBPACK_IMPORTED_MODULE_0__.vector),\n/* harmony export */   \"vectorFun\": () => (/* reexport safe */ _dg_dg_js__WEBPACK_IMPORTED_MODULE_0__.vectorFun),\n/* harmony export */   \"vectorXY\": () => (/* reexport safe */ _dg_dg_js__WEBPACK_IMPORTED_MODULE_0__.vectorXY),\n/* harmony export */   \"view\": () => (/* reexport safe */ _dg_dg_js__WEBPACK_IMPORTED_MODULE_0__.view)\n/* harmony export */ });\n/* harmony import */ var _dg_dg_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dg/dg.js */ \"./src/dg/dg.js\");\n/* harmony import */ var _dg_objects_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dg/objects.js */ \"./src/dg/objects.js\");\n/* harmony import */ var _dg_animation_buttons_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./dg/animation_buttons.js */ \"./src/dg/animation_buttons.js\");\n/* harmony import */ var _dg_tools_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./dg/tools.js */ \"./src/dg/tools.js\");\n/* harmony import */ var _dg_list_view_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./dg/list_view.js */ \"./src/dg/list_view.js\");\n\n\n\n\n\n\n\n//# sourceURL=webpack://ArgoDG/./src/dg.js?");

/***/ }),

/***/ "./src/dg/animation_buttons.js":
/*!*************************************!*\
  !*** ./src/dg/animation_buttons.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AnimationButtons\": () => (/* binding */ AnimationButtons)\n/* harmony export */ });\nclass AnimationButtons {\n    constructor(construction, element) {\n        const divBtns = document.createElement(\"div\");\n        element.appendChild(divBtns);\n        \n        const btnPrev = document.createElement(\"button\");\n        btnPrev.innerHTML = \"<<\";\n        btnPrev.addEventListener(\"click\", construction.prevAnimationStep.bind(construction));\n        divBtns.appendChild(btnPrev);\n        \n        const btnNext = document.createElement(\"button\");\n        btnNext.innerHTML = \">>\";\n        btnNext.addEventListener(\"click\", construction.nextAnimationStep.bind(construction));\n        divBtns.append(btnNext);\n    }\n}\n\n\n\n\n//# sourceURL=webpack://ArgoDG/./src/dg/animation_buttons.js?");

/***/ }),

/***/ "./src/dg/canvas.js":
/*!**************************!*\
  !*** ./src/dg/canvas.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Canvas\": () => (/* binding */ Canvas)\n/* harmony export */ });\n/* harmony import */ var _latex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./latex.js */ \"./src/dg/latex.js\");\n/* harmony import */ var _colors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./colors.js */ \"./src/dg/colors.js\");\n/* harmony import */ var _complex_geom_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../complex_geom.js */ \"./src/complex_geom.js\");\n/* harmony import */ var canvas2svg__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! canvas2svg */ \"./node_modules/canvas2svg/canvas2svg.js\");\n/* harmony import */ var canvas2svg__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(canvas2svg__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _tool_images_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./tool_images.js */ \"./src/dg/tool_images.js\");\n/* harmony import */ var _font_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./font.js */ \"./src/dg/font.js\");\n\n\n\n\n\n\n\n// delegate all object access to given list of objects\nfunction Delegate(objects) {\n    return new Proxy({}, {\n        get: function(target, property) {\n            if (property in objects[0] && typeof objects[0][property] !== 'function')\n                return objects[0][property];\n            else\n                return function(...args) {\n                    let retVal = undefined;\n                    objects.forEach(obj => {\n                        if (typeof obj[property] === 'function') {\n                            const objRetVal = obj[property].apply(obj, args);\n                            // return the first value\n                            if (retVal === undefined)\n                                retVal = objRetVal;\n                        }\n                    });\n                    return retVal;\n                }\n        },\n        set: function(target, property, value) {\n            objects.forEach(obj => { if (property in obj) obj[property] = value; });\n            return true;\n        }\n    });\n}\n\n\n// -----------------------------------------------------------------------------\n// encapsulate drawing canvas with a few basic drawing primitives\n// -----------------------------------------------------------------------------\nclass Canvas {\n    constructor(element, options) {\n        if (typeof element == \"string\")\n            element = document.getElementById(element);\n\n        if (element instanceof HTMLCanvasElement) {\n            this._canvas = element;\n            this._container = document.createElement(\"div\");\n            this._canvas.parentNode.replaceChild(this._container, this._canvas);\n            this._container.append(this._canvas);\n            this._container.style.width = \"500px\";\n            const h1 = document.getElementsByTagName(\"h1\")[0];\n            h1.style.textAlign = \"center\";\n            h1.style.marginTop = \"45px\";\n        } else {\n            this._container = element;\n            this._canvas = document.createElement(\"canvas\");\n            this._container.innerHTML = \"\";\n            this._container.append(this._canvas);\n            this._canvas.width = this._container.width;\n            this._canvas.height = this._container.height;\n        }\n\n        this._container.style.marginLeft = \"auto\";\n        this._container.style.marginRight = \"auto\";\n\n        const ratio = window.devicePixelRatio;\n        \n        if (options.width)\n            this.setCanvasWidth(options.width);\n\n        if (options.height)\n            this.setCanvasHeight(options.height);\n\n        if (options.border)\n            this._canvas.style.border = options.border;\n\n        // setup canvas drawing context\n        this._canvas_ctx = this._canvas.getContext(\"2d\");\n        this._canvas_ctx.scale(ratio, ratio);\n\n        \n        if (options.saveSVG) {\n            this._saveSVG = true;\n            // drawing simultaneously onto SVG and onto canvas context\n            this._canvas2SVG = new (canvas2svg__WEBPACK_IMPORTED_MODULE_3___default())(this._canvas);\n            this._ctx = Delegate([this._canvas_ctx, this._canvas2SVG]);\n        } else {\n            this._saveSVG = false;\n            this._ctx = this._canvas_ctx;\n        }\n\n        this._defaultColor = \"black\";\n        this._defaultWidth = 1;\n        this._defaultDash = [];\n\n        // add status line paragraph\n        const p = document.createElement(\"p\");;\n        p.id = \"status-line\";\n        this._p_status = p;\n        this._canvas_container = document.createElement(\"div\");\n        this._canvas_container.style.width = this._canvas.style.width;\n        \n        this._canvas.parentNode.replaceChild(this._canvas_container, this._canvas);\n        this._canvas_container.style.position = \"relative\";\n        this._canvas_container.append(this._canvas);\n        this._canvas_container.append(p);\n        p.style.position = \"absolute\";\n        p.style.top = \"0px\";\n        p.style.left = \"0px\";\n        p.style.margin = \"5px\";\n        p.style.display = \"none\";\n\n        // add save svg button\n        if (options.saveSVG) {\n            const saveSvgIcon = document.createElement(\"img\");\n            saveSvgIcon.style.border = \"1px solid #555\";\n            saveSvgIcon.style.borderRadius = \"5px\";\n            saveSvgIcon.style.opacity = \"0.5\";\n            saveSvgIcon.style.margin = \"1px\";\n            saveSvgIcon.src = _tool_images_js__WEBPACK_IMPORTED_MODULE_4__.save_svg;\n            saveSvgIcon.style.position = \"absolute\";\n            saveSvgIcon.style.top = \"0px\";\n            saveSvgIcon.style.right = \"0px\";\n            saveSvgIcon.style.display = \"none\";\n            this._canvas_container.append(saveSvgIcon);\n            const canvas = this._canvas;\n            canvas.addEventListener('mousemove', function(event) {\n                // Check if mouse pointer is in the top right corner\n                if (event.offsetX >= canvas.clientWidth - 40 && event.offsetY <= 40) {\n                    saveSvgIcon.style.display = 'block';\n                } else {\n                    saveSvgIcon.style.display = 'none';\n                }\n            });\n            saveSvgIcon.addEventListener('mouseout', function() {\n                saveSvgIcon.style.display = 'none';\n            });\n            const self = this;\n            saveSvgIcon.addEventListener('click', function() {\n                // Get the content of the SVG from the canvas\n                var svgContent = self.svg();\n\n                // Create a new Blob object with the SVG content\n                var blob = new Blob([svgContent], { type: 'image/svg+xml' });\n\n                // Create a temporary URL to the Blob object\n                var url = URL.createObjectURL(blob);\n            \n                // Create a new anchor element for the download link\n                var link = document.createElement('a');\n                link.href = url;\n                link.download = 'ArgoDG.svg';\n\n                // Programmatically click the download link\n                link.click();\n\n                // Remove the temporary URL and the anchor element\n                URL.revokeObjectURL(url);\n                link.remove();\n            });\n        }\n    }\n\n    addElement(e) {\n        this._canvas_container.append(e);\n    }\n\n    canvas() {\n        return this._canvas;\n    }\n    \n    container() {\n        return this._container;\n    }\n\n    addEventListener(event, fun) {\n        this._canvas.addEventListener(event, fun);\n    }\n\n    setCanvasWidth(width) {\n        const ratio = window.devicePixelRatio;\n        this._canvas.width = width * ratio;\n        this._canvas.style.width = width + \"px\";\n    }\n\n    setWidth(width) {\n        this.setCanvasWidth(width);\n        const ratio = window.devicePixelRatio;\n        this._canvas_ctx = this._canvas.getContext(\"2d\");\n        this._canvas_ctx.scale(ratio, ratio);\n    }\n\n    setCanvasHeight(height) {\n        const ratio = window.devicePixelRatio;\n        this._canvas.height = height * ratio;\n        this._canvas.style.height = height + \"px\";\n    }\n\n    setHeight(height) {\n        this.setCanvasHeight(height);\n        const ratio = window.devicePixelRatio;\n        this._canvas_ctx = this._canvas.getContext(\"2d\");\n        this._canvas_ctx.scale(ratio, ratio);\n    }\n\n    width() {\n        const ratio = window.devicePixelRatio;\n        return this._canvas.width / ratio;\n    }\n\n    height() {\n        const ratio = window.devicePixelRatio;\n        return this._canvas.height / ratio;\n    }\n\n    context() {\n        return this._ctx;\n    }\n\n    clear() {\n        const ctx = this.context();\n        ctx.clearRect(0, 0, this.width(), this.height());\n        if (this._saveSVG) {\n            this._canvas2SVG = new (canvas2svg__WEBPACK_IMPORTED_MODULE_3___default())(this._canvas);\n            const ratio = window.devicePixelRatio;\n            this._canvas2SVG.scale(ratio, ratio);\n            this._ctx = Delegate([this._canvas_ctx, this._canvas2SVG]);\n        }\n    }\n\n    arc(x, y, r, angle_from, angle_to, counterclockwise, color, width, dash, fillColor) {\n        // due to bugs in Firefox and Chrome arc primitive large circles are drawn specially\n        if (angle_from == 0 && angle_to == 2 * Math.PI) {\n            if (r > 500 * this.width()) {\n                const intersections = this.circle_endpoints(x, y, r);\n                if (intersections.length == 2) {\n                    this.segment(intersections[0][0], intersections[0][1],\n                                 intersections[1][0], intersections[1][1],\n                                 color, width, dash);\n                }\n                return;\n            }\n\n            // special fix for Firefox - split circle to two arc\n            if (navigator.userAgent.includes(\"Firefox\") &&\n                r > this.width()) {\n                const intersections = this.circle_endpoints(x, y, r);\n                if (intersections.length == 2) {\n                    const P1 = new _complex_geom_js__WEBPACK_IMPORTED_MODULE_2__.Complex(intersections[0][0], intersections[0][1]);\n                    const P2 = new _complex_geom_js__WEBPACK_IMPORTED_MODULE_2__.Complex(intersections[1][0], intersections[1][1]);\n                    this.arc(P1.x(), P1.y(), 2, 0, 2*Math.PI, true, \"green\");\n                    this.arc(P2.x(), P2.y(), 2, 0, 2*Math.PI, true, \"green\");\n                    const c = new _complex_geom_js__WEBPACK_IMPORTED_MODULE_2__.Complex(x, y);\n                    const a1 = P1.sub(c).arg();\n                    const a2 = P2.sub(c).arg();\n                    this.arc(x, y, r, a1, a2, counterclockwise, color, width, dash, fillColor);\n                    this.arc(x, y, r, a1, a2, !counterclockwise, color, width, dash, fillColor);\n                    return;\n                }\n            }\n        }\n        \n        color = color || this._defaultColor;\n        width = width || this._defaultWidth;\n        dash = dash || this._defaultDash;\n        \n        const ctx = this.context();\n        ctx.lineWidth = width;\n        ctx.setLineDash(dash);\n        if (fillColor) {\n            const full = Math.abs(angle_to - angle_from) >= 2*Math.PI;\n            ctx.beginPath();\n            if (!full)\n                ctx.moveTo(x, y);\n            ctx.arc(x, y, r, angle_from, angle_to, counterclockwise);\n            if (!full)\n                ctx.closePath();\n            \n            ctx.fillStyle = fillColor;\n            ctx.fill();\n            ctx.strokeStyle = color;\n            ctx.stroke();\n        } else {\n            ctx.beginPath();\n            ctx.arc(x, y, r, angle_from, angle_to, counterclockwise);\n            ctx.strokeStyle = color;\n            ctx.stroke();\n        }\n    }\n    \n    circle(x, y, r, color, width, dash, fill) {\n        this.arc(x, y, r, 0, 2*Math.PI, true, color, width, dash, fill);\n    }\n\n    point(x, y, color) {\n        const ctx = this.context();\n        ctx.beginPath();\n        ctx.arc(x, y, 1, 0, 2*Math.PI, true);\n        ctx.strokeStyle = color;\n        ctx.stroke();\n    }\n\n    segment(x1, y1, x2, y2, color, width, dash) {\n        color = color || this._defaultColor;\n        width = width || this._defaultWidth;\n        dash = dash || this._defaultDash;\n        const ctx = this.context();\n        ctx.beginPath();\n        ctx.moveTo(x1, y1);\n        ctx.lineTo(x2, y2);\n        ctx.lineWidth = width;\n        ctx.strokeStyle = color;\n        ctx.setLineDash(dash);\n        ctx.stroke();\n    }\n\n    vector(x1, y1, x2, y2, color, width, dash) {\n        color = color || this._defaultColor;\n        width = width || this._defaultWidth;\n        dash = dash || this._defaultDash;\n        const ctx = this.context();\n        \n        var d = Math.sqrt((x2-x1)*(x2-x1) + (y2-y1)*(y2-y1));\n        \n        ctx.save();\n        ctx.translate(x1, y1);\n        var alpha = Math.atan2(y2 - y1, x2 - x1);\n        ctx.rotate(alpha);\n\n        var r = 15;\n        var bottomX = 0, bottomY = 0;\n        var topX = d, topY = 0;\n\n        // draw line\n        ctx.beginPath();\n        ctx.lineWidth = width;\n        ctx.strokeStyle = color;\n        ctx.moveTo(bottomX, bottomY);\n        ctx.lineTo(topX, topY);\n        ctx.stroke();\n\n        // draw \"arrow\"\n        ctx.beginPath();\n        ctx.moveTo(topX - r, topY - 5);\n        ctx.lineTo(topX, topY);\n        ctx.stroke();\n        \n        ctx.beginPath();\n        ctx.moveTo(topX - r, topY + 5);\n        ctx.lineTo(topX, topY);\n        ctx.stroke();\n\n        ctx.restore();\n    }\n\n    polygon(points, borderColor, width, dash, fillColor) {\n        if (points.length == 0)\n            return;\n        const ctx = this.context();\n        ctx.save();\n        borderColor = borderColor || this._defaultColor;\n        width = width || this._defaultWidth;\n        dash = dash || this._defaultDash;\n        ctx.beginPath();\n        ctx.moveTo(points[0][0], points[0][1]);\n        for (let i = 1; i < points.length; i++)\n            ctx.lineTo(points[i][0], points[i][1]);\n        ctx.lineTo(points[0][0], points[0][1]);\n        ctx.lineWidth = width;\n        ctx.strokeStyle = borderColor;\n        if (fillColor)\n            ctx.fillStyle = fillColor;\n        else\n            ctx.fillStyle = \"rgba(0, 0, 0, 0)\";\n        ctx.setLineDash(dash);\n\n        ctx.fill();\n        ctx.stroke();\n        ctx.restore();\n    }\n\n    segment_complement(x1, y1, x2, y2, color, width, dash) {\n        color = color || this._defaultColor;\n        width = width || this._defaultWidth;\n        dash = dash || this._defaultDash;\n        const [x1l, y1l, x2l, y2l] = this.line_endpoints(x1, y1, x2, y2);\n        this.segment(x1l, y1l, x1, y1);\n        this.segment(x2, y2, x2l, y2l);\n    }\n\n    circle_endpoints(x, y, r) {\n        const [w, h] = [this.width(), this.height()];\n        const inUL = x*x + y*y < r*r;\n        const inUR = (x - w)*(x - w) + y*y < r*r;\n        const inDL = x*x + (y - h) * (y - h);\n        const inDR = (x - w)*(x - w) + (y - h)*(y - h) < r*r;\n\n        const intersections = [];\n        if (inUL != inUR) {\n            const d = Math.sqrt(r*r - y*y);\n            const x0 = x + d;\n            const x1 = x - d;\n            if (0 <= x0 && x0 <= w)\n                intersections.push([x0, 0]);\n            else if (0 <= x1 && x1 <= w)\n                intersections.push([x1, 0]);\n        }\n\n        if (inDL != inDR) {\n            const d = Math.sqrt(r*r - (y - h)*(y - h));\n            const x0 = x + d;\n            const x1 = x - d;\n            if (0 <= x0 && x0 <= w)\n                intersections.push([x0, h]);\n            else if (0 <= x1 && x1 <= w)\n                intersections.push([x1, h]);\n        }\n\n        if (inUL != inDL) {\n            const d = Math.sqrt(r*r - x*x);\n            const y0 = y + d;\n            const y1 = y - d;\n            if (0 <= y0 && y0 <= h)\n                intersections.push([0, y0]);\n            else if (0 <= y1 && y1 <= h)\n                intersections.push([0, y1]);\n        }\n\n        if (inUR != inDR) {\n            const d = Math.sqrt(r*r - (x - w)*(x - w));\n            const y0 = y + d;\n            const y1 = y - d;\n            if (0 <= y0 && y0 <= h)\n                intersections.push([w, y0]);\n            else if (0 <= y1 && y1 <= h)\n                intersections.push([w, y1]);\n        }\n\n        return intersections;\n    }\n\n    line_endpoints(x1, y1, x2, y2) {\n        const [w, h] = [this.width(), this.height()];\n\n        if (x1 == x2)\n            return [x1, 0, x1, h];\n        else if (y1 == y2)\n            return [0, y1, w, y1];\n        else {\n            let intersections = []\n\n            function point(t) {\n                const x = x1 + t * (x2 - x1);\n                const y = y1 + t * (y2 - y1);\n                return [x, y];\n            }\n\n            let t, x, y;\n            \n            t = (0 - x1) / (x2 - x1);\n            [x, y] = point(t);\n\n            if (0 <= y && y <= h)\n                intersections.push.apply(intersections, [x, y]);\n\n            t = (w - x1) / (x2 - x1);\n            [x, y] = point(t);\n\n            if (0 <= y && y <= h)\n                intersections.push.apply(intersections, [x, y]);\n\n            if (intersections.length == 4)\n                return intersections;\n\n            t = (0 - y1) / (y2 - y1);\n            [x, y] = point(t);\n\n            if (0 <= x && x <= w)\n                intersections.push.apply(intersections, [x, y]);\n            \n            if (intersections.length == 4)\n                return intersections;\n            \n            t = (h - y1) / (y2 - y1);\n            [x, y] = point(t);\n\n            if (0 <= x && x <= w)\n                intersections.push.apply(intersections, [x, y]);\n\n            return intersections;\n        }\n    }\n\n    line(x1, y1, x2, y2, color, width, dash) {\n        const [x1l, y1l, x2l, y2l] = this.line_endpoints(x1, y1, x2, y2);\n        this.segment(x1l, y1l, x2l, y2l, color, width, dash);\n    }\n\n    ray(x1, y1, x2, y2, color, width, dash) {\n        const [x1l, y1l, x2l, y2l] = this.line_endpoints(x1, y1, x2, y2);\n        function between1(a, m, b) {\n            return (a <= m && m <= b) || (b <= m && m <= a);\n        }\n        function between(xa, ya, x, y, xb, yb) {\n            return between1(xa, x, xb) && between1(ya, y, yb);\n        }\n        \n        if (!between(x1l, y1l, x1, y1, x2l, y2l)) {\n            if (between(x1, y1, x1l, y1l, x2, y2) ||\n                between(x1, y1, x2l, x2l, x2, y2))\n                this.segment(x1l, y1l, x2l, y2l, color, width, dash);\n            else\n                return;\n        }\n        if (between(x1l, y1l, x2, y2, x1, y1))\n            this.segment(x1, y1, x1l, y1l, color, width, dash);\n        else\n            this.segment(x1, y1, x2l, y2l, color, width, dash);\n    }\n    \n\n    line_label(x1, y1, x2, y2, label, color, font) {\n        let [x1l, y1l, x2l, y2l] = this.line_endpoints(x1, y1, x2, y2).map(x => Math.round(x));\n        if (y1l > y2l)\n            [x1l, y1l] = [x2l, y2l];\n\n\n        const offset = 15;\n        let x, y;\n        if (x1l == 0) {\n            x = 0;\n            y = y1l;\n        } else if (x1l == this.width()) {\n            x = this.width() - offset;\n            y = y1l;\n        } if (y1l == 0) {\n            x = x1l;\n            y = offset;\n        } else if (y1l == this.height()) {\n            x = x1l;\n            y = this.height() - offset;\n        }\n        this.text(x + 1, y, label, \"15px Arial\", color, font);\n    }\n\n    text(x, y, txt, font, color, xAlign, yAlign) {\n        font = font || \"15px Arial\";\n        color = color || \"black\";\n        xAlign = xAlign || \"left\";\n        yAlign = yAlign || \"middle\";\n\n        const width = this.width();\n        const height = this.height();\n        const ctx = this.context();\n        \n        function fixMargins(x, y, txt, font) {\n            ctx.font = font;\n            const metrics = ctx.measureText((0,_latex_js__WEBPACK_IMPORTED_MODULE_0__.removeLaTeX)(txt));\n            if (x + metrics.width > width)\n                x -= (x + metrics.width - width);\n            if (x < 0)\n                x = 0;\n            return [x, y];\n        }\n        \n        function renderText(x, y, txt, font) {\n            ctx.font = font;\n            ctx.textAlign = xAlign;\n            ctx.textBaseline = yAlign;\n            ctx.strokeStyle = 'white';\n            ctx.lineWidth = 2;\n            ctx.lineJoin = \"miter\";\n\t    ctx.miterLimit = 2;\n            ctx.strokeText(txt, x, y);\n            if (color)\n                ctx.fillStyle = color;\n            ctx.fillText(txt, x, y);\n\n            const metrics = ctx.measureText(txt);\n            const width = metrics.width;\n            return x + width;\n        }\n\n        function latex(x, y, txt, font) {\n            const m = (0,_latex_js__WEBPACK_IMPORTED_MODULE_0__.splitSubSupScript)(txt);\n            \n            if (m.subscript || m.supscript) {\n                let script, dy;\n                if (m.supscript) {\n                    script = m.supscript;\n                    dy = -2;\n                } else if (m.subscript) {\n                    script = m.subscript;\n                    dy = 2;\n                }\n                \n                const x1 = renderText(x, y, m.text, font);\n                const x2 = latex(x1, y + dy, script, (0,_font_js__WEBPACK_IMPORTED_MODULE_5__.reduceFont)(font));\n                if (!m.rest)\n                    return x2;\n                    \n                return latex(x2, y, m.rest, font);\n            } else {\n                return renderText(x, y, txt, font);\n            }\n        }\n\n        [x, y] = fixMargins(x, y, txt, font);\n        latex(x, y, txt, font);\n    }\n\n    message(msg) {\n        // this.text(5, 15, msg, \"15px Arial\", \"black\");\n        this._p_status.innerHTML = (0,_latex_js__WEBPACK_IMPORTED_MODULE_0__.laTeX2HTML)(msg);\n        if (msg != \"\") {\n            this._p_status.style.display = \"block\";\n        } else \n            this._p_status.style.display = \"none\";\n    }\n\n    addMessage(msg) {\n        if (this._p_status.innerHTML)\n            this._p_status.innerHTML += \"<br/>\";\n        this._p_status.innerHTML += (0,_latex_js__WEBPACK_IMPORTED_MODULE_0__.laTeX2HTML)(msg);\n    }\n\n    svg() {\n        return this._canvas2SVG.getSerializedSvg();\n    }\n}\n\n\n\n\n\n//# sourceURL=webpack://ArgoDG/./src/dg/canvas.js?");

/***/ }),

/***/ "./src/dg/colors.js":
/*!**************************!*\
  !*** ./src/dg/colors.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"getOpacity\": () => (/* binding */ getOpacity),\n/* harmony export */   \"hsvColor\": () => (/* binding */ hsvColor),\n/* harmony export */   \"parseRGB\": () => (/* binding */ parseRGB),\n/* harmony export */   \"rgb2hsv\": () => (/* binding */ rgb2hsv),\n/* harmony export */   \"rgbColor\": () => (/* binding */ rgbColor),\n/* harmony export */   \"setOpacity\": () => (/* binding */ setOpacity)\n/* harmony export */ });\nconst ctx = document.createElement(\"canvas\").getContext(\"2d\");\n\n// input: r,g,b in [0,1], out: h in [0,360) and s,v in [0,1]\nfunction rgb2hsv(r, g, b) {\n    let v=Math.max(r,g,b), c=v-Math.min(r,g,b);\n    let h= c && ((v==r) ? (g-b)/c : ((v==g) ? 2+(b-r)/c : 4+(r-g)/c)); \n    return [60*(h<0?h+6:h), v&&c/v, v];\n}\n\n// read RGB from rgb or rgba string\nfunction parseRGB(str) {\n    const m = str.match(/^rgba?\\s*\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*(,\\s*(\\d+([.]\\d*)?))?\\s*\\)$/i);\n    return m ? {\n        r: parseFloat(m[1]),\n        g: parseFloat(m[2]),\n        b: parseFloat(m[3])\n    } : null;\n}\n\n// convert color in any format to rgb\nfunction rgbColor(str){\n    function hexToRGB(hex) {\n        const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n        return result ? {\n            r: parseInt(result[1], 16),\n            g: parseInt(result[2], 16),\n            b: parseInt(result[3], 16)\n        } : null;\n    }\n\n    ctx.fillStyle = str;\n    const color = ctx.fillStyle;\n    if (color[0] == '#')\n        return hexToRGB(color);\n    else\n        return parseRGB(color);\n}\n\nfunction hsvColor(str) {\n    const rgb = rgbColor(str);\n    const hsv = rgb2hsv(rgb.r / 255, rgb.g / 255, rgb.b / 255);\n    return {h: hsv[0], s: hsv[1], v: hsv[2]};\n}\n\n// extract opacity from color string\nfunction getOpacity(color) {\n    const defaultOpacity = 1;\n    \n    if (!color)\n        return defaultOpacity;\n    const m = color.match(/^rgba\\s*\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+([.]\\d*)?)\\s*\\)$/i);\n    return parseFloat(m ? m[4] : defaultOpacity);\n}\n\n// set opacity to color string\nfunction setOpacity(color, o) {\n    const rgb = rgbColor(color);\n    return \"rgba(\" + rgb.r + \", \" + rgb.g + \", \" + rgb.b + \", \" + o + \")\";\n}\n\n\n//# sourceURL=webpack://ArgoDG/./src/dg/colors.js?");

/***/ }),

/***/ "./src/dg/construction.js":
/*!********************************!*\
  !*** ./src/dg/construction.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Construction\": () => (/* binding */ Construction)\n/* harmony export */ });\n/* harmony import */ var _view_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./view.js */ \"./src/dg/view.js\");\n\n\n/**\n * Construction is a list of DGObjects\n */\nclass Construction {\n    constructor() {\n        this._objects = [];\n        this._views = [];\n        this._listeners = [];        \n        this._animation_step = -1;\n    }\n\n    setView(view) {\n        this._views = [view];\n        view.addConstruction(this);\n    }\n\n    addView(view) {\n        this._views.push(view);\n        view.addConstruction(this);\n    }\n\n    addListener(listener) {\n        this._listeners.push(listener);\n    }    \n\n    addObject(o, redraw) {\n        if (!o) return;\n        this._objects.push(o);\n        o.addConstruction(this);\n        if (redraw === undefined || redraw)\n            this.draw();\n    }\n\n    removeObject(o, redraw) {\n        if (!o) return;\n        this._objects = this._objects.filter(obj => obj != o);\n        o.removeConstruction(this);\n        if (redraw === undefined || redraw)\n            this.draw();\n    }\n\n    removeAll(redraw) {\n        this._objects.forEach(o => {\n            if (o) {\n                o.removeConstruction(this);\n            }\n        });\n        this._objects = [];\n        if (redraw == undefined || redraw)\n            this.draw();\n    }\n\n    forEach(fun) {\n        this._objects.forEach(fun);\n    }\n\n    visibleObjects() {\n        let objects = this.animationInProgress() ?\n                      this._objects.slice(0, this._animation_step+1) :\n                      this._objects;\n        return objects.filter(obj => obj.visible());\n    }\n\n    drawView(view) {\n        view.drawObjects(this.visibleObjects());\n        if (this.animationInProgress()) {\n            const currentAnimationObject = this._objects[this._animation_step];\n            view.message(currentAnimationObject.describe());\n        }\n    }\n\n    draw() {\n        this._views.forEach(view => {\n            view.redraw();\n        });            \n    }\n\n    change(redraw) {\n        if (redraw == undefined || redraw)\n            this.draw();\n        this._listeners.forEach(listener => {\n            listener.change(this);\n        });\n    }    \n\n    animationInProgress() {\n        return this._animation_step != -1;\n    }\n\n    doAnimationStep(increment) {\n        do {\n            const n = this._objects.length;\n            this._animation_step = (this._animation_step + n + increment) % n;\n        } while (!this._objects[this._animation_step].visible());\n        this.draw();\n    }\n\n    nextAnimationStep() {\n        this.doAnimationStep(+1);\n    }\n    \n    prevAnimationStep() {\n        this.doAnimationStep(-1);\n    }\n    \n    animate() {\n        var self = this;\n        window.setInterval(function() {\n            self.nextAnimationStep();\n            self.drawAnimationStep();\n        }, 1000);\n    }\n\n\n    highlightAt(x, y, worldToScreen, highlighter) {\n        this._objects.forEach(obj => {\n            if (obj.visible() && obj.isNear(x, y, worldToScreen) && highlighter.shouldHighlight(obj))\n                obj.highlightOn();\n            else\n                obj.highlightOff();\n        });\n    }\n\n    findObjectsAt(x, y, worldToScreen) {\n        return this.visibleObjects().filter(p => p.isNear(x, y, worldToScreen));\n    }\n\n    findFreePointAt(x, y, worldToScreen) {\n        return this.findObjectsAt(x, y, worldToScreen).find(o => o.isFreePoint());\n    }\n    \n    findPointAt(x, y, worldToScreen) {\n        return this.findObjectsAt(x, y, worldToScreen).find(o => o.isPoint());\n    }\n\n    findLineAt(x, y, worldToScreen) {\n        return this.findObjectsAt(x, y, worldToScreen).find(o => o.isLine());\n    }\n\n    findCircleAt(x, y, worldToScreen) {\n        return this.findObjectsAt(x, y, worldToScreen).find(o => o.isCircle());\n    }\n\n    find(label) {\n        return this._objects.find(o => o.label() == label);\n    }\n\n    includes(label) {\n        // this can be faster if all object labels are put in a hash-set  \n        return this._objects.some(o => o.label() == label);\n    }\n}\n\n\n\n\n//# sourceURL=webpack://ArgoDG/./src/dg/construction.js?");

/***/ }),

/***/ "./src/dg/dg.js":
/*!**********************!*\
  !*** ./src/dg/dg.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"If\": () => (/* binding */ If),\n/* harmony export */   \"Vector2\": () => (/* reexport safe */ _objects_js__WEBPACK_IMPORTED_MODULE_0__.Vector2),\n/* harmony export */   \"addObject\": () => (/* binding */ addObject),\n/* harmony export */   \"animate\": () => (/* binding */ animate),\n/* harmony export */   \"animationButtons\": () => (/* binding */ animationButtons),\n/* harmony export */   \"arc\": () => (/* binding */ arc),\n/* harmony export */   \"between\": () => (/* binding */ between),\n/* harmony export */   \"center\": () => (/* binding */ center),\n/* harmony export */   \"circle\": () => (/* binding */ circle),\n/* harmony export */   \"clone\": () => (/* binding */ clone),\n/* harmony export */   \"constant\": () => (/* binding */ constant),\n/* harmony export */   \"construction\": () => (/* binding */ construction),\n/* harmony export */   \"constructionToolbar\": () => (/* binding */ constructionToolbar),\n/* harmony export */   \"container\": () => (/* binding */ container),\n/* harmony export */   \"convexAngle\": () => (/* binding */ convexAngle),\n/* harmony export */   \"convexArc\": () => (/* binding */ convexArc),\n/* harmony export */   \"distance\": () => (/* binding */ distance),\n/* harmony export */   \"findCircleAt\": () => (/* binding */ findCircleAt),\n/* harmony export */   \"findFreePointAt\": () => (/* binding */ findFreePointAt),\n/* harmony export */   \"findLineAt\": () => (/* binding */ findLineAt),\n/* harmony export */   \"findObjectsAt\": () => (/* binding */ findObjectsAt),\n/* harmony export */   \"findPointAt\": () => (/* binding */ findPointAt),\n/* harmony export */   \"intersectCC_any\": () => (/* binding */ intersectCC_any),\n/* harmony export */   \"intersectCC_both\": () => (/* binding */ intersectCC_both),\n/* harmony export */   \"intersectCC_select\": () => (/* binding */ intersectCC_select),\n/* harmony export */   \"intersectLC_any\": () => (/* binding */ intersectLC_any),\n/* harmony export */   \"intersectLC_both\": () => (/* binding */ intersectLC_both),\n/* harmony export */   \"intersectLC_select\": () => (/* binding */ intersectLC_select),\n/* harmony export */   \"intersectLL\": () => (/* binding */ intersectLL),\n/* harmony export */   \"line\": () => (/* binding */ line),\n/* harmony export */   \"midpoint\": () => (/* binding */ midpoint),\n/* harmony export */   \"nextAnimationStep\": () => (/* binding */ nextAnimationStep),\n/* harmony export */   \"num\": () => (/* binding */ num),\n/* harmony export */   \"orientedAngle\": () => (/* binding */ orientedAngle),\n/* harmony export */   \"poincareDiscCircle\": () => (/* binding */ poincareDiscCircle),\n/* harmony export */   \"poincareDiscCircleR\": () => (/* binding */ poincareDiscCircleR),\n/* harmony export */   \"poincareDiscLine\": () => (/* binding */ poincareDiscLine),\n/* harmony export */   \"poincareHalfPlaneCircle\": () => (/* binding */ poincareHalfPlaneCircle),\n/* harmony export */   \"poincareHalfPlaneCircleR\": () => (/* binding */ poincareHalfPlaneCircleR),\n/* harmony export */   \"poincareHalfPlaneLine\": () => (/* binding */ poincareHalfPlaneLine),\n/* harmony export */   \"point\": () => (/* binding */ point),\n/* harmony export */   \"pointFun\": () => (/* binding */ pointFun),\n/* harmony export */   \"polygon\": () => (/* binding */ polygon),\n/* harmony export */   \"prevAnimationStep\": () => (/* binding */ prevAnimationStep),\n/* harmony export */   \"randomPoint\": () => (/* binding */ randomPoint),\n/* harmony export */   \"randomPointOnCircle\": () => (/* binding */ randomPointOnCircle),\n/* harmony export */   \"randomPointOnLine\": () => (/* binding */ randomPointOnLine),\n/* harmony export */   \"ray\": () => (/* binding */ ray),\n/* harmony export */   \"redraw\": () => (/* binding */ redraw),\n/* harmony export */   \"removeAll\": () => (/* binding */ removeAll),\n/* harmony export */   \"removeObject\": () => (/* binding */ removeObject),\n/* harmony export */   \"segment\": () => (/* binding */ segment),\n/* harmony export */   \"setConstruction\": () => (/* binding */ setConstruction),\n/* harmony export */   \"setup\": () => (/* binding */ setup),\n/* harmony export */   \"svg\": () => (/* binding */ svg),\n/* harmony export */   \"text\": () => (/* binding */ text),\n/* harmony export */   \"vector\": () => (/* binding */ vector),\n/* harmony export */   \"vectorFun\": () => (/* binding */ vectorFun),\n/* harmony export */   \"vectorXY\": () => (/* binding */ vectorXY),\n/* harmony export */   \"view\": () => (/* binding */ view)\n/* harmony export */ });\n/* harmony import */ var _objects_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./objects.js */ \"./src/dg/objects.js\");\n/* harmony import */ var _graphics_view_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./graphics_view.js */ \"./src/dg/graphics_view.js\");\n/* harmony import */ var _construction_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./construction.js */ \"./src/dg/construction.js\");\n/* harmony import */ var _animation_buttons_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./animation_buttons.js */ \"./src/dg/animation_buttons.js\");\n/* harmony import */ var _tools_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./tools.js */ \"./src/dg/tools.js\");\n/* harmony import */ var _complex_geom_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../complex_geom.js */ \"./src/complex_geom.js\");\n\n\n\n\n\n\n\n// -----------------------------------------------------------------------------\n// API and a global register of all DGobjects\n// -----------------------------------------------------------------------------\n\nlet _global_construction = new _construction_js__WEBPACK_IMPORTED_MODULE_2__.Construction();\nlet _global_view = null;\n\n// current construction and view (either global or provided by the user)\nlet _construction = _global_construction;\nlet _view = _global_view;\n\nlet _animation_buttons = null;\nlet _construction_toolbar = null;\n\nfunction setup(element, options, xmin, xmax, ymin, ymax) {\n   if (arguments.length == 2)\n        _global_view = new _graphics_view_js__WEBPACK_IMPORTED_MODULE_1__.GraphicsView(element, options);\n    else\n        _global_view = new _graphics_view_js__WEBPACK_IMPORTED_MODULE_1__.GraphicsView(element, options, xmin, xmax, ymin, ymax);\n\n    _construction = _global_construction;\n    _view = _global_view;\n    \n    _construction.setView(_view);\n    _view.setTool(new _tools_js__WEBPACK_IMPORTED_MODULE_4__.ToolDragFree(_view, _construction));\n}\n\nfunction setConstruction(construction) {\n    _construction = construction ? construction : _global_construction;\n    _construction.setView(_view);\n    _view.setConstruction(_construction);\n    _view.setTool(new _tools_js__WEBPACK_IMPORTED_MODULE_4__.ToolDragFree(_view, _construction));\n}\n\nfunction construction() {\n    return _construction;\n}\n\nfunction view() {\n    return _view;\n}\n\nfunction container() {\n    return this.view().canvas().container();\n}\n\nfunction svg() {\n    return this.view().canvas().svgString();\n}\n\nfunction redraw() {\n    _construction.draw();\n}\n\nfunction addObject(o, redraw) {\n    _construction.addObject(o, redraw);\n}\n\nfunction removeObject(o, redraw) {\n    _construction.removeObject(o, redraw);\n    o.dispose(redraw);\n}\n\nfunction removeAll(redraw) {\n    const objects = [..._construction._objects];\n    _construction.removeAll(redraw);\n    objects.forEach(o => o.dispose(redraw));\n}\n\nfunction text(text, x, y, redraw) {\n    const t = new _objects_js__WEBPACK_IMPORTED_MODULE_0__.DGText(text, x, y);\n    addObject(t, redraw);\n    return t;\n}\n\nfunction point(x, y, redraw, validity_check) {\n    const p = new _objects_js__WEBPACK_IMPORTED_MODULE_0__.DGPoint(x, y, validity_check);\n    addObject(p, redraw);\n    return p;\n}\n\nfunction randomPoint(redraw, validity_check, xmin, xmax, ymin, ymax) {\n    const p = new _objects_js__WEBPACK_IMPORTED_MODULE_0__.DGRandomPoint(validity_check, xmin, xmax, ymin, ymax);\n    addObject(p, redraw);\n    return p;\n}\n\nfunction randomPointOnCircline(cl, redraw, validity_check, disc) {\n    const p = new _objects_js__WEBPACK_IMPORTED_MODULE_0__.DGRandomPointOnCircline(cl, {\"validity_check\": validity_check, \"disc\": disc});\n    addObject(p, redraw);\n    return p;\n}\n\nfunction randomPointOnLine(line, redraw, validity_check, disc) {\n    return randomPointOnCircline(line, redraw, validity_check, disc);\n}\n\nfunction randomPointOnCircle(circle, redraw, validity_check, disc) {\n    return randomPointOnCircline(circle, redraw, validity_check, disc);\n}\n\nfunction pointFun(fun, dependent, redraw) {\n    const p = new _objects_js__WEBPACK_IMPORTED_MODULE_0__.DGPointFun(fun, dependent);\n    addObject(p, redraw);\n    return p;\n}\n\nfunction vector(startPoint, arg2, redraw) {\n    const p = new _objects_js__WEBPACK_IMPORTED_MODULE_0__.DGVector(startPoint, arg2);\n    addObject(p, redraw);\n    return p;\n}\n\nfunction vectorXY(startPoint, x, y, redraw) {\n    const p = new _objects_js__WEBPACK_IMPORTED_MODULE_0__.DGVectorXY(startPoint, x, y);\n    addObject(p, redraw);\n    return p;\n}\n\nfunction vectorFun(startPoint, fun, dependencies, redraw) {\n    const p = new _objects_js__WEBPACK_IMPORTED_MODULE_0__.DGVectorFun(startPoint, fun, dependencies);\n    addObject(p, redraw);\n    return p;\n}\n\nfunction line(P1, P2, redraw) {\n    const l = new _objects_js__WEBPACK_IMPORTED_MODULE_0__.DGLine(P1, P2);\n    addObject(l, redraw);\n    return l;\n}\n\nfunction ray(O, A, redraw) {\n    const l = new _objects_js__WEBPACK_IMPORTED_MODULE_0__.DGRay(O, A);\n    addObject(l, redraw);\n    return l;\n}\n\nfunction circle(C, P, redraw) {\n    const c = new _objects_js__WEBPACK_IMPORTED_MODULE_0__.DGCircle(C, P);\n    addObject(c, redraw);\n    return c;\n}\n\nfunction intersectLL(l1, l2, redraw) {\n    const p = new _objects_js__WEBPACK_IMPORTED_MODULE_0__.DGIntersectLL(l1, l2);\n    addObject(p, redraw);\n    return p;\n}\n\nfunction intersectLC(l, c, redraw, includeFictive) {\n    const p = new _objects_js__WEBPACK_IMPORTED_MODULE_0__.DGIntersectLC(l, c, includeFictive);\n    addObject(p, redraw);\n    return p;\n}\n\nfunction intersectLC_both(l, c, redraw, includeFictive) {\n    const i = intersectLC(l, c, redraw, includeFictive);\n    const [p1, p2] = i.both();\n    addObject(p1, false);\n    addObject(p2, redraw);\n    return [p1, p2];\n}\n\nfunction intersectLC_any(l, c, redraw, includeFictive) {\n    const i = intersectLC(l, c, redraw, includeFictive);\n    const p = i.any();\n    addObject(p, redraw);\n    return p;\n}\n\nfunction intersectLC_select(l, c, select_fun, redraw, includeFictive) {\n    const i = intersectLC(l, c, redraw, includeFictive);\n    const p = i.select(select_fun);\n    p._createdObjects.push(i);\n    addObject(p, redraw);\n    return p;\n}\n\nfunction intersectCC(c1, c2, redraw, includeFictive) {\n    const p = new _objects_js__WEBPACK_IMPORTED_MODULE_0__.DGIntersectCC(c1, c2, includeFictive);\n    addObject(p, redraw);\n    return p;\n}\n\nfunction intersectCC_both(c1, c2, redraw, includeFictive) {\n    const i = intersectCC(c1, c2, redraw, includeFictive);\n    const [p1, p2] = i.both();\n    addObject(p1, false);\n    addObject(p2, redraw);\n    return [p1, p2];\n}\n\nfunction intersectCC_any(c1, c2, redraw, includeFictive) {\n    const i = intersectCC(c1, c2, redraw, includeFictive);\n    const p = i.any();\n    addObject(p, redraw);\n    return p;\n}\n\nfunction intersectCC_select(c1, c2, select_fun, redraw, includeFictive) {\n    const i = intersectCC(c1, c2, redraw, includeFictive);\n    const p = i.select(select_fun);\n    addObject(p, redraw);\n    return p;\n}\n\nfunction clone(obj, redraw) {\n    const c = new _objects_js__WEBPACK_IMPORTED_MODULE_0__.DGClone(obj);\n    addObject(c, redraw);\n    return c;\n}\n\nfunction If(cond, then_object, else_object, dependencies, redraw) {\n    const p = new _objects_js__WEBPACK_IMPORTED_MODULE_0__.DGIf(cond, then_object, else_object, dependencies);\n    addObject(p, redraw);\n    return p;\n}\n\nfunction distance(pointA, pointB, redraw) {\n    const n = DG.num((a, b) => {\n        const dx = b.x() - a.x();\n        const dy = b.y() - a.y();\n        return Math.sqrt(dx*dx + dy*dy);\n    }, [pointA, pointB]);\n    addObject(n, redraw);\n    return n;\n}\n\nfunction center(c, redraw) {\n    const cc = new _objects_js__WEBPACK_IMPORTED_MODULE_0__.DGCircleCenterPoint(c);\n    addObject(cc, redraw);\n    return cc;\n}\n\nfunction poincareDiscLine(p1, p2, redraw) {\n    const l = new _objects_js__WEBPACK_IMPORTED_MODULE_0__.DGPoincareDiscLine(p1, p2);\n    addObject(l, redraw);\n    return l;\n}\n\nfunction poincareDiscCircle(c, p, redraw) {\n    const pc = new _objects_js__WEBPACK_IMPORTED_MODULE_0__.DGPoincareDiscCircle(c, p);\n    addObject(pc, redraw);\n    return pc;\n}\n\nfunction poincareDiscCircleR(c, r, redraw) {\n    const pc = new _objects_js__WEBPACK_IMPORTED_MODULE_0__.DGPoincareDiscCircleR(c, r);\n    addObject(pc, redraw);\n    return pc;\n}\n\nfunction poincareHalfPlaneLine(p1, p2, redraw) {\n    const l = new _objects_js__WEBPACK_IMPORTED_MODULE_0__.DGPoincareHalfPlaneLine(p1, p2);\n    addObject(l, redraw);\n    return l;\n}\n\nfunction poincareHalfPlaneCircle(o, a, redraw) {\n    const c = new _objects_js__WEBPACK_IMPORTED_MODULE_0__.DGPoincareHalfPlaneCircle(o, a);\n    addObject(c, redraw);\n    return c;\n}\n\nfunction poincareHalfPlaneCircleR(c, r, redraw) {\n    const pc = new _objects_js__WEBPACK_IMPORTED_MODULE_0__.DGPoincareHalfPlaneCircleR(c, r);\n    addObject(pc, redraw);\n    return pc;\n}\n\nfunction segment(p1, p2, redraw) {\n    const s = new _objects_js__WEBPACK_IMPORTED_MODULE_0__.DGSegment(p1, p2);\n    addObject(s, redraw);\n    return s;\n}\n\nfunction midpoint(A, B, redraw) {\n    return DG.pointFun((a, b) => [(a.x() + b.x()) / 2, (a.y() + b.y()) / 2], [A, B], redraw);\n}\n\nfunction arc(p1, p, p2, redraw) {\n    const a = new _objects_js__WEBPACK_IMPORTED_MODULE_0__.DGArc(p1, p, p2);\n    addObject(a, redraw);\n    return a;\n}\n\nfunction convexArc(O, A, B, redraw, convex) {\n    const a = new _objects_js__WEBPACK_IMPORTED_MODULE_0__.DGConvexArc(O, A, B, convex);\n    addObject(a, redraw);\n    return a;\n}\n\nfunction orientedAngle(A, O, B, r, redraw) {\n    const a = new _objects_js__WEBPACK_IMPORTED_MODULE_0__.DGOrientedAngle(A, O, B, r);\n    addObject(a, redraw);\n    return a;\n}\n\nfunction convexAngle(A, O, B, r, redraw) {\n    const a = new _objects_js__WEBPACK_IMPORTED_MODULE_0__.DGConvexAngle(A, O, B, r);\n    addObject(a, redraw);\n    return a;\n}\n\nfunction polygon(points, redraw) {\n    const p = new _objects_js__WEBPACK_IMPORTED_MODULE_0__.DGPolygon(points);\n    addObject(p, redraw);\n    return p;\n}\n\nfunction constant(value, redraw) {\n    const c = new _objects_js__WEBPACK_IMPORTED_MODULE_0__.DGConst(value);\n    addObject(c, redraw);\n    return c;\n}\n\nfunction num(fun, dependencies, redraw) {\n    const n = new _objects_js__WEBPACK_IMPORTED_MODULE_0__.DGNum(fun, dependencies);\n    addObject(n, redraw);\n    return n;\n}\n\nfunction findFreePointAt(x, y, transform) {\n    return _construction.findFreePointAt(x, y, transform);\n}\n    \nfunction findPointAt(x, y, transform) {\n    return _construction.findPointAt(x, y, transform);\n}\n\nfunction findLineAt(x, y, transform) {\n    return _construction.findLineAt(x, y, transform);\n}\n\nfunction findCircleAt(x, y, transform) {\n    return _construction.findCircleAt(x, y, transform);\n}\n\nfunction findObjectsAt(x, y, transform) {\n    return _construction.findObjectsAt(x, y, transform);\n}\n\nfunction nextAnimationStep() {\n    _construction.nextAnimationStep();\n}\n\nfunction prevAnimationStep() {\n    _construction.prevAnimationStep();\n}\n\nfunction animate() {\n    _construction.animate();\n}\n\nfunction animationButtons(element) {\n    if (!element)\n        element = _view.canvas().container();\n    if (!_animation_buttons)\n        _animation_buttons = new _animation_buttons_js__WEBPACK_IMPORTED_MODULE_3__.AnimationButtons(_construction, element);\n}\n\nfunction constructionToolbar(element) {\n    if (!element)\n        element = _view.canvas().container();\n    \n    if (!_construction_toolbar)\n        _construction_toolbar = new _tools_js__WEBPACK_IMPORTED_MODULE_4__.ConstructionToolbar(_construction, _view, element);\n}\n\n\nfunction between(A, X, B) {\n    return _complex_geom_js__WEBPACK_IMPORTED_MODULE_5__.Circline.between(A, X, B);\n}\n\n\n\n\n//# sourceURL=webpack://ArgoDG/./src/dg/dg.js?");

/***/ }),

/***/ "./src/dg/font.js":
/*!************************!*\
  !*** ./src/dg/font.js ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"reduceFont\": () => (/* binding */ reduceFont),\n/* harmony export */   \"splitFont\": () => (/* binding */ splitFont),\n/* harmony export */   \"textWidth\": () => (/* binding */ textWidth)\n/* harmony export */ });\nconst ctx = document.createElement(\"canvas\").getContext(\"2d\");\n\nfunction splitFont(font) {\n    const m = font.match(/^(\\d+)(\\w+)\\s+((\\w|\\s)+)$/)\n    const size = parseInt(m[1]);\n    const units = m[2];\n    const family = m[3];\n    return [size, units, family];\n}\n\nfunction reduceFont(font, percent) {\n    percent = percent || 0.75;\n    const [size, units, family] = splitFont(font);\n    return Math.ceil(percent*size) + units + \" \" + family;\n}\n\nfunction textWidth(txt, font) {\n    ctx.font = font;\n    const metrics = ctx.measureText(txt);\n    const width = metrics.width;\n    return width;\n}\n\n\n//# sourceURL=webpack://ArgoDG/./src/dg/font.js?");

/***/ }),

/***/ "./src/dg/graphics_view.js":
/*!*********************************!*\
  !*** ./src/dg/graphics_view.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"GraphicsView\": () => (/* binding */ GraphicsView)\n/* harmony export */ });\n/* harmony import */ var _view__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./view */ \"./src/dg/view.js\");\n/* harmony import */ var _canvas_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./canvas.js */ \"./src/dg/canvas.js\");\n/* harmony import */ var _font_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./font.js */ \"./src/dg/font.js\");\n/* harmony import */ var _latex_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./latex.js */ \"./src/dg/latex.js\");\n\n\n\n\n\n// -----------------------------------------------------------------------------\n// drawing view enables drawing objects given in the world coordinate system\n// -----------------------------------------------------------------------------\nclass GraphicsView extends _view__WEBPACK_IMPORTED_MODULE_0__.View {\n    constructor(element, options, xmin, xmax, ymin, ymax) {\n        super();\n        \n        if (arguments.length == 2) {\n            [xmin, xmax] = [-5, 5];\n            [ymin, ymax] = [-5, 5];\n        }\n        this._canvas = new _canvas_js__WEBPACK_IMPORTED_MODULE_1__.Canvas(element, options);\n        this.setVisibleRange(xmin, xmax, ymin, ymax);\n        \n        // tool that react to the mouse and keyboard events\n        this._tool = undefined;\n\n        // panning tool\n        this._startPan = undefined;\n        \n        this.addEventListener('mousemove', this.mousemove.bind(this), false);\n        this.addEventListener('mousedown', this.mousedown.bind(this), false);\n        this.addEventListener('mouseup', this.mouseup.bind(this), false);\n        document.body.addEventListener('keydown', this.keydown.bind(this), false);\n    }\n\n    setVisibleRange(xmin, xmax, ymin, ymax) {\n        this._xmin = xmin;\n        this._xmax = xmax;\n        this._ymin = ymin;\n        this._ymax = ymax;\n        this._scalex = (this._canvas.width()) / (xmax - xmin);\n        this._scaley = (this._canvas.height()) / (ymax - ymin);\n        this._x0 = -xmin * this._scalex;\n        this._y0 = ymax * this._scaley;\n    }\n\n    drawObjects(objects) {\n        // draw points above other objects\n        objects.filter(o => !o.isPoint()).forEach(obj => {this.drawObject(obj);});\n        objects.filter(o => o.isPoint()).forEach(obj => {this.drawObject(obj);});\n    }\n\n    zoom(factor) {\n        const w = this._xmax - this._xmin;\n        const h = this._ymax - this._ymin;\n        const cx = (this._xmin + this._xmax) / 2;\n        const cy = (this._ymin + this._ymax) / 2;\n        this.setVisibleRange(cx - w/(2 * factor), cx + w/(2 * factor),\n                             cy - h/(2 * factor), cy + h/(2 * factor));\n        this.redraw();\n    }\n\n    pan(startPan, endPan) {\n        const dX = endPan.X - startPan.X;\n        const dY = endPan.Y - startPan.Y;\n        const w = this._canvas.width();\n        const h = this._canvas.height();\n        const dx = -dX / w * (this._xmax - this._xmin);\n        const dy = dY / w * (this._xmax - this._xmin);\n        this.setVisibleRange(this._xmin + dx, this._xmax + dx,\n                             this._ymin + dy, this._ymax + dy);\n        this.redraw();\n    }\n\n    canvas() {\n        return this._canvas;\n    }\n\n    addEventListener(event, fun) {\n        this._canvas.addEventListener(event, fun);\n    }\n\n    clear() {\n        this._canvas.clear();\n    }\n\n    worldToScreen(x, y) {\n        return [this._x0 + x * this._scalex, this._y0 - y * this._scaley];\n    }\n\n    screenToWorld(x, y) {\n        return [(x - this._x0) / this._scalex, (this._y0 - y) / this._scaley];\n    }\n\n    point(x, y, options) {\n        options = options || {}\n        const size = options.size || 1;\n        const [xt, yt] = this.worldToScreen(x, y);\n        const r = 4*size;\n        if (r >= 2)\n            this._canvas.circle(xt, yt, 4 * size, \"black\", undefined, undefined, options.color)\n        else\n            this._canvas.point(xt, yt, \"black\");\n    }\n\n    vector(x1, y1, x2, y2, options) {\n        options = options || {};\n        const [x1t, y1t] = this.worldToScreen(x1, y1);\n        const [x2t, y2t] = this.worldToScreen(x2, y2);\n        this._canvas.vector(x1t, y1t, x2t, y2t, options.color, options.width, options.dash);\n    }\n\n    text(x, y, txt, font, color, size) {\n        size = size || 0;\n        const [xt, yt] = this.worldToScreen(x, y);\n        const displace = 7 + 3*size;\n        if (xt < this._canvas.width() / 2)\n            this._canvas.text(xt - displace - (0,_font_js__WEBPACK_IMPORTED_MODULE_2__.textWidth)((0,_latex_js__WEBPACK_IMPORTED_MODULE_3__.removeLaTeX)(txt), font), yt, txt, font, color);\n        else\n            this._canvas.text(xt + displace, yt, txt, font, color);\n    }\n    \n    segment(x1, y1, x2, y2, options) {\n        options = options || {};\n        const [x1t, y1t] = this.worldToScreen(x1, y1);\n        const [x2t, y2t] = this.worldToScreen(x2, y2);\n        this._canvas.segment(x1t, y1t, x2t, y2t, options.color, options.width, options.dash);\n    }\n\n    segment_complement(x1, y1, x2, y2, options) {\n        options = options || {}\n        const [x1t, y1t] = this.worldToScreen(x1, y1);\n        const [x2t, y2t] = this.worldToScreen(x2, y2);\n        this._canvas.segment_complement(x1t, y1t, x2t, y2t, options.color, options.width, options.dash);\n    }\n    \n    line(x1, y1, x2, y2, options) {\n        options = options || {};\n        const [x1t, y1t] = this.worldToScreen(x1, y1);\n        const [x2t, y2t] = this.worldToScreen(x2, y2);\n        this._canvas.line(x1t, y1t, x2t, y2t, options.color, options.width, options.dash);\n    }\n\n    ray(x1, y1, x2, y2, options) {\n        options = options || {};\n        const [x1t, y1t] = this.worldToScreen(x1, y1);\n        const [x2t, y2t] = this.worldToScreen(x2, y2);\n        this._canvas.ray(x1t, y1t, x2t, y2t, options.color, options.width, options.dash);\n    }\n    \n    circle(x, y, r, options) {\n        options = options || {};\n        const [xt, yt] = this.worldToScreen(x, y);\n        const rt = r * this._scalex; // FIXME: different scales\n        this._canvas.circle(xt, yt, rt, options.color, options.width, options.dash);\n    }\n\n    arc(x, y, r, start_angle, end_angle, counterclockwise, options) {\n        options = options || {};\n        const [xt, yt] = this.worldToScreen(x, y);\n        const rt = r * this._scalex; // FIXME: different scales\n        this._canvas.arc(xt, yt, rt, start_angle, end_angle, counterclockwise, options.color, options.width, options.dash, options.fillColor);\n    }\n\n    polygon(points, options) {\n        options = options || {};\n        this._canvas.polygon(points.map(p => this.worldToScreen(p[0], p[1])), options.borderColor, options.width, options.dash, options.fillColor);\n    }\n\n    line_label(x1, y1, x2, y2, label, color) {\n        const [x1t, y1t] = this.worldToScreen(x1, y1);\n        const [x2t, y2t] = this.worldToScreen(x2, y2);\n        this._canvas.line_label(x1t, y1t, x2t, y2t, label, color);\n    }\n\n    message(msg) {\n        this._canvas.message(msg);\n    }\n\n    addMessage(msg) {\n        this._canvas.addMessage(msg);\n    }\n\n    setTool(tool) {\n        this._tool = tool;\n    }    \n\n    getMousePosition(e) {\n        return {X: e.offsetX, Y: e.offsetY};\n    }\n    \n    mousemove(e) {\n        // mouse position\n        const p = this.getMousePosition(e);\n        \n        // panning\n        if (this._startPan) {\n            this.pan(this._startPan, p);\n            this._startPan = p;\n        }\n\n        // specific actions by the current tool \n        if (this._tool)\n            this._tool.mousemove(p.X, p.Y,\n                                 this.worldToScreen.bind(this),\n                                 this.screenToWorld.bind(this));\n    }\n\n    findObjectsAt(x, y) {\n        let objects = [];\n        this._constructions.forEach(construction => {\n            const c_objects = construction.findObjectsAt(x, y,\n                                                         this.worldToScreen.bind(this));\n            objects.push(...c_objects);\n        });\n        return objects;\n    }\n\n    mousedown(e) {\n        // mouse position\n        const p = this.getMousePosition(e);\n        \n        // panning\n        if (e.ctrlKey)\n            this._startPan = p;\n\n        // show description\n        if (e.shiftKey) {\n            const p = this.getMousePosition(e);\n            const objects = this.findObjectsAt(p.X, p.Y);\n            \n            this.message(\"\");\n            objects.forEach(obj => {\n                this.addMessage(obj.describe());\n            });\n        }\n        \n        // specific actions by the current tool \n        if (this._tool)\n            this._tool.mousedown(p.X, p.Y,\n                                 this.worldToScreen.bind(this),\n                                 this.screenToWorld.bind(this));\n    }\n\n    mouseup(e) {\n        // mouse position\n        const p = this.getMousePosition(e);\n        \n        // panning\n        if (this._startPan) {\n            this.pan(this._startPan, p);\n            this._startPan = undefined;\n        }\n\n        // reset message\n        if (e.shiftKey)\n            this.message(\"\");\n\n        // specific actions by the current tool \n        if (this._tool)\n            this._tool.mouseup(p.X, p.Y,\n                               this.worldToScreen.bind(this),\n                               this.screenToWorld.bind(this));\n    }\n\n    keydown(e) {\n        // zooming\n        if (e.ctrlKey && e.code == 'NumpadAdd') { // numpad +\n            e.preventDefault();\n            this.zoom(1.5);\n        } else if (e.ctrlKey && e.code == 'NumpadSubtract') { // numpad -\n            e.preventDefault();\n            this.zoom(1 / 1.5);\n        }\n\n        // specific actions by the current tool \n        if (this._tool)\n            this._tool.keydown(e,\n                               this.worldToScreen.bind(this),\n                               this.screenToWorld.bind(this));\n    }\n\n    svgString() {\n        return this._canvas.svgString();\n    }\n}\n\n\n\n\n//# sourceURL=webpack://ArgoDG/./src/dg/graphics_view.js?");

/***/ }),

/***/ "./src/dg/latex.js":
/*!*************************!*\
  !*** ./src/dg/latex.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"laTeX2HTML\": () => (/* binding */ laTeX2HTML),\n/* harmony export */   \"normalizeBraces\": () => (/* binding */ normalizeBraces),\n/* harmony export */   \"removeLaTeX\": () => (/* binding */ removeLaTeX),\n/* harmony export */   \"splitSubSupScript\": () => (/* binding */ splitSubSupScript)\n/* harmony export */ });\nfunction fixpointReplace(str, re, replacement) {\n    while(true) {\n        const newStr = str.replace(re, replacement);\n        if (newStr == str)\n            return str;\n        str = newStr;\n    }\n}\n\nfunction normalizeBraces(str) {\n    return str ? fixpointReplace(str, /([\\w'()]+)_(\\w)/g, '$1_{$2}') : \"\";\n}\n\nfunction laTeX2HTML(str) {\n    return str ? fixpointReplace(normalizeBraces(str), /([\\w'()]+)_{([\\w<>/]+)}/g, '$1<sub>$2</sub>') : \"\";\n}\n\nfunction removeLaTeX(str) {\n    return str ? fixpointReplace(normalizeBraces(str), /([\\w'()]+)_{(\\w+)}/g, '$1$2') : \"\";\n}\n\nfunction splitSubSupScript(str) {\n    if (!str)\n        return {};\n\n    str = normalizeBraces(str);\n\n    let i = 0;\n    while (i < str.length && str[i] != \"_\" && str[i] != \"^\")\n        i++;\n\n    let scriptType = \"\";\n    if (i < str.length)\n        scriptType = str[i];\n\n    let result = {text: str.substring(0, i)};\n    i++;\n    let braces = 0;\n    const scriptStart = i + 1;\n    while (i < str.length) {\n        if (str[i] == '{')\n            braces++;\n        if (str[i] == '}')\n            braces--;\n        if (braces == 0) {\n            const scriptEnd = i - 1;\n            const script = str.substring(scriptStart, scriptEnd + 1);\n\n            if (scriptType == '_')\n                result.subscript = script;\n            else if (scriptType == '^')\n                result.supscript = script;\n            \n            if (i + 1 < str.length)\n                result.rest = str.substring(i+1);\n            return result;\n        }\n        i++;\n    }\n    return result;\n}\n\n\n\n\n//# sourceURL=webpack://ArgoDG/./src/dg/latex.js?");

/***/ }),

/***/ "./src/dg/list_view.js":
/*!*****************************!*\
  !*** ./src/dg/list_view.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ListView\": () => (/* binding */ ListView)\n/* harmony export */ });\n/* harmony import */ var _view__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./view */ \"./src/dg/view.js\");\n\n\nclass ListView extends _view__WEBPACK_IMPORTED_MODULE_0__.View {\n    constructor(element) {\n        super();\n        this._element = element;\n    }\n    \n    drawObjects(objects) {\n        const table = document.createElement(\"table\");\n        table.classList.add(\"objects\");\n        this._element.append(table);\n        let tr = document.createElement(\"tr\");\n        table.append(tr);\n        const th1 = document.createElement(\"th\");\n        th1.innerHTML = \"Label\";\n        tr.append(th1);\n        const th2 = document.createElement(\"th\");\n        th2.innerHTML = \"Description\";\n        tr.append(th2);\n        \n        objects.forEach(obj => {\n            tr = document.createElement(\"tr\");\n            table.append(tr);\n            const td1 = document.createElement(\"td\");\n            tr.append(td1);\n            td1.innerHTML = obj.label();\n            const td2 = document.createElement(\"td\");\n            tr.append(td2);\n            td2.innerHTML = obj.description();\n\n            tr.addEventListener(\"mouseenter\", () => { obj.highlightOn(); });\n            tr.addEventListener(\"mouseleave\", () => { obj.highlightOff(); });\n            td1.addEventListener(\"click\", (e) => {\n                const input = document.createElement(\"input\");\n                input.type = \"text\";\n                input.value = obj.label();\n                td1.innerHTML = \"\";\n                td1.append(input);\n                input.focus();\n                input.addEventListener(\"blur\", (e) => {\n                    obj.label(input.value);\n                });\n            });\n        });\n    }\n\n    redraw() {\n        this.clear();\n        this._constructions.forEach(construction => {\n            construction.drawView(this);\n        });\n    }\n\n    clear() {\n        this._element.innerHTML = \"\";\n    }\n}\n\n\n\n\n//# sourceURL=webpack://ArgoDG/./src/dg/list_view.js?");

/***/ }),

/***/ "./src/dg/objects.js":
/*!***************************!*\
  !*** ./src/dg/objects.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DGArc\": () => (/* binding */ DGArc),\n/* harmony export */   \"DGCircle\": () => (/* binding */ DGCircle),\n/* harmony export */   \"DGCircleCenterPoint\": () => (/* binding */ DGCircleCenterPoint),\n/* harmony export */   \"DGClone\": () => (/* binding */ DGClone),\n/* harmony export */   \"DGConst\": () => (/* binding */ DGConst),\n/* harmony export */   \"DGConvexAngle\": () => (/* binding */ DGConvexAngle),\n/* harmony export */   \"DGConvexArc\": () => (/* binding */ DGConvexArc),\n/* harmony export */   \"DGIf\": () => (/* binding */ DGIf),\n/* harmony export */   \"DGIntersectCC\": () => (/* binding */ DGIntersectCC),\n/* harmony export */   \"DGIntersectCL\": () => (/* binding */ DGIntersectCL),\n/* harmony export */   \"DGIntersectLC\": () => (/* binding */ DGIntersectLC),\n/* harmony export */   \"DGIntersectLL\": () => (/* binding */ DGIntersectLL),\n/* harmony export */   \"DGLine\": () => (/* binding */ DGLine),\n/* harmony export */   \"DGNum\": () => (/* binding */ DGNum),\n/* harmony export */   \"DGObject\": () => (/* binding */ DGObject),\n/* harmony export */   \"DGOrientedAngle\": () => (/* binding */ DGOrientedAngle),\n/* harmony export */   \"DGPoincareDiscCircle\": () => (/* binding */ DGPoincareDiscCircle),\n/* harmony export */   \"DGPoincareDiscCircleR\": () => (/* binding */ DGPoincareDiscCircleR),\n/* harmony export */   \"DGPoincareDiscLine\": () => (/* binding */ DGPoincareDiscLine),\n/* harmony export */   \"DGPoincareHalfPlaneCircle\": () => (/* binding */ DGPoincareHalfPlaneCircle),\n/* harmony export */   \"DGPoincareHalfPlaneCircleR\": () => (/* binding */ DGPoincareHalfPlaneCircleR),\n/* harmony export */   \"DGPoincareHalfPlaneLine\": () => (/* binding */ DGPoincareHalfPlaneLine),\n/* harmony export */   \"DGPoint\": () => (/* binding */ DGPoint),\n/* harmony export */   \"DGPointFun\": () => (/* binding */ DGPointFun),\n/* harmony export */   \"DGPolygon\": () => (/* binding */ DGPolygon),\n/* harmony export */   \"DGRandomPoint\": () => (/* binding */ DGRandomPoint),\n/* harmony export */   \"DGRandomPointOnCircline\": () => (/* binding */ DGRandomPointOnCircline),\n/* harmony export */   \"DGRay\": () => (/* binding */ DGRay),\n/* harmony export */   \"DGSegment\": () => (/* binding */ DGSegment),\n/* harmony export */   \"DGText\": () => (/* binding */ DGText),\n/* harmony export */   \"DGVector\": () => (/* binding */ DGVector),\n/* harmony export */   \"DGVectorFun\": () => (/* binding */ DGVectorFun),\n/* harmony export */   \"DGVectorXY\": () => (/* binding */ DGVectorXY),\n/* harmony export */   \"NO_REDRAW\": () => (/* binding */ NO_REDRAW),\n/* harmony export */   \"REDRAW\": () => (/* binding */ REDRAW),\n/* harmony export */   \"Vector2\": () => (/* binding */ Vector2)\n/* harmony export */ });\n/* harmony import */ var _complex_geom_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../complex_geom.js */ \"./src/complex_geom.js\");\n/* harmony import */ var _colors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./colors.js */ \"./src/dg/colors.js\");\n\n\n\nconst REDRAW = true;\nconst NO_REDRAW = false;\n\n// -----------------------------------------------------------------------------\n// the base class for all geometric objects\n// -----------------------------------------------------------------------------\nclass DGObject {\n    // global number of created objects\n    static num_objects = 0;\n\n    constructor(construction) {\n        // unique object identifier\n        this._ID = DGObject.num_objects++;\n        \n        // objects dependent on the current one (the ones constructed\n        // using this object)\n        this._dependent_objects = [];\n\n        // some objects can be invalid (e.g., intersection point\n        // selected by some given criteria, when no selection point exists)\n        this._valid = true;\n\n        // style (visibility, color, width, size, dashed, ...)\n        this._style = {};\n\n        // no object is highlighted by default\n        this._style._isHighlighted = false;\n\n        // each object can be a part of one or more constructions\n        this._constructions = [];\n        if (construction)\n            this.addConstruction(construction);\n\n        this._listeners = [];\n\n        // all auxiliary objects that are created by this object's\n        // constructor should be put into this list so that they are\n        // automatically \"destructed\"\n        this._createdObjects = [];\n        // true if the object is disposed (should be considered \"dead\")\n        this._disposed = false;\n    }\n\n    // remove internally created objects (sort of like a destructor)\n    dispose(redraw) {\n        this._disposed = true;\n        this._createdObjects.forEach(o => DG.removeObject(o, redraw));\n    }\n\n    addConstruction(construction) {\n        this._constructions.push(construction);\n    }\n\n    removeConstruction(construction) {\n        this._constructions = this._constructions.filter(c => c != construction);\n    }\n\n    constructions() {\n        return this._constructions;\n    }\n\n    addListener(listener) {\n        this._listeners.push(listener);\n        return this;\n    }\n\n    type() {\n        return \"object\";\n    }\n\n    valid() {\n        return this._valid;\n    }\n\n    isFreePoint() {\n        return false;\n    }\n\n    isPoint() {\n        return false;\n    }\n\n    isLine() {\n        return false;\n    }\n\n    isCircle() {\n        return false;\n    }\n\n    // fire event that this object has changed\n    fireChangeEvent() {\n        // redraw constructions where this object occurs\n        this._constructions.forEach(construction => {\n            construction.change();\n        });\n    }\n\n    // get or set whole style subobject\n    getStyle() {\n        return this._style;\n    }\n\n    setStyle(style, redraw) {\n        this._style = style;\n        if (redraw === undefined || redraw)\n            this.fireChangeEvent();\n    }\n\n    style(style, redraw) {\n        if (style === undefined)\n            return this.getStyle();\n        this.setStyle(style, redraw);\n        return this;\n    }\n\n    getProperty(prop, defaultValue) {\n        return this._style[prop] !== undefined ? this._style[prop] : defaultValue;\n    }\n\n    setProperty(prop, value, redraw) {\n        if (this._style[prop] === value)\n            return;\n        \n        this._style[prop] = value;\n        if (redraw === undefined || redraw)\n            this.fireChangeEvent();\n    }\n\n    // set object visibility\n    setVisibility(visible, redraw) {\n        this.setProperty(\"_hide\", !visible, redraw);\n    }\n    \n    // set that this object should be visible\n    show(redraw) {\n        this.setVisibility(true, redraw);\n        return this;\n    }\n\n    // set that this object should not be visible\n    hide(redraw) {\n        this.setVisibility(false, redraw);\n        return this;\n    }\n\n    // check if the object is hidden (not visible)\n    hidden() {\n        return this.getProperty(\"_hide\");\n    }\n\n    // check if the object is visible (not hidden)\n    visible() {\n        return !this.hidden();\n    }\n\n    // get or set the color of the object\n    getColor() {\n        // return color that has been set or black otherwise\n        return this.getProperty(\"_color\", \"black\");\n    }\n\n    setColor(c, redraw) {\n        this.setProperty(\"_color\", c, redraw);\n    }\n\n    color(c, redraw) {\n        // if c is undefined get the color\n        if (c === undefined)\n            return this.getColor();\n\n        // otherwise set the color\n        this.setColor(c, redraw);        \n        return this;\n    }\n\n    // get or set the fill color of the object\n    getFillColor() {\n        // return color that has been set or undefined otherwise\n        return this.getProperty(\"_fillColor\", \"\");\n    }\n\n    setFillColor(c, redraw) {\n        this.setProperty(\"_fillColor\", c, redraw);\n    }\n\n    fillColor(c, redraw) {\n        // if c is undefined get the color\n        if (c === undefined)\n            return this.getFillColor();\n\n        // otherwise set the color\n        this.setFillColor(c, redraw);        \n        return this;\n    }\n    \n\n    // get or set opacity of the object\n    getOpacity() {\n        return (0,_colors_js__WEBPACK_IMPORTED_MODULE_1__.getOpacity)(this.color());\n    }\n\n    setOpacity(o, redraw) {\n        this.color((0,_colors_js__WEBPACK_IMPORTED_MODULE_1__.setOpacity)(this.color(), o), redraw);\n        if (this.fillColor())\n            this.fillColor((0,_colors_js__WEBPACK_IMPORTED_MODULE_1__.setOpacity)(this.fillColor(), o), redraw);\n    }\n\n    opacity(o, redraw) {\n        // o is undefined get the opacity\n        if (o === undefined)\n            return this.getOpacity();\n\n        // otherwise set the opacity\n        this.setOpacity(o, redraw);\n        return this;\n    }\n\n    // get or set the size of the object (for drawing points)\n    getSize() {\n        // return size that has been set or 1 if it is undefined\n        return this.getProperty(\"_size\", 1);\n    }\n\n    setSize(s, redraw) {\n        this.setProperty(\"_size\", s, redraw);\n    }\n    \n    size(s, redraw) {\n        // if s is undefined get the size\n        if (s === undefined)\n            return this.getSize();\n\n        // otherwise set the size\n        this.setSize(s, redraw);\n        return this;\n    }\n\n    // get or set the line width of the object\n    getWidth() {\n        // return width that has been set or 1 if it is undefined\n        return this.getProperty(\"_width\", 1);\n    }\n\n    setWidth(w, redraw) {\n        this.setProperty(\"_width\", w, redraw);\n    }\n    \n    width(w, redraw) {\n        // w is undefined get the width\n        if (w === undefined)\n            return this.getWidth();\n\n        // otherwise set the width\n        this.setWidth(w, redraw);\n        return this;\n    }\n\n\n    // set dashed pattern\n    dashed(redraw) {\n        this.setProperty(\"_dash\", [8, 4], redraw);\n        return this;\n    }\n\n    // set solid line\n    solid(redraw) {\n        this.setProperty(\"_dash\", [], redraw);\n        return this;\n    }\n\n    // get the dash pattern\n    dash() {\n        return this.getProperty(\"_dash\", []);\n    }\n\n    isDashed() {\n        return this.dash().length > 0;\n    }\n\n    // default label for the object (if label is not set)\n    defaultLabel() {\n        return this.type() + \"(\" + this._ID + \")\";\n    }\n\n    // get/set the label of the object\n    getLabel() {\n        // if the label is not set, get the default label\n        return this.getProperty(\"_label\", this.defaultLabel());\n    }\n\n    setLabel(str, redraw) {\n        this.setProperty(\"_label\", str, redraw);\n    }\n    \n    label(str, redraw) {\n        // str is undefined get the label\n        if (str === undefined)\n            return this.getLabel();\n        \n        // otherwise set the label\n        this.setLabel(str, redraw);\n        return this;\n    }\n\n\n    // get/set the label font of the object\n    getLabelFont() {\n        return this.getProperty(\"_label_font\", undefined);\n    }\n    \n    setLabelFont(font, readraw) {\n        this.setProperty(\"_label_font\", font, readraw);\n    }\n\n    labelFont(font, redraw) {\n        // font is undefined get the font\n        if (font === undefined)\n            return this.getLabelFont();\n\n        // otherwise set the font\n        this.setLabelFont(font, redraw);\n        return this;\n    }\n\n    // does this object have a non-generic label\n    hasLabel() {\n        return this.getProperty(\"_label\") !== undefined;\n    }\n\n    // set or get label visibility\n    setLabelVisibility(visible, redraw) {\n        this.setProperty(\"_label_visible\", visible, redraw);\n    }\n    \n    showLabel(redraw) {\n        this.setLabelVisibility(true, redraw);\n        return this;\n    }\n\n    hideLabel(redraw) {\n        this.setLabelVisibility(false, redraw);\n        return this;\n    }\n\n    // check if the label should be shown\n    showingLabel() {\n        return this.getProperty(\"_label_visible\", true);\n    }\n\n    // default description for the object (if description is not set)\n    defaultDescription() {\n        return \"\";\n    }\n\n    // get or set the description\n    getDescription() {\n        // if the description is not set - get the default description\n        return this.getProperty(\"_description\", this.defaultDescription());\n    }\n\n    hasDescription() {\n        return this.getProperty(\"_description\") !== undefined;\n    }\n\n    setDescription(desc, redraw) {\n        this.setProperty(\"_description\", desc, redraw);\n    }\n\n    description(desc, redraw) {\n        if (desc === undefined) {\n            // description is not given, so get the description\n            return this.getDescription();\n        } else {\n            // otherwise set the description\n            this.setDescription(desc, redraw);\n            return this;\n        }\n    }\n\n    // append string to the existing description\n    addDescription(desc, redraw) {\n        this.setDescription(this._style._description + desc, redraw);\n    }\n\n    // returns a nice description for the object that might contain a label (if its given)\n    // and description (given or default)\n    describe() {\n        let result;\n        if (this.hasLabel()) {\n            result = this.label();\n            if (this.hasDescription())\n                result += \": \" + this.description();\n            else\n                result = this.type() + \" \" + result;\n        } else {\n            if (this.description())\n                result = this.description();\n            else\n                result = this.label();\n        }\n        return result;\n    }\n\n    // get or set highlight (that shows that mouse is on the object) \n    isHighlighted() {\n        return this.getProperty(\"_isHighlighted\", false);\n    }\n\n    setHighlight(highlight, redraw) {\n        this.setProperty(\"_isHighlighted\", highlight, redraw);\n    }\n\n    highlightOn(redraw) {\n        this.setHighlight(true, redraw);\n        return this;\n    }\n\n    highlightOff(redraw) {\n        this.setHighlight(false, redraw);\n        return this;\n    }\n\n    // draw object on the given View\n    // this is a template method and the real drawing is done within\n    // the polimorphic drawMe method\n    draw(view) {\n        if (this.hidden())\n            return;\n        if (!this.valid())\n            return;\n        this.drawMe(view);\n        if (this.showingLabel())\n            this.drawLabel(view);\n    }\n\n    // this should be overridden\n    drawMe(view) {\n    }\n\n    // this should be overridden\n    drawLabel(view) {\n    }\n    \n    // Register a DGObject to depend on the current object, so that it\n    // is updated whenever the current object changes\n    addDependent(o) {\n        this._dependent_objects.push(o);\n    }\n\n    // return dependent objects that are not disposed\n    dependentNotDisposed() {\n        return this._dependent_objects.filter(obj => !obj._disposed);\n    }\n\n    // Recaculate the position of all dependent objects when this object changes\n    // this is a template method that handles the order of\n    // recalculations, while the coordinate calculations happen within\n    // the polimorphic recalceMe method\n    recalc() {\n        // a topological sort is performed to determine the optimal\n        // order of recalculation of dependent objects\n\n        // first a BFS traversal is used to calculate the number of objects that \n        // each relevant object depends on (its degree)\n        \n        let queue = {\n            elements: [],\n            start: 0,\n            init: function() {\n                this.elements = [];\n                this.start = 0;\n            },\n            push: function(x) {\n                this.elements.push(x);\n            },\n            empty: function() {\n                return this.start == this.elements.length;\n            },\n            shift() {\n                return this.elements[this.start++];\n            }\n        };\n\n        const n = DGObject.num_objects;\n        const degree = new Array(n).fill(0);\n        const objects = new Array(n).fill(null);\n        \n        function enqueue(obj) {\n            degree[obj._ID]++;\n            if (objects[obj._ID] == null) {\n                objects[obj._ID] = obj;\n                queue.push(obj);\n            }\n        }\n\n        objects[this._ID] = this;\n        this.dependentNotDisposed().forEach(enqueue);\n        while (!queue.empty()) {\n            const obj = queue.shift();\n            obj.dependentNotDisposed().forEach(enqueue);\n        }\n\n        // next the Kahn's algoritm is performed\n        queue.init();\n        queue.push(this._ID);\n        while (!queue.empty()) {\n            const id = queue.shift();\n            objects[id].recalcMe();\n            objects[id].dependentNotDisposed().forEach(obj => {\n                if (--degree[obj._ID] == 0)\n                    queue.push(obj._ID);\n            });\n        }\n    }\n\n    // this should be overridden\n    recalcMe() {\n    }\n\n    // check if this point is near the given point on the screen\n    // (world-to-screen coordinate transform is given)\n    isNear(x, y, worldToScreen) {\n        return false;\n    }\n    \n    // check if two objects are equal\n    eq(other, eps) {\n        if (this.isPoint() && other.isPoint()) {\n            return this.cp1().eq(other.cp1(), eps);\n        }\n        if (this instanceof DGCircline && other instanceof DGCircline) {\n            if (!this.valid() || !other.valid())\n                return false;\n            return this.circline().eq(other.circline(), eps)\n        }\n        return false;\n    }\n\n    // data used when this object is passed as a function argument in DGPointFun\n    funArg() {\n        return null;\n    }\n\n    // clone\n    clone() {\n        return new DGClone(this);\n    }\n\n}\n\n// -----------------------------------------------------------------------------\n// clone - shallow copy of object that can have its own style and visibility\n// -----------------------------------------------------------------------------\n\nclass DGClone extends DGObject {\n    constructor(object) {\n        super();\n        this._object = object;\n        this._style = {...this._object.style()};\n        return new Proxy(this, this);\n    }\n\n    type() {\n        return \"clone\";\n    }\n\n    valid() {\n        return this._object.valid();\n    }\n\n    drawMe(view) {\n        const old_style = this._object.style();\n        this._object.style(this._style, NO_REDRAW);\n        this._object.drawMe(view);\n        this._object.style(old_style, NO_REDRAW);\n    }\n\n    drawLabel(view) {\n        const old_style = this._object.style();\n        this._object.style(this._style, NO_REDRAW);\n        this._object.drawLabel(view);\n        this._object.style(old_style, NO_REDRAW);\n    }\n\n    isPoint() {\n        return this._object.isPoint();\n    }\n\n    isFreePoint() {\n        return this._object.isFreePoint();\n    }\n\n    isLine() {\n        return this._object.isLine();\n    }\n\n    isCircle() {\n        return this._object.isCircle();\n    }\n    \n    get(target, prop, receiver) {\n        if (prop in this)\n            return this[prop];\n        else {\n            if (typeof this._object[prop] == \"function\")\n                return this._object[prop].bind(this._object);\n            else\n                return this._object[prop];\n        }\n    }\n}\n\n// \"free\" numeric constant whose value can be changed that can be used in numeric expressions\nclass DGConst extends DGObject {\n    constructor(value) {\n        super();\n        this.setValue(value);\n    }\n\n    value() {\n        return this._value;\n    }\n\n    funArg() {\n        return this.value();\n    }\n\n    setValue(value, redraw) {\n        this._value = value;\n        // update all dependent objects\n        this.recalc();\n        \n        if (redraw == undefined || redraw)\n            this.fireChangeEvent();\n    }\n}\n\n// numeric expression that can depend on numeric constants, points (i.e., their coordinates) etc.\nclass DGNum extends DGObject {\n    constructor(fun, dependencies) {\n        super();\n        this._fun = fun;\n        this._dependencies = dependencies;\n        \n        dependencies.forEach(obj => {\n            obj.addDependent(this);\n        });\n        this.recalcMe();\n        this.hide(false);\n    }\n\n    value() {\n        return this._value;\n    }\n    \n    funArg() {\n        return this.value();\n    }\n    \n    recalcMe() {\n        this._valid = this._dependencies.every(obj => obj.valid());\n        if (!this._valid)\n            return;\n        const args = this._dependencies.map(obj => obj.funArg());\n        this._value = this._fun(...args);\n        this._valid = isFinite(this._value);\n\n        this._listeners.forEach(listener => {\n            if (typeof listener == \"function\")\n                listener(this);\n            else\n                listener.changed(this);\n        });\n    }\n}\n\n\n// -----------------------------------------------------------------------------\n// Text\n// -----------------------------------------------------------------------------\nclass DGText extends DGObject {\n    constructor(text, x, y) {\n        super();\n        this._text = text;\n        this._coords = [x, y];\n    }\n\n    x() {\n        return this._coords[0];\n    }\n\n    y() {\n        return this._coords[1];\n    }\n\n    setText(text, redraw) {\n        this._text = text;\n        if (redraw == undefined || redraw)\n            this.fireChangeEvent();\n    }\n\n    moveTo(x, y, redraw) {\n        this._coords = [x, y];\n        this._listeners.forEach(listener => {\n            if (typeof listener == \"function\")\n                listener(this);\n            else\n                listener.moved(this);\n        });\n\n        if (redraw == undefined || redraw)\n            this.fireChangeEvent();\n\n        // the point was successfully moved\n        return true;\n    }\n    \n    // drawing the point on the given View\n    drawMe(view) {\n        view.text(this.x(), this.y(), this._text, this._style._label_font, this._style._label_color);\n    }\n}\n\n// -----------------------------------------------------------------------------\n// free point\n// -----------------------------------------------------------------------------\n// the point is internally represented by a CP1 object\nclass DGPoint extends DGObject {\n    constructor(x, y, validity_check) {\n        super();\n        \n        this._validity_check = validity_check;\n        this._coords = _complex_geom_js__WEBPACK_IMPORTED_MODULE_0__.CP1.of_xy(x, y);\n        this._valid = !this._validity_check || this._validity_check(this.cp1());\n\n        return this;\n    }\n\n    type() {\n        return \"point\";\n    }\n\n    // fix the point so that it cannot be moved\n    fix() {\n        this._fixed = true;\n        return this;\n    }\n\n    // free the point so that it can be moved\n    unfix() {\n        this._fixed = false;\n        return this;\n    }\n\n    // this is the only class that defines free points (points that\n    // can be moved by using the mouse, unless they are fixed)\n    isFreePoint() {\n        if (this._fixed)\n            return false;\n        return true;\n    }\n\n    // this object is a point\n    isPoint() {\n        return true;\n    }\n\n    // user can constrain this point to satisfy some criteria defined\n    // by the function fun cp1 -> bool\n    validityCheck(fun) {\n        this._validity_check = fun;\n        return this;\n    }\n\n    // trying to move the point to the given position\n    // moving is not allowed if the target position does not satisfy\n    // the validity check\n    moveTo(x, y, redraw) {\n        const cp1 = _complex_geom_js__WEBPACK_IMPORTED_MODULE_0__.CP1.of_xy(x, y);\n        if (!this._validity_check || this._validity_check(cp1)) {\n            // update the internal CP1 object\n            this._coords = cp1;\n            this._valid = true; \n            // update all dependent objects\n            this.recalc();\n\n            this._listeners.forEach(listener => {\n                if (typeof listener == \"function\")\n                    listener(this);\n                else\n                    listener.moved(this);\n            });\n\n            if (redraw == undefined || redraw)\n                this.fireChangeEvent();\n\n            // the point was successfully moved\n            return true;\n        }\n        // the point could not be moved\n        return false;\n    }\n\n    // theoretically, the point can be infinite\n    isInf() {\n        return this._coords.is_inf();\n    }\n\n    // conversion to complex number (unless infinite)\n    toComplex() {\n        return this._coords.to_complex();\n    }\n\n    // x coordinate (unless infinite)\n    x() {\n        const c = this.toComplex();\n        return c.re();\n    }\n\n    // y coordinate (unless infinite)\n    y() {\n        const c = this.toComplex();\n        return c.im();\n    }\n    \n    // both coordinates (unless infinite)\n    coords() {\n        return this.toComplex().coords();\n    }\n\n    // internal cp1 representation\n    cp1() {\n        return this._coords;\n    }\n\n    funArg() {\n        return this.cp1();\n    }\n\n    // check equality of two points (other can represented by a complex number of cp1)\n    eq(other, eps) {\n        if (other instanceof _complex_geom_js__WEBPACK_IMPORTED_MODULE_0__.CP1)\n            return this.cp1().eq(other, eps);\n        if (other instanceof _complex_geom_js__WEBPACK_IMPORTED_MODULE_0__.Complex)\n            return !this.isInf() && this.toComplex().eq(other, eps);\n        if (other.isPoint()) {\n            if (!this.valid() || !other.valid())\n                return false;\n            return this.cp1().eq(other.cp1(), eps);\n        }\n        return false;\n    }\n\n    // distance to the other point (unless one of them is infinite)\n    distance(other) {\n        return this.toComplex().sub(other.toComplex()).norm();\n    }\n\n    // check if this point is near the given point on the screen\n    // (world-to-screen coordinate transform is given)\n    isNear(x, y, worldToScreen) {\n        if (!this.valid())\n            return false;\n        const [xt, yt] = worldToScreen ? worldToScreen(this.x(), this.y()) : [x, y];\n        const dist2 = (xt - x)*(xt - x) + (yt - y)*(yt - y);\n        let EPS = 5;\n        EPS *= this.size();\n        return dist2 <= EPS * EPS;\n    }\n\n    // drawing the point on the given View\n    drawMe(view) {\n        if (!this.isInf()) {\n            if (this.isHighlighted()) {\n                view.point(this.x(), this.y(), {color: (0,_colors_js__WEBPACK_IMPORTED_MODULE_1__.setOpacity)(this.color(), 0.5*this.opacity()), size: 1.5*this.size()});\n            }\n            view.point(this.x(), this.y(), {color: this.color(), size: this.size()});\n        }\n    }\n\n    // drawing the point label on the given View \n    drawLabel(view) {\n        if (!this.isInf() && this._style._label)\n            view.text(this.x(), this.y(), this._style._label, this._style._label_font, this._style._label_color, this.size());\n    }\n\n    translate(vector) {\n        return DG.pointFun((p, v) => [p.x() + v.x(), p.y() + v.y()], [this, vector]);\n    }\n\n    rot(O, alpha, redraw) {\n        return DG.pointFun((p, o) => {\n            // Calculate the cosine and sine of the angle\n            const cosAlpha = Math.cos(alpha);\n            const sinAlpha = Math.sin(alpha);\n\n            // Translate the point to the origin (subtract the rotation center coordinates)\n            const translatedX = p.x() - o.x();\n            const translatedY = p.y() - o.y();\n\n            // Apply the rotation transformation\n            const rotatedX = translatedX * cosAlpha - translatedY * sinAlpha;\n            const rotatedY = translatedX * sinAlpha + translatedY * cosAlpha;\n\n            // Translate the point back to its original position (add the rotation center coordinates)\n            const finalX = rotatedX + o.x();\n            const finalY = rotatedY + o.y();\n\n            // Return the rotated coordinates\n            return [finalX, finalY];\n        }, [this, O], redraw);\n    }\n\n    // projection of this point to the given line\n    projectOn(l, redraw) {\n        const A = l.point1();\n        const B = l.point2();\n        const ab = DG.vector(A, B, NO_REDRAW).hide(NO_REDRAW);\n        const v = DG.vector(A, this, NO_REDRAW).hide(NO_REDRAW); \n        const P = DG.pointFun((O, v1, v2) => {\n            const proj = v1.projectOn(v2);\n            return [O.x() + proj.x(), O.y() + proj.y()];\n        }, [A, v, ab], redraw);\n        return P;\n    }\n}\n\n\n// -----------------------------------------------------------------------------\n// functionally dependent point\n// -----------------------------------------------------------------------------\n\nclass DGPointFun extends DGPoint {\n    constructor(fun, dependencies) {\n        super();\n        this._fun = fun;\n        this._dependencies = dependencies;\n        dependencies.forEach(obj => {\n            obj.addDependent(this);\n        });\n        this.recalcMe();\n    }\n\n    // point is not free\n    isFreePoint() {\n        return false;\n    }\n    \n    recalcMe() {\n        this._valid = this._dependencies.every(obj => obj.valid());\n        if (!this._valid)\n            return;\n        \n        const args = this._dependencies.map(obj => obj.funArg());\n        const c = this._fun(...args);\n        if (c instanceof _complex_geom_js__WEBPACK_IMPORTED_MODULE_0__.CP1)\n            this._coords = c;\n        else if (Array.isArray(c))\n            this._coords = new _complex_geom_js__WEBPACK_IMPORTED_MODULE_0__.CP1(new _complex_geom_js__WEBPACK_IMPORTED_MODULE_0__.Complex(c[0], c[1]));\n        else\n            this._coords = new _complex_geom_js__WEBPACK_IMPORTED_MODULE_0__.CP1(c);\n    }\n}\n\n\n\n// -----------------------------------------------------------------------------\n// random point\n// -----------------------------------------------------------------------------\nclass DGRandomPoint extends DGPoint {\n    constructor(validity_check, xmin, xmax, ymin, ymax) {\n        super();\n        \n        xmin = (xmin === undefined) ? -1 : xmin;\n        xmax = (xmax === undefined) ? 1 : xmax;\n        ymin = (ymin === undefined) ? -1 : ymin;\n        ymax = (ymax === undefined) ? 1 : ymax;\n        this._xmin = xmin; this._xmax = xmax;\n        this._ymin = ymin; this._ymax = ymax;\n        this._validity_check = validity_check ? validity_check : (p => true);\n        this.recalcMe();\n    }\n\n    type() {\n        return \"random point\";\n    }\n    \n    // random point is not free\n    isFreePoint() {\n        return false;\n    }\n\n    recalcMe() {\n        const MAX_ITER = 100;\n        let x, y;\n        let i = 0;\n        do {\n            x = this._xmin + Math.random() * (this._xmax - this._xmin);\n            y = this._ymin + Math.random() * (this._ymax - this._ymin);\n            this._coords = new _complex_geom_js__WEBPACK_IMPORTED_MODULE_0__.CP1(new _complex_geom_js__WEBPACK_IMPORTED_MODULE_0__.Complex(x, y));\n            i++;\n        } while (!this._validity_check(this._coords) && i < MAX_ITER);\n        if (i == MAX_ITER) {\n            this._valid = false;\n        } else\n            this._valid = true;\n    }\n}\n\n\nclass Vector2 {\n    constructor(x, y) {\n        this._x = x;\n        this._y = y;\n    }\n\n    static ofPoint(p) {\n        return new Vector2(p.x(), p.y());\n    }\n\n    static ofPoints(p1, p2) {\n        return new Vector2(p2.x() - p1.x(), p2.y() - p1.y());\n    }\n\n    x() {\n        return this._x;\n    }\n\n    y() {\n        return this._y;\n    }\n\n    opposite() {\n        return new Vector2(-this.x(), -this.y());\n    }\n    \n    add(v) {\n        return new Vector2(this.x() + v.x(), this.y() + v.y());\n    }\n\n    subtract(v) {\n        return this.add(v.opposite());\n    }\n\n    scale(c) {\n        return new Vector2(this.x() * c, this.y() * c);\n    }\n\n    scalProd(v) {\n        return this.x()*v.x() + this.y()*v.y();\n    }\n\n    norm() {\n        return Math.sqrt(this.scalProd(this));\n    }\n\n\n    vecProd(v) {\n        return this.x()*v.y() - this.y()*v.x();\n    }\n\n    projectOn(v) {\n        const dp = this.scalProd(v);\n        const vNormSq = v.scalProd(v);\n        if (vNormSq == 0)\n            return new Vector2(0, 0);\n        return new Vector2(v.x() * (dp / vNormSq), v.y() * (dp / vNormSq));\n        \n    }\n}\n\n// vector between two given points\nclass DGVector extends DGObject {\n    constructor(startPoint, endPoint) {\n        super();\n        this._start = startPoint;\n        this._end = endPoint;\n        this._start.addDependent(this);\n        this._end.addDependent(this);\n    }\n\n    startPoint() {\n        return this._start;\n    }\n\n    endPoint() {\n        return this._end;\n    }\n    \n    vector() {\n        return new Vector2(this._end.x() - this._start.x(),\n                           this._end.y() - this._start.y());\n    }\n\n    x() {\n        return this._end.x() - this._start.x();\n    }\n\n    y() {\n        return this._end.y() - this._start.y();\n    }\n\n    valid() {\n        return this._start.valid() && this._end.valid();\n    }\n\n    norm() {\n        return Math.sqrt(this.x() * this.x() + this.y() * this.y());\n    }\n\n    unit(redraw) {\n        return DG.vectorFun(this.startPoint(), (s, e, v) => {\n            const norm = v.norm();\n            if (norm == 0)\n                return [0, 0];\n            return [(e.x() - s.x()) / norm,\n                    (e.y() - s.y()) / norm];\n        }, [this.startPoint(), this.endPoint(), this], redraw);\n    }\n\n    scale(k, redraw) {\n        if (k instanceof DGNum)\n            return DG.vectorFun(this.startPoint(),\n                                (k, s, e, v) => [k*(e.x() - s.x()), k*(e.y() - s.y())],\n                                [k, this.startPoint(), this.endPoint(), this], redraw);\n        else\n            return DG.vectorFun(this.startPoint(),\n                                (s, e, v) => [k*(e.x() - s.x()), k*(e.y() - s.y())],\n                                [this.startPoint(), this.endPoint(), this], redraw);\n    }\n\n    scalProd(v) {\n        return DG.num((v1, v2) => v1.scalProd(v2), [this, v]);\n    }\n\n    vecProd(v) {\n        return DG.num((v1, v2) => v1.vecProd(v2), [this, v]);\n    }\n\n    drawMe(view) {\n        view.vector(this._start.x(), this._start.y(),\n                    this._end.x(), this._end.y(),\n                    {color: this.color(), size: this.size(), width: this.width()});\n    }\n\n    funArg() {\n        return this.vector();\n    }\n}\n\n// vector of fixed length and movable starting point\nclass DGVectorXY extends DGVector {\n    constructor(startPoint, x, y) {\n        const endPoint = DG.pointFun(p => [p.x() + x, p.y() + y], [startPoint]).hide();\n        super(startPoint, endPoint);\n        this._createdObjects.push(endPoint);\n    }\n}\n\n\nclass DGVectorFun extends DGVector {\n    constructor(startPoint, fun, dependencies) {\n        const endPoint = DG.pointFun(() => {\n            const args = dependencies.map(obj => obj.funArg());\n            const c = fun(...args);\n            if (c instanceof Vector2)\n                return [startPoint.x() + c.x(), startPoint.y() + c.y()];\n            else if (Array.isArray(c))\n                return [startPoint.x() + c[0], startPoint.y() + c[1]];\n            else {\n                const v = new Vector2(c);\n                return [startPoint.x() + v.x(), startPoint.y() + v.y()];\n            }\n        }, dependencies, NO_REDRAW).hide(NO_REDRAW);\n        super(startPoint, endPoint);\n        \n        dependencies.forEach(obj => {\n            obj.addDependent(this);\n        });\n        this.recalcMe();\n        this._createdObjects.push(endPoint);\n    }\n}\n\n// -----------------------------------------------------------------------------\n// joint class for circles and lines\n// -----------------------------------------------------------------------------\n\nclass DGCircline extends DGObject {\n    constructor() {\n        super();\n    }\n\n    type() {\n        return \"circline\";\n    }\n\n    drawMe(view) {\n        function doDraw(cl, style) {\n            if (cl._circline.is_line()) {\n                const [p1, p2] = cl._circline.line_points();\n                const [x1, y1] = p1.coords();\n                const [x2, y2] = p2.coords();\n                view.line(x1, y1, x2, y2, style);\n            } else {\n                const c = cl._circline.circle_center();\n                const r = cl._circline.circle_radius();\n                const [x, y] = c.coords();\n                view.circle(x, y, r, style);\n            }\n        }\n        \n        const style = {\n            color: this.color(),\n            width: this.width(),\n            dash: this.dash()\n        };\n        doDraw(this, style);\n        \n        if (this.isHighlighted()) {\n            const style = {\n                color: (0,_colors_js__WEBPACK_IMPORTED_MODULE_1__.setOpacity)(this.color(), 0.5*(0,_colors_js__WEBPACK_IMPORTED_MODULE_1__.getOpacity)(this.color())),\n                width: 3*this.width(),\n                dash: this.dash()\n            };\n            doDraw(this, style);\n        }\n    }\n\n    // drawing the line label on the given View \n    drawLabel(view) {\n        if (this._circline.is_line() && this._style._label) {\n            const [p1, p2] = this._circline.line_points();\n            const [x1, y1] = p1.coords();\n            const [x2, y2] = p2.coords();\n            view.line_label(x1, y1, x2, y2, this.label(), this.color());\n        }\n    }\n\n    // check if this line is near the given point on the screen\n    // (world-to-screen coordinate transform is given)\n    isNear(x, y, worldToScreen) {\n        if (!this.valid())\n            return false;\n        if (!worldToScreen)\n            worldToScreen = (x, y) => [x, y];\n        return this._circline.transform(worldToScreen).on_circline(_complex_geom_js__WEBPACK_IMPORTED_MODULE_0__.CP1.of_xy(x, y));\n    }\n    \n    // return internal representation (FIXME: this should be private)\n    circline() {\n        return this._circline;\n    }\n\n    // check if the given cp1 point is on this circline\n    onCircline(p, eps) {\n        return this._circline.on_circline(p, eps);\n    }\n\n    onCirclineXY(x, y, eps) {\n        return this.onCircline(_complex_geom_js__WEBPACK_IMPORTED_MODULE_0__.CP1.of_xy(x, y), eps);\n    }\n\n    // return the center of the circline\n    center() {\n        return new DGCircleCenterPoint(this);\n    }\n\n    funArg() {\n        return this.circline();\n    }\n\n    // find intersection of two circlines in cp1 (fictive intersections can be included)\n    static intersect(cl1, cl2, includeFictive) {\n        return cl1.circline().intersect(cl2.circline(), includeFictive);\n    }\n    \n    // find intersection of two lines (infinite point if the lines are parallel)\n    static intersectLL(l1, l2) {\n        const p = DGCircline.intersect(l1, l2, false);\n        if (p.length == 0)\n            return _complex_geom_js__WEBPACK_IMPORTED_MODULE_0__.CP1.inf;\n        if (!p[0].is_inf())\n            return p[0];\n        if (!p[1].is_inf())\n            return p[1];\n        // both points are infinite (lines are parallel)\n        return _complex_geom_js__WEBPACK_IMPORTED_MODULE_0__.CP1.inf;\n    }\n}\n\n// -----------------------------------------------------------------------------\n// straight line between two given points\n// -----------------------------------------------------------------------------\n// internally the line is represented by a CP1 circline (a Hermitean matrix)\nclass DGLine extends DGCircline {\n    // construct a line given the two points\n    constructor(p1, p2) {\n        super();\n        \n        this._p1 = p1;\n        this._p2 = p2;\n        // if any of the two points move, this line must be updated\n        p1.addDependent(this);\n        p2.addDependent(this);\n        // initialize the internal circline representation (Hermitean matrix)\n        this.recalcMe();\n    }\n\n    point1() {\n        return this._p1;\n    }\n\n    point2() {\n        return this._p2;\n    }\n    \n    type() {\n        return \"line\";\n    }\n\n    defaultDescription() {\n        return \"line \" + this._p1.label() + this._p2.label();\n    }\n\n    // recalculate the coordinates\n    recalcMe() {\n        this._valid = this._p1.valid() && this._p2.valid();\n        if (!this._valid)\n            return;\n        this._circline = _complex_geom_js__WEBPACK_IMPORTED_MODULE_0__.Circline.mk_circline3(this._p1.cp1(), this._p2.cp1(), _complex_geom_js__WEBPACK_IMPORTED_MODULE_0__.CP1.inf);\n    }\n\n    isLine() {\n        return true;\n    }\n\n    // check if the given CP1 object lies on the current line\n    onLine(p, eps) {\n        return this.onCircline(p, eps);\n    }\n\n    // check if the point (x, y) lies on the current line\n    onLineXY(x, y, eps) {\n        return this.onLine(_complex_geom_js__WEBPACK_IMPORTED_MODULE_0__.CP1.of_xy(x, y), eps);\n    }\n}\n\n// -----------------------------------------------------------------------------\n// straight half-line between two given points\n// -----------------------------------------------------------------------------\n// internally the line is represented by a CP1 circline (a Hermitean matrix)\nclass DGRay extends DGLine {\n    constructor(O, A) {\n        super(O, A);\n    }\n    type() {\n        return \"line\";\n    }\n\n    defaultDescription() {\n        return \"half-line \" + this._p1.label() + this._p2.label();\n    }\n\n    isLine() {\n        return true;\n    }\n\n    // check if the given CP1 object lies on the current line\n    onLine(p, eps) {\n        return _complex_geom_js__WEBPACK_IMPORTED_MODULE_0__.Circline.same_side(p, this._p2, this._p1, eps);\n    }\n    \n    // check if the point (x, y) lies on the current line\n    onLineXY(x, y, eps) {\n        return this.onLine(_complex_geom_js__WEBPACK_IMPORTED_MODULE_0__.CP1.of_xy(x, y), eps);\n    }\n\n    drawMe(view) {\n        const [x1, y1] = this._p1.coords();\n        const [x2, y2] = this._p2.coords();\n        view.ray(x1, y1, x2, y2, {color: this._style._color, width: this._style._width, dash: this._style._dash});\n    }\n}\n\n// -----------------------------------------------------------------------------\n// a line segment\n// -----------------------------------------------------------------------------\nclass DGSegment extends DGLine {\n    constructor(p1, p2) {\n        super(p1, p2);\n        // should the first point be included in the segment\n        this._include1 = false;\n        // should the second point be included in the segment\n        this._include2 = false;\n    }\n\n    include1(include) {\n        this._include1 = include;\n    }\n\n    include2(include) {\n        this._include2 = include;\n    }\n    \n    type() {\n        return \"segment\";\n    }\n\n    defaultDescription() {\n        return \"segment \" + this._p1.label() + this._p2.label();\n    }\n\n    drawMe(view) {\n        const [x1, y1] = this._p1.coords();\n        const [x2, y2] = this._p2.coords();\n        view.segment(x1, y1, x2, y2, {color: this._style._color, width: this._style._width, dash: this._style._dash});\n    }\n\n    // drawing the segment label on the given View \n    drawLabel(view) {\n        // TODO\n    }\n\n    // check if the given CP1 object lies on the current segment\n    onLine(p, eps) {\n        return _complex_geom_js__WEBPACK_IMPORTED_MODULE_0__.Circline.between(this._p2, p, this._p1, eps) ||\n               (this._include1 && this._p1.eq(p, eps)) ||\n               (this._include2 && this._p2.eq(p, eps));\n    }\n    \n    // check if the point (x, y) lies on the current line\n    onLineXY(x, y, eps) {\n        return this.onLine(_complex_geom_js__WEBPACK_IMPORTED_MODULE_0__.CP1.of_xy(x, y), eps);\n    }\n    \n    // FIXME: isNear\n}\n\n// -----------------------------------------------------------------------------\n// a random point on a  circline\n// -----------------------------------------------------------------------------\nclass DGRandomPointOnCircline extends DGPoint {\n    constructor(l, params) {\n        super();\n        if (params === undefined)\n            params = {};\n        \n        this._line = l;\n        this._validity_check = params.validity_check ? params.validity_check : p => true;\n        this._disc = params.disc;\n        // if the line moves, this point must be updated\n        l.addDependent(this);\n        // initialize (randomly) the point coordinates\n        this.recalcMe();\n        // fix the point so that it cannot be moved\n        this.fix();\n    }\n\n    type() {\n        return \"point on circline\";\n    }\n\n    // point on circline is not free\n    isFreePoint() {\n        return false;\n    }\n\n    // recalculate the coordinates\n    recalcMe() {\n        this._valid = this._line.valid();\n        if (!this._valid)\n            return;\n        const MAX_ITER = 100;\n        let iter = 0;\n        do {\n            if (this._disc)\n                this._coords = this._line.circline().random_point_in_disc(this._disc);\n            else\n                this._coords = this._line.circline().random_point();\n            iter++;\n        } while ((this._coords === null || !this._validity_check(this._coords)) && iter < MAX_ITER);\n        if (!this._coords || iter == MAX_ITER) {\n            this._valid = false;\n        }\n    }\n}\n\n// -----------------------------------------------------------------------------\n// a circle with a given center and point\n// -----------------------------------------------------------------------------\n// internally the line is represented by a CP1 circline (a Hermitean matrix)\nclass DGCircle extends DGCircline {\n    constructor(c, p) {\n        super();\n        \n        this._c = c;\n        this._p = p;\n        // if any of the two points move, this line must be updated\n        c.addDependent(this);\n        p.addDependent(this);\n        // initialize the internal circline representation (Hermitean matrix)\n        this.recalcMe();\n    }\n\n    type() {\n        return \"circle\";\n    }\n\n    defaultDescription() {\n        return \"circle c(\" + this._c.label() + \", \" + this._p.label() + \")\";\n    }\n\n    // this is a circle\n    isCircle() {\n        return true;\n    }\n\n    // recalculate the coordinates\n    recalcMe() {\n        this._valid = this._c.valid() && this._p.valid();\n        if (!this._valid)\n            return;\n        this._r = this._c.distance(this._p);\n        this._circline = _complex_geom_js__WEBPACK_IMPORTED_MODULE_0__.Circline.mk_circle(this._c.toComplex(), this._r);\n    }\n\n    // check if the given CP1 object lies in the current circle disc (boundary excluded)\n    inDisc(p) {\n        return this._circline.in_disc(p);\n    }\n\n    // check if the point (x, y) lies in the current circle disc (boundary excluded)\n    inDiscXY(x, y) {\n        return this.inDisc(_complex_geom_js__WEBPACK_IMPORTED_MODULE_0__.CP1.of_xy(x, y));\n    }\n\n    // check if the given CP1 object lies on the current circle\n    onCircle(p, eps) {\n        return this.onCircline(p, eps);\n    }\n\n    // check if the point (x, y) lies on the current circle\n    onCircleXY(x, y, eps) {\n        return this.onCircle(_complex_geom_js__WEBPACK_IMPORTED_MODULE_0__.CP1.of_xy(x, y), eps);\n    }\n}\n\n// -----------------------------------------------------------------------------\n// Circular arc\n// -----------------------------------------------------------------------------\n\nclass DGArc extends DGCircline {\n    constructor(p1, p, p2) {\n        super();\n        this._p1 = p1;\n        this._p = p;\n        this._p2 = p2;\n        p1.addDependent(this);\n        p.addDependent(this);\n        p2.addDependent(this);\n        this.recalcMe();\n    }\n\n    type() {\n        return \"arc\";\n    }\n    \n    recalcMe() {\n        this._valid = this._p1.valid() && this._p.valid() && this._p2.valid() &&\n                      !this._p1.eq(this._p) && !this._p2.eq(this._p) && !this._p1.eq(this._p2);\n        if (!this._valid)\n            return;\n        this._circline = _complex_geom_js__WEBPACK_IMPORTED_MODULE_0__.Circline.mk_circline3(this._p1, this._p, this._p2);\n    }\n\n    drawMe(view) {\n        function canonAngle(alpha) {\n            const k = Math.floor((alpha + Math.PI) / (2 * Math.PI));\n            let res = alpha - 2*k*Math.PI;\n            if (res < 0)\n                res += 2*Math.PI;\n            return res;\n        }\n        \n        function doDraw(cl, style) {\n            if (cl._circline.is_line()) {\n                const [x1, y1] = cl._p1.coords();\n                const [x, y] = cl._p.coords();\n                const [x2, y2] = cl._p2.coords();\n                if (_complex_geom_js__WEBPACK_IMPORTED_MODULE_0__.Circline.between(cl._p1, cl._p, cl._p2))\n                    view.segment(x1, y1, x2, y2, style);\n                else\n                    view.segment_complement(x1, y1, x2, y2, style);\n            } else {\n                const c = cl._circline.circle_center();\n                const r = cl._circline.circle_radius();\n                const a1 = -cl._p1.cp1().to_complex().sub(c).arg();\n                const a = -cl._p.cp1().to_complex().sub(c).arg();\n                const a2 = -cl._p2.cp1().to_complex().sub(c).arg();\n                const [x, y] = c.coords();\n                view.arc(x, y, r, a1, a2, canonAngle(a2 - a1) < canonAngle(a - a1), style);\n            }\n        }\n        doDraw(this, {color: this.color(), width: this.width(), dash: this.dash(), fillColor: this.fillColor()});\n    }\n}\n\n\n// -----------------------------------------------------------------------------\n// convex arc given its center and two points (center O should lie on the\n// bisector of AB)\n// -----------------------------------------------------------------------------\nclass DGConvexArc extends DGArc {\n    constructor(O, A, B, convex) {\n        if (convex === undefined) convex = true;\n        const createdObjects = [];\n        const M = DG.midpoint(A, B, DG.NO_REDRAW).hide(DG.NO_REDRAW);\n        createdObjects.push(M);\n        const c = DG.circle(O, A, DG.NO_REDRAW).hide(DG.NO_REDRAW);\n        createdObjects.push(c);\n        const l = DG.line(O, M, DG.NO_REDRAW).hide(DG.NO_REDRAW);\n        createdObjects.push(l);\n        const X = DG.intersectLC_select(l, circ, x => DG.between(O, M, x) == convex, DG.NO_REDRAW).hide(DG.NO_REDRAW);\n        createdObjects.push(X);\n        super(A, X, B);\n        this._createdObjects = createdObjects;              \n    }\n}\n\n\n// -----------------------------------------------------------------------------\n// oriented angle (in positive direction, from OA towards OB\n// -----------------------------------------------------------------------------\n\nclass DGOrientedAngle extends DGArc {\n    constructor(A, O, B, r) {\n        const createdObjects = [];\n        const OA = DG.vector(O, A, NO_REDRAW).hide(NO_REDRAW);\n        createdObjects.push(OA);\n        const Ap1 = OA.unit(NO_REDRAW).hide(NO_REDRAW);\n        createdObjects.push(Ap1);\n        const Ap1s = Ap1.scale(r, NO_REDRAW).hide(NO_REDRAW);\n        createdObjects.push(Ap1s);\n        const Ap = Ap1s.endPoint();\n        \n        const OB = DG.vector(O, B, NO_REDRAW).hide(NO_REDRAW);\n        createdObjects.push(OB);\n        const Bp1 = OB.unit(NO_REDRAW).hide(NO_REDRAW);\n        createdObjects.push(Bp1);\n        const Bp1s = Bp1.scale(r, NO_REDRAW).hide(NO_REDRAW);\n        createdObjects.push(Bp1s);\n        const Bp = Bp1s.endPoint();\n        \n        const OC = DG.vectorFun(O, (v1, v2) => v1.add(v2), [OA, OB], NO_REDRAW).hide(NO_REDRAW);\n        createdObjects.push(OC);\n        const mOC = OC.scale(-1, NO_REDRAW).hide(NO_REDRAW);\n        createdObjects.push(mOC);\n\n        const pCp1 = OC.unit(NO_REDRAW).hide(NO_REDRAW);\n        createdObjects.push(pCp1);\n        const pCp1s = pCp1.scale(r, NO_REDRAW).hide(NO_REDRAW);\n        createdObjects.push(pCp1s);\n        const pCp = pCp1s.endPoint();\n        createdObjects.push(pCp);\n\n        const mCp1 = mOC.unit(NO_REDRAW).hide(NO_REDRAW);\n        createdObjects.push(mCp1);\n        const mCp1s = mCp1.scale(r, NO_REDRAW).hide(NO_REDRAW);\n        createdObjects.push(mCp1s);\n        const mCp = mCp1s.endPoint();\n        createdObjects.push(mCp);\n        \n        const Ar = A.rot(O, Math.PI/2, NO_REDRAW).hide(NO_REDRAW);\n        createdObjects.push(Ar);\n        const OAr = DG.vector(O, Ar, NO_REDRAW).hide(NO_REDRAW);\n        createdObjects.push(OAr);\n        const rCp1 = OAr.unit(NO_REDRAW).hide(NO_REDRAW);\n        createdObjects.push(rCp1);\n        const rCp1s = rCp1.scale(r, NO_REDRAW).hide(NO_REDRAW);\n        createdObjects.push(rCp1s);\n        const rCp = rCp1s.endPoint();\n        createdObjects.push(rCp);\n\n        const vp = DG.num((oa, ob) => oa.vecProd(ob), [OA, OB], NO_REDRAW);\n        createdObjects.push(vp);\n        const sp = DG.num((oa, ob) => oa.scalProd(ob), [OA, OB], NO_REDRAW);\n        createdObjects.push(sp);\n        \n        const Cp = DG.pointFun((vp, sp, pcp, mcp, rcp) => {\n            if (Math.abs(vp) / (OA.norm() * OB.norm()) < 0.5 && sp < 0) {\n                return rcp;\n            } else if (vp > 0) {\n                return pcp;\n            } else {\n                return mcp;\n            }\n        }, [vp, sp, pCp, mCp, rCp], NO_REDRAW).hide(NO_REDRAW);\n        createdObjects.push(Cp);\n\n        super(Ap, Cp, Bp);\n        this._createdObjects = createdObjects;\n    }\n}\n\n// -----------------------------------------------------------------------------\n// convex angle between OA and OB\n// -----------------------------------------------------------------------------\n\nclass DGConvexAngle extends DGArc {\n    constructor(A, O, B, r) {\n        const OA = DG.vector(O, A, NO_REDRAW).hide(NO_REDRAW);\n        const OB = DG.vector(O, B, NO_REDRAW).hide(NO_REDRAW);\n        const Ap = OA.unit(NO_REDRAW).hide(NO_REDRAW).scale(r).hide(NO_REDRAW).endPoint();\n        const Bp = OB.unit(NO_REDRAW).hide(NO_REDRAW).scale(r).hide(NO_REDRAW).endPoint();\n        \n        const OC = DG.vectorFun(O, (v1, v2) => v1.add(v2), [OA, OB], NO_REDRAW).hide(NO_REDRAW);\n        const Cp = OC.unit(NO_REDRAW).hide(NO_REDRAW).scale(r, NO_REDRAW).hide(NO_REDRAW).endPoint();\n\n        const vp = DG.num((oa, ob) => oa.vecProd(ob), [OA, OB], NO_REDRAW);\n        const sp = DG.num((oa, ob) => oa.scalProd(ob), [OA, OB], NO_REDRAW);\n\n        super(Ap, Cp, Bp)\n    }\n}\n\n\n// -----------------------------------------------------------------------------\n// center of the given circle\n// -----------------------------------------------------------------------------\nclass DGCircleCenterPoint extends DGPoint {\n    constructor(c) {\n        super();\n        \n        this._circle = c;\n        // if the circle moves, this point must be updated\n        c.addDependent(this);\n        // initialize center coordinates\n        this.recalcMe();\n    }\n\n    type() {\n        return \"circle center\";\n    }\n\n    // circle center point is not free\n    isFreePoint() {\n        return false;\n    }\n\n    defaultDescription() {\n        return \"center of \" + this._circle.label();\n    }\n\n    // recalculate the coordinates\n    recalcMe() {\n        this._valid = this._circle.valid();\n        if (!this._valid)\n            return;\n        this._coords = this._circle.circline().center();\n    }\n}\n\n// -----------------------------------------------------------------------------\n// intersection of two lines\n// -----------------------------------------------------------------------------\n// a finte CP1 point, unless lines are parallel\nclass DGIntersectLL extends DGPoint {\n    constructor(l1, l2) {\n        super();\n        this._l1 = l1;\n        this._l2 = l2;\n        // if any of the two line line changes, the intersection must be updated\n        l1.addDependent(this);\n        l2.addDependent(this);\n\n        // initialize the coordinates of the intersection\n        this.recalcMe();\n    }\n\n    type() {\n        return \"intersectLL\";\n    }\n\n    defaultDescription() {\n        return \"intersection of \" + this._l1.label() + \" and \" + this._l2.label();\n    }\n\n    // although the intersection is a point, it is not a free point\n    isFreePoint() {\n        return false;\n    }\n\n    // recalculate the coordinates\n    recalcMe() {\n        this._valid = this._l1.valid() && this._l2.valid();\n        if (!this._valid)\n            return;\n\n        this._coords = DGCircline.intersectLL(this._l1, this._l2);\n        this._valid = this._l1.onLine(this._coords) && this._l2.onLine(this._coords) ;\n    }\n}\n\n\n// -----------------------------------------------------------------------------\n// object that represents the set of all intersection points between two\n// geometric objects (e.g. a line and a circle, or two circles)\n// -----------------------------------------------------------------------------\nclass DGIntersections extends DGObject {\n    constructor() {\n        super();\n        this.hide(false);\n    }\n\n    type() {\n        return \"intersections\";\n    }\n    \n    // creates a single intersection point based on the given\n    // selection criterion cp1 -> bool\n    intersectionPoint(selectionCriterion) {\n        const p = new DGIntersectPoint(this, selectionCriterion, this.description());\n        // if this set of all intersection points changes, then the\n        // single selected intersection point must be updated\n        this.addDependent(p);\n        return p;\n    }\n\n    // return any intersection point\n    any() {\n        return this.intersectionPoint(p => true);\n    }\n\n    // return both intersection points\n    both() {\n        return [this.intersectionPoint(0), this.intersectionPoint(1)];\n    }\n\n    // return any point that satisfies the given criterion (the point\n    // is invalid if no intersections satisfy the given criterion)\n    select(selectionFun, redraw) {\n        return this.intersectionPoint(selectionFun, redraw);\n    }\n\n    // perform the selection based on the given criterion (this method\n    // is called by the single intersection point objects)\n    selectPoint(selectionCriterion) {\n        if (typeof selectionCriterion == \"function\") {\n            const selected = this._intersections.filter(selectionCriterion);\n            if (selected.length > 0)\n                return selected[0];\n            return null;\n        }\n        \n        if (typeof selectionCriterion == \"number\") {\n            if (this._intersections.length <= selectionCriterion)\n                return null;\n            return this._intersections[selectionCriterion];\n        }\n\n        throw \"Unknown criterion\";\n    }\n\n    isNear(x, y, worldToScreen) {\n        // FIXME: perform the check\n        return false;\n    }\n}\n\n// -----------------------------------------------------------------------------\n// all intersections of two circlines\n// -----------------------------------------------------------------------------\nclass DGIntersect extends DGIntersections {\n    constructor(cl1, cl2, includeFictive) {\n        super();\n        this._cl1 = cl1;\n        this._cl2 = cl2;\n        this._includeFictive = includeFictive;\n        // if the circle or the line changes, the intersection must be updated\n        cl1.addDependent(this);\n        cl2.addDependent(this);\n        // initialize the intersection coordinates\n        this.recalcMe();\n    }\n\n    type() {\n        return \"intersect circlines\";\n    }\n\n    defaultDescription() {\n        return \"intersection of \" + this._cl1.label() + \" and \" + this._cl2.label();\n    }\n\n    // recalculate the coordinates\n    recalcMe() {\n        this._valid = this._cl1.valid() && this._cl2.valid();\n        if (!this._valid)\n            return;\n        this._intersections = DGCircline.intersect(this._cl1, this._cl2, this._includeFictive);\n    }\n}\n\n// -----------------------------------------------------------------------------\n// all intersections of line and circle\n// -----------------------------------------------------------------------------\nclass DGIntersectLC extends DGIntersect {\n    constructor(l, c, includeFictive) {\n        super(l, c, includeFictive);\n    }\n}\n\nclass DGIntersectCL extends DGIntersect {\n    constructor(c, l, includeFictive) {\n        super(c, l, includeFictive);\n    }\n}\n\n// -----------------------------------------------------------------------------\n// all intersections of two circles\n// -----------------------------------------------------------------------------\nclass DGIntersectCC extends DGIntersect {\n    constructor(c1, c2, includeFictive) {\n        super(c1, c2, includeFictive);\n    }\n}\n\n// -----------------------------------------------------------------------------\n// a single intersection point selected from the set of all intersection points\n// by some criteria\n// -----------------------------------------------------------------------------\nclass DGIntersectPoint extends DGPoint {\n    constructor(intersections, selectionCriterion, description) {\n        super();\n        this._intersections = intersections;\n        this._selectionCriterion = selectionCriterion;\n        this.description(description, false);\n        \n        // initialize the coordinates\n        this.recalcMe();\n    }\n\n    type() {\n        return \"intersection point\";\n    }\n\n    // although this is a single point, it is not free\n    isFreePoint() {\n        return false;\n    }\n\n    // change the selection criterion\n    setSelectionCriterion(selectionCriterion) {\n        this._selectionCriterion = selectionCriterion;\n        this.recalc();\n    }\n\n    // get the selection criterion\n    getSelectionCriterion(selectionCriterion) {\n        return this._selectionCriterion;\n    }\n    \n    // recalculate the coordinates\n    recalcMe() {\n        // if no point satisfies the selection criterion, then this point is invalid\n        this._valid = this._intersections.valid();\n        if (!this._valid)\n            return;\n        this._coords = this._intersections.selectPoint(this._selectionCriterion);\n        this._valid = this._coords != null;\n    }\n}\n\n// -----------------------------------------------------------------------------\n// Polygon\n// -----------------------------------------------------------------------------\nclass DGPolygon extends DGObject {\n    constructor(points) {\n        super();\n        this._points = points;\n        this._points.forEach(p => p.addDependent(this));\n        this.recalcMe();\n    }\n\n    // draw\n    drawMe(view) {\n        view.polygon(this._points.map(p => [p.x(), p.y()]),\n                     {borderColor: this.color(),\n                      width: this.width(),\n                      dash: this.dash(),\n                      fillColor: this.fillColor()});\n    }\n\n    point(i) {\n        return this._points[i];\n    }\n\n    // recalculate\n    recalcMe() {\n    }\n}\n\n// -----------------------------------------------------------------------------\n// condition\n// -----------------------------------------------------------------------------\n\nclass DGIf extends DGObject {\n    constructor(condition, thenObject, elseObject, dependencies) {\n        super();\n        this._condition = condition;\n        // both subobjects should be hidden\n        this._thenObject = thenObject.hide(NO_REDRAW);\n        this._elseObject = elseObject.hide(NO_REDRAW);\n        this._dependencies = dependencies;\n        thenObject.addDependent(this);\n        elseObject.addDependent(this);\n        dependencies.forEach(o => o.addDependent(this));\n        this.recalcMe();\n        this._proxy = new Proxy(this, this);\n        return this._proxy;\n    }\n\n    get(target, prop, receiver) {\n        if (prop in this)\n            return this[prop];\n        else {\n            if (typeof this._object[prop] == \"function\")\n                return this._object[prop].bind(this._proxy);\n            else\n                return this._object[prop];\n        }\n    }\n\n    isPoint() {\n        return this._object.isPoint();\n    }\n\n    isLine() {\n        return this._object.isLine();\n    }\n    \n    isCircle() {\n        return this._object.isCircle();\n    }\n\n    type() {\n        return \"if\";\n    }\n\n    // both subobjects must be hidden, and DGIf has its own visibility\n    hidden() {\n        return super.getProperty(\"_hide\");\n    }\n\n    setVisibility(visible, redraw) {\n        super.setProperty(\"_hide\", !visible, redraw);\n    }\n\n    // other properties are delegated to subobjects\n    getProperty(prop, defaultValue) {\n        return this._object.getProperty(prop, defaultValue);\n    }\n\n    setProperty(prop, value, redraw) {\n        this._thenObject.setProperty(prop, value, NO_REDRAW);\n        this._elseObject.setProperty(prop, value, redraw);\n    }\n\n    getStyle() {\n        return this._object.style();\n    }\n\n    setStyle(style, redraw) {\n        this._thenObject.setStyle(style, NO_REDRAW);\n        this._elseObject.setStyle(style, redraw);\n    }\n\n    funArg() {\n        return this._object.funArg();\n    }\n\n    valid() {\n        return this._valid && this._object.valid();\n    }\n    \n    isNear(x, y, worldToScreen) {\n        return this._object.isNear(x, y, worldToScreen);\n    }\n    \n    eq(other, eps) {\n        return this._object.eq(other, eps);\n    }\n\n\n    drawMe(view) {\n        this._object.drawMe(view);\n    }\n\n    drawLabel(view) {\n        this._object.drawLabel(view);\n    }\n\n    recalcMe() {\n        this._valid = this._dependencies.every(obj => obj.valid());\n\n        if (!this._valid || this._condition(...this._dependencies)) {\n            this._object = this._thenObject;\n        } else {\n            this._object = this._elseObject;\n        }\n        \n        this._valid = this._valid && this._object.valid();\n    }\n}\n\n// -----------------------------------------------------------------------------\n// Poincare disc elements\n// -----------------------------------------------------------------------------\n\nclass DGPoincareDiscLine extends DGCircline {\n    constructor(p1, p2) {\n        super();\n        this._p1 = p1;\n        this._p2 = p2;\n        // if any of the two points move, this line must be updated\n        p1.addDependent(this);\n        p2.addDependent(this);\n        // initialize the internal circline representation (Hermitean matrix)\n        this.recalcMe();\n    }\n\n    type() {\n        return \"Poincare line\";\n    }\n\n    defaultDescription() {\n        return \"Poincare line \" + this._p1.label() + this._p2.label();\n    }\n\n    recalcMe() {\n        this._valid = this._p1.valid() && this._p2.valid();\n        if (!this._valid)\n            return;\n        const u = this._p1.cp1().to_complex();\n        const v = this._p2.cp1().to_complex();\n        this._circline = _complex_geom_js__WEBPACK_IMPORTED_MODULE_0__.PoincareDisc.mk_line(u, v);\n    }\n}\n\nclass DGPoincareDiscCircleR extends DGCircline {\n    constructor(c, r) {\n        super();\n        this._c = c;\n        this._r = r;\n        // if the center moves, this circle must be updated\n        c.addDependent(this);\n        // if r is symbolic and it changes, this circle must be updated\n        if (r instanceof DGNum)\n            r.addDependent(this);\n        // initialize the circline\n        this.recalcMe();\n    }\n\n    type() {\n        return \"Poincare circle\";\n    }\n\n    defaultDescription() {\n        return \"Poincare circle c(\" + this._c.label() + \", \" + this.r() + \")\";\n    }\n\n    r() {\n        return this._r instanceof DGNum ? this._r.value() : this._r;\n    }\n\n    recalcMe() {\n        this._valid = this._c.valid() && (!(this._r instanceof DGNum) || this._r.valid());\n        if (!this._valid)\n            return;\n        const r = this.r();\n        if (r <= 0) {\n            this._valid = false;\n            return;\n        }\n        const u = this._c.cp1().to_complex();\n        this._circline = _complex_geom_js__WEBPACK_IMPORTED_MODULE_0__.PoincareDisc.mk_circle(u, r);\n    }\n}\n\nclass DGPoincareDiscCircle extends DGPoincareDiscCircleR {\n    constructor(c, p) {\n        function r(c, p) {\n            const u = c.to_complex();\n            const v = p.to_complex();\n            return _complex_geom_js__WEBPACK_IMPORTED_MODULE_0__.PoincareDisc.hdist(u, v);\n        }\n        super(c, new DGNum((c, p) => r(c, p), [c, p]));\n        // if the point p moves, this circle must be updated\n        this._p = p;\n        p.addDependent(this);\n        // initialize the circline\n        this.recalcMe();\n    }\n\n    type() {\n        return \"Poincare circle\";\n    }\n\n    defaultDescription() {\n        return \"Poincare circle c(\" + this._c.label() + \", \" + this._p.label() + \")\";\n    }\n}\n\n// -----------------------------------------------------------------------------\n// Poincare upper half plane elements\n// -----------------------------------------------------------------------------\n\nclass DGPoincareHalfPlaneLine extends DGCircline {\n    constructor(p1, p2) {\n        super();\n        this._p1 = p1;\n        this._p2 = p2;\n        // if any of the two points move, this line must be updated\n        p1.addDependent(this);\n        p2.addDependent(this);\n        // initialize the internal circline representation (Hermitean matrix)\n        this.recalcMe();\n    }\n\n    type() {\n        return \"Poincare line\";\n    }\n\n    defaultDescription() {\n        return \"Poincare line \" + this._p1.label() + this._p2.label();\n    }\n\n    recalcMe() {\n        this._valid = this._p1.valid() && this._p2.valid();\n        if (!this._valid)\n            return;\n        const u = this._p1.cp1().to_complex();\n        const v = this._p2.cp1().to_complex();\n        this._circline = _complex_geom_js__WEBPACK_IMPORTED_MODULE_0__.PoincareHalfPlane.mk_line(u, v);\n    }\n}\n\nclass DGPoincareHalfPlaneCircleR extends DGCircline {\n    constructor(c, r) {\n        super();\n        this._c = c;\n        this._r = r;\n        // if the center moves, this circle must be updated\n        c.addDependent(this);\n        // if r is symbolic and it changes, this circle must be updated\n        if (r instanceof DGNum)\n            r.addDependent(this);\n        // initialize the circline\n        this.recalcMe();\n    }\n\n    type() {\n        return \"Poincare circle\";\n    }\n\n    defaultDescription() {\n        return \"Poincare circle c(\" + this._c.label() + \", \" + this.r() + \")\";\n    }\n\n    r() {\n        return this._r instanceof DGNum ? this._r.value() : this._r;\n    }\n\n    recalcMe() {\n        this._valid = this._c.valid() && (!(this._r instanceof DGNum) || this._r.valid());\n        if (!this._valid)\n            return;\n        const r = this.r();\n        if (r <= 0) {\n            this._valid = false;\n            return;\n        }\n        const u = this._c.cp1().to_complex();\n        this._circline = _complex_geom_js__WEBPACK_IMPORTED_MODULE_0__.PoincareHalfPlane.mk_circle(u, r);\n    }\n}\n\nclass DGPoincareHalfPlaneCircle extends DGPoincareHalfPlaneCircleR {\n    constructor(c, p) {\n        function r(c, p) {\n            const u = c.to_complex();\n            const v = p.to_complex();\n            return _complex_geom_js__WEBPACK_IMPORTED_MODULE_0__.PoincareHalfPlane.hdist(u, v);\n        }\n        super(c, new DGNum((c, p) => r(c, p), [c, p]));\n        // if the point p moves, this circle must be updated\n        this._p = p;\n        p.addDependent(this);\n        // initialize the circline\n        this.recalcMe();\n    }\n\n    type() {\n        return \"Poincare circle\";\n    }\n\n    defaultDescription() {\n        return \"Poincare circle c(\" + this._c.label() + \", \" + this._p.label() + \")\";\n    }\n}\n\n\n\n\n\n\n//# sourceURL=webpack://ArgoDG/./src/dg/objects.js?");

/***/ }),

/***/ "./src/dg/rc.js":
/*!**********************!*\
  !*** ./src/dg/rc.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"angle_bisector\": () => (/* binding */ angle_bisector),\n/* harmony export */   \"angle_divide\": () => (/* binding */ angle_divide),\n/* harmony export */   \"bisector\": () => (/* binding */ bisector),\n/* harmony export */   \"circle\": () => (/* binding */ circle),\n/* harmony export */   \"circle3\": () => (/* binding */ circle3),\n/* harmony export */   \"circle3_center\": () => (/* binding */ circle3_center),\n/* harmony export */   \"circle_over_segment\": () => (/* binding */ circle_over_segment),\n/* harmony export */   \"drop_perp\": () => (/* binding */ drop_perp),\n/* harmony export */   \"foot\": () => (/* binding */ foot),\n/* harmony export */   \"free\": () => (/* binding */ free),\n/* harmony export */   \"harmonic_conjugate\": () => (/* binding */ harmonic_conjugate),\n/* harmony export */   \"homothety_line\": () => (/* binding */ homothety_line),\n/* harmony export */   \"intersectCC_both\": () => (/* binding */ intersectCC_both),\n/* harmony export */   \"intersectCC_other\": () => (/* binding */ intersectCC_other),\n/* harmony export */   \"intersectLC_both\": () => (/* binding */ intersectLC_both),\n/* harmony export */   \"intersectLC_other\": () => (/* binding */ intersectLC_other),\n/* harmony export */   \"intersectLL\": () => (/* binding */ intersectLL),\n/* harmony export */   \"line\": () => (/* binding */ line),\n/* harmony export */   \"midpoint\": () => (/* binding */ midpoint),\n/* harmony export */   \"other_tangent\": () => (/* binding */ other_tangent),\n/* harmony export */   \"parallel\": () => (/* binding */ parallel),\n/* harmony export */   \"point\": () => (/* binding */ point),\n/* harmony export */   \"points_of_tangency\": () => (/* binding */ points_of_tangency),\n/* harmony export */   \"reflectL\": () => (/* binding */ reflectL),\n/* harmony export */   \"reflectP\": () => (/* binding */ reflectP),\n/* harmony export */   \"segment\": () => (/* binding */ segment),\n/* harmony export */   \"tangents\": () => (/* binding */ tangents),\n/* harmony export */   \"touching_circle\": () => (/* binding */ touching_circle),\n/* harmony export */   \"towards\": () => (/* binding */ towards),\n/* harmony export */   \"triangle\": () => (/* binding */ triangle)\n/* harmony export */ });\n/* harmony import */ var _dg_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dg.js */ \"./src/dg/dg.js\");\n/* harmony import */ var _complex_geom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../complex_geom.js */ \"./src/complex_geom.js\");\n/* harmony import */ var _objects_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./objects.js */ \"./src/dg/objects.js\");\n\n\n\n\n// free point\nfunction point(x, y, redraw) {\n    return _dg_js__WEBPACK_IMPORTED_MODULE_0__.point(x, y, redraw);\n}\n\nconst free = point;\n\n// line AB\n// det: A != B\nfunction line(A, B, redraw) {\n    return _dg_js__WEBPACK_IMPORTED_MODULE_0__.line(A, B, redraw);\n}\n\n// segment AB\n// det: A != B\nfunction segment(A, B, redraw) {\n    return _dg_js__WEBPACK_IMPORTED_MODULE_0__.segment(A, B, redraw);\n}\n\n// intersection of lines l1 and l2\n// non-deg: !parallel(l1, l2)\n// det: l1 != l2\nfunction intersectLL(l1, l2, redraw, includeFictive) {\n    return _dg_js__WEBPACK_IMPORTED_MODULE_0__.intersectLL(l1, l2, redraw, includeFictive);\n}\n\n// both intersections of line l and circle c\n// non-deg: l intersects c\nfunction intersectLC_both(l, c, redraw, includeFictive) {\n    return _dg_js__WEBPACK_IMPORTED_MODULE_0__.intersectLC_both(l, c, redraw, includeFictive);\n}\n\n// other intersection of line l and circle c (different from given point A)\n// non-deg: l intersects c (in two points)\nfunction intersectLC_other(l, c, A, redraw, includeFictive) {\n    const I = _dg_js__WEBPACK_IMPORTED_MODULE_0__.intersectLC_select(l, c, p => !p.eq(A.cp1()), redraw, includeFictive)\n    return I;\n}\n\n// circle centered at C containing A\n// non-deg: C != A\nfunction circle(C, A, redraw) {\n    return _dg_js__WEBPACK_IMPORTED_MODULE_0__.circle(C, A, redraw);\n}\n\n// both intersection of circles c1 and c2\n// non-deg: c1 intersects c2\n// det: c1 != c2\nfunction intersectCC_both(c1, c2, redraw, includeFictive) {\n    return _dg_js__WEBPACK_IMPORTED_MODULE_0__.intersectCC_both(c1, c2, redraw, includeFictive);\n}\n\n// other intersection of circles c1 and c2 (different from the given point A)\n// non-deg: c1 intersects c2 (in two different points)\n// det: c1 != c2\nfunction intersectCC_other(c1, c2, A, redraw, includeFictive) {\n    return _dg_js__WEBPACK_IMPORTED_MODULE_0__.intersectCC_select(c1, c2, p => !p.eq(A.cp1()), redraw, includeFictive);\n}\n\n// bisector of segment AB\n// nondeg: A != B\nfunction bisector(A, B, redraw) {\n    const c1 = circle(A, B, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    const c2 = circle(B, A, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    const [X1, X2] = intersectCC_both(c1, c2, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).map(p => p.hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW));\n    const m = line(X1, X2, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    m.description(\"Bisector of segment \" + A.label() + B.label(), redraw);\n    return m;\n}\n\n\n// midpoint of segment AB\nfunction midpoint(A, B, redraw) {\n    const m = bisector(A, B, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    const l = line(A, B, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    const M = intersectLL(m, l, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    const Mp = _dg_js__WEBPACK_IMPORTED_MODULE_0__.If((A, B) => A.eq(B), _dg_js__WEBPACK_IMPORTED_MODULE_0__.clone(B, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW), M, [A, B], _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    Mp.description(\"Midpoint of segment \" + A.label() + B.label(), redraw);\n    return Mp;\n}\n\n\n// circle over segment AB\n// non-deg: A != B\nfunction circle_over_segment(A, B, redraw) {\n    const l1 = line(A, B, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    const l2 = bisector(A, B, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    const M = intersectLL(l1, l2, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    const c = circle(M, A, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW)\n    c.description(\"Circle over segment \" + A.label() + B.label(), redraw);\n    return c;\n}\n\n// line perpendicular to line l containing point A\nfunction drop_perp(l, A, redraw) {\n    const B = _dg_js__WEBPACK_IMPORTED_MODULE_0__.randomPointOnLine(l, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); // FIXME: diffferent from A\n    const c = circle(A, B, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    const [X1, X2] = intersectLC_both(l, c, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).map(p => p.hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW));\n    const m = bisector(X1, X2, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    m.description(\"Drop perpendicular from point \" + A.label() + \" onto line \" + l.label(), redraw);\n    return m;\n}\n\n// foot of the perpendicular projection of point A onto line l\nfunction foot(l, A, redraw)  {\n    const p = drop_perp(l, A, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    const X = intersectLL(p, l, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    X.description(\"Project point \" + A.label() + \" onto line \" + l.label(), redraw);\n    return X;\n}\n\n// circle centered at point A that touches line l\n// non-deg: A not on l\nfunction touching_circle(A, l, redraw) {\n    const p = drop_perp(l, A, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    const M = intersectLL(p, l, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    const c = circle(A, M, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    c.description(\"Circle centered in \" + A.label() + \" touching line \" + l.label(), redraw);\n    return c;\n}\n\nfunction points_of_tangency(A, c, redraw) {\n    const O = _dg_js__WEBPACK_IMPORTED_MODULE_0__.center(c, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    const c1 = circle_over_segment(O, A, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    const [X1, X2] = intersectCC_both(c, c1, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    const A_on_c = (A, c) => c.circline().on_circline(A);\n    const X = A.clone();\n    return [_dg_js__WEBPACK_IMPORTED_MODULE_0__.If(A_on_c, X, X1, [A, c], redraw), _dg_js__WEBPACK_IMPORTED_MODULE_0__.If(A_on_c, X, X2, [A, c], redraw)];\n}\n\n// both tangents from point A that touch circle c\n// non-deg: A outside c or on c\nfunction tangents(A, c, redraw) {\n    const O = _dg_js__WEBPACK_IMPORTED_MODULE_0__.center(c, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    const c1 = circle_over_segment(O, A, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    const [X1, X2] = intersectCC_both(c, c1, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).map(obj => obj.hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW));\n    const t1 = line(A, X1, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    const t2 = line(A, X2, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    const OA = line(O, A).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    const t = drop_perp(OA, A).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    const A_on_c = (A, c) => c.circline().on_circline(A, 1e-8);\n    return [_dg_js__WEBPACK_IMPORTED_MODULE_0__.If(A_on_c, t, t1, [A, c]), _dg_js__WEBPACK_IMPORTED_MODULE_0__.If(A_on_c, t, t2, [A, c])].map(l => l.description(\n        \"Tangent from point \" + A.label() + \" to circle \" + c.label(), redraw\n    ));\n}\n\n\n\n// tangent from point A that touch circle c, that is different from the given line t\n// non-deg: A outside c\nfunction other_tangent(A, c, t, redraw) {\n    const [t1, t2] = tangents(A, c, false).map(t => t.hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW));\n    const t_ = _dg_js__WEBPACK_IMPORTED_MODULE_0__.If((x, y) => x.eq(y), t2, t1, [t, t1], _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    t_.show(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    t_.description(\"Tangent from point \" + A.label() + \" to circle \" + c.label(), redraw);\n    return t_;\n}\n\n// homothety of a line\nfunction homothety_line() {\n    // TODO\n}\n\n// parallel line to line l that contains point A\nfunction parallel(l, A, redraw) {\n    const n = drop_perp(l, A, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    const p = drop_perp(n, A, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    p.description(\"Parallel to line \" + l.label() + \" containing point \" + A.label(), redraw);\n    return p;\n}\n\n\n// point Z such that XY : XZ = p : q\nfunction towards_aux(X, Y, p, q, redraw) {\n    const pp = Math.abs(p), qq = Math.abs(q);\n    const M = _dg_js__WEBPACK_IMPORTED_MODULE_0__.randomPoint(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    // change M whenever X and Y change\n    X.addDependent(M); Y.addDependent(M);\n    const l = line(X, M, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    const points = [X, M];\n    for (let i = 0; i < Math.max(pp, qq); i++) {\n        const O = points[points.length - 1];\n        const A = points[points.length - 2];\n        const c = circle(O, A, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n        const MM = intersectLC_other(l, c, A, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n        points.push(MM);\n    }\n\n    const p1 = line(Y, points[pp], _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    const p2 = parallel(p1, points[qq], _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    const xy = line(X, Y, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    let Z =  intersectLL(xy, p2, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n\n    if (p*q < 0)\n        Z = reflectP(X, Z, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n\n    return _dg_js__WEBPACK_IMPORTED_MODULE_0__.If((X, Y) => X.eq(Y), _dg_js__WEBPACK_IMPORTED_MODULE_0__.clone(X, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW), Z, [X, Y], redraw).show(redraw);\n}\n\n// point B such that vector AB equals vector XY\nfunction translate_vec(X, Y, A, redraw) {\n    const xy = line(X, Y, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    const xa = line(X, A, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    const p1 = parallel(xy, A, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    const p2 = parallel(xa, Y, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    const B = intersectLL(p1, p2, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    return _dg_js__WEBPACK_IMPORTED_MODULE_0__.If((X, Y) => X.eq(Y),\n                 _dg_js__WEBPACK_IMPORTED_MODULE_0__.clone(A, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW),\n                 _dg_js__WEBPACK_IMPORTED_MODULE_0__.If((X, A) => X.eq(A),\n                       _dg_js__WEBPACK_IMPORTED_MODULE_0__.clone(Y, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW),\n                       B,\n                       [X, A]).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW),\n                 [X, Y], _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).show(redraw);\n}\n\n// point W such that XY : ZW = p : q\nfunction towards(X, Y, Z, p, q, redraw) {\n    const YY = towards_aux(X, Y, p, q, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    const w = translate_vec(X, YY, Z, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    let description;\n    if (X == Z && p == 2 && q == 1)\n        description = \"Midpoint of segment \" + X.label() + Y.label();\n    else if (X == Z && p == 1 && q == 2)\n        description = \"Reflection of point \" + X.label() + \" about point \" + Y.label();\n    else if (X == Z && p == 1 && q == -1)\n        description = \"Reflection of point \" + Y.label() + \" about point \" + X.label();\n    else\n        description = \"Point X such that \" + X.label() + Y.label() + \":\" + Z.label() + \"X\" + \" = \" + p + \":\" + q;\n    w.description(description, redraw);\n    return w;\n}\n\n\n// angle divide\nfunction angle_divide() {\n    // TODO\n}\n\n// a line that bisect the angle BAC\nfunction angle_bisector(B, A, C, redraw) {\n    const k = circle(A, B, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    const c = line(A, B, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    const b = line(A, C, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    const X = _dg_js__WEBPACK_IMPORTED_MODULE_0__.intersectLC_select(b, k, p => _complex_geom_js__WEBPACK_IMPORTED_MODULE_1__.Circline.same_side(p, C, A), _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    const k1 = circle(B, X, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    const k2 = circle(X, B, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    const Y = _dg_js__WEBPACK_IMPORTED_MODULE_0__.intersectCC_any(k1, k2, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    const l = line(A, Y, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    l.description(\"Angle \" + B.label() + A.label() + C.label() + \" bisector\", redraw);\n    return l;\n}\n\n// reflection of point B around point O\nfunction reflectP(O, B, redraw) {\n    const l = line(O, B, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    const c = circle(O, B, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    const BB = intersectLC_other(l, c, B, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    const r = _dg_js__WEBPACK_IMPORTED_MODULE_0__.If((O, B) => O.eq(B), _dg_js__WEBPACK_IMPORTED_MODULE_0__.clone(B, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW), BB, [O, B], _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    r.description(\"Reflect point \" + B.label() + \" about point \" + O.label(), redraw);\n    return r;\n}\n\n// reflection of point A around line l\nfunction reflectL(l, A, redraw) {\n    const p = drop_perp(l, A, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    const M = intersectLL(p, l, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    const c = circle(M, A, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    const AA = intersectLC_other(p, c, A, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    const r = _dg_js__WEBPACK_IMPORTED_MODULE_0__.If((A, M) => A.eq(M), _dg_js__WEBPACK_IMPORTED_MODULE_0__.clone(A, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW), AA, [A, M], _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    r.description(\"Reflect point \" + A.label() + \" about line \" + l.label(), redraw);\n    return r;\n}\n\n// reflection of line l around point O \nfunction reflectP_line(O, l, redraw) {\n    var B1 = _dg_js__WEBPACK_IMPORTED_MODULE_0__.randomPointOnLine(l, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide();\n    var B2 = _dg_js__WEBPACK_IMPORTED_MODULE_0__.randomPointOnLine(l, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW, p => !B1.eq(p)).hide();\n    var B1p = reflectP(O, B1, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    var B2p = reflectP(O, B2, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    var lp = line(B1p, B2p, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    lp.description(\"Reflect line \" + l.label() + \" about point \" + O.label(), redraw);\n    return lp;\n}\n\n// circumcenter of triangle ABC\nfunction circle3_center(A, B, C, redraw) {\n    const ma = bisector(B, C, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    const mb = bisector(A, C, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    const O = intersectLL(ma, mb, redraw);\n    return O;\n}\n\n// circumcircle of triangle ABC\nfunction circle3(A, B, C, redraw) {\n    const ma = bisector(B, C, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    const mb = bisector(A, C, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    const O = intersectLL(ma, mb).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    const c = circle(O, A, redraw);\n    return c;\n}\n\n// point D such that H(A, B, C, D)=-1\n// non-deg: collinear A, B, C and C != A and C != B and C is not midpoint of AB\nfunction harmonic_conjugate(A, B, C, redraw) {\n    const R = _dg_js__WEBPACK_IMPORTED_MODULE_0__.randomPoint(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    A.addDependent(R); B.addDependent(R); C.addDependent(R);\n    const ra = line(R, A, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    const rb = line(R, B, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    const Q = _dg_js__WEBPACK_IMPORTED_MODULE_0__.randomPointOnLine(la, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    const qc = line(Q, C, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    const P = intersectLL(rb, qc, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    const ap = line(A, P, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    const bq = line(B, Q, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    const S = intersectLL(ap, bq, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    const ab = line(A, B, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    const rs = line(R, S, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    return intersectLL(ab, rs, redraw);\n}\n\n// all significant points of the triangle\nfunction triangle(A, B, C) {\n    const elements = [A, B, C];\n    // sides\n    const a = line(B, C, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"a\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"black\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).width(2, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(a);\n    const b = line(A, C, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"b\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"black\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).width(2, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(b);\n    const c = line(A, B, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"c\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"black\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).width(2, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(c);\n\n    // side bisectors\n    const ba = bisector(B, C, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"blue\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"b_{a}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(ba);\n    const bb = bisector(A, C, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"blue\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"b_{b}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(bb);\n    const bc = bisector(A, B, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"blue\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"b_{c}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(bc);\n\n    // circumcenter\n    const O = intersectLL(ba, bb, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"blue\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"O\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(O);\n    // circumcircle\n    const o = circle(O, A, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"blue\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(o);\n\n    // side midpoints\n    const Ma = midpoint(B, C, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"green\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"M_{a}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(Ma);\n    const Mb = midpoint(A, C, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"green\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"M_{b}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(Mb);\n    const Mc = midpoint(A, B, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"green\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"M_{c}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(Mc);\n\n    // angle bisectors\n    const ta = angle_bisector(B, A, C, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"orange\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"t_{a}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(ta);\n    const tb = angle_bisector(A, B, C, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"orange\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"t_{b}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(tb);\n    const tc = angle_bisector(B, C, A, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"orange\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"t_{c}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(tc);\n    // incenter\n    const I = intersectLL(ta, tb, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"orange\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"I\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(I);\n\n    // angle bisector feet\n    const Ta = intersectLL(ta, a, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"orange\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"T_{a}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(Ta);\n    const Tb = intersectLL(tb, b, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"orange\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"T_{b}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(Tb);\n    const Tc = intersectLL(tc, c, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"orange\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"T_{c}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(Tc);\n\n    // incenter perpendicular projections onto triangle sides\n    const tpa = drop_perp(a, I, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"Chocolate\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"t'_{a}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(tpa);\n    const tpb = drop_perp(b, I, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"Chocolate\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"t'_{b}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(tpb);\n    const tpc = drop_perp(c, I, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"Chocolate\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"t'_{c}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(tpc);\n\n    // incenter projection feet\n    const Tpa = intersectLL(tpa, a, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"Chocolate\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"T'_{a}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(Tpa);\n    const Tpb = intersectLL(tpb, b, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"Chocolate\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"T'_{b}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(Tpb);\n    const Tpc = intersectLL(tpc, c, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"Chocolate\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"T'_{c}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(Tpc);\n\n    // incircle\n    const i = circle(I, Tpa, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"orange\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"i\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(i);\n\n    // altitudes\n    const ha = drop_perp(a, A, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"red\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"h_{a}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(ha);\n    const hb = drop_perp(b, B, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"red\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"h_{b}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(hb);\n    const hc = drop_perp(c, C, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"red\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"h_{c}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(hc);\n\n    // orthocenter\n    const H = intersectLL(ha, hb, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"red\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"H\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(H);\n\n    // altitude feet\n    const Ha = intersectLL(ha, a, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"red\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"H_{a}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(Ha);\n    const Hb = intersectLL(hb, b, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"red\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"H_{b}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(Hb);\n    const Hc = intersectLL(hc, c, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"red\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"H_{c}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(Hc);\n\n    // circles over triangle sides\n    const ca = circle(Ma, B, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"DimGray\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"c(B, C)\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(ca);\n    const cb = circle(Mb, A, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"DimGray\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"c(A, C)\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(cb);\n    const cc = circle(Mc, A, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"DimGray\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"c(A, B)\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(cc);\n\n    // medians\n    const ma = line(A, Ma, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"green\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"m_{a}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(ma);\n    const mb = line(B, Mb, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"green\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"m_{b}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(mb);\n    const mc = line(C, Mc, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"green\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"m_{c}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(mc);\n\n    // centroid\n    const G = intersectLL(ma, mb, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"green\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"G\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(G);\n\n    // midlines\n    const MaMb = line(Ma, Mb, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"DarkTurquoise\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"MaMb\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(MaMb);\n    const MaMc = line(Ma, Mc, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"DarkTurquoise\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"MaMc\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(MaMc);\n    const MbMc = line(Mb, Mc, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"DarkTurquoise\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"MbMc\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(MbMc);\n\n    // Euler line\n    const e = line(O, H, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"purple\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"e\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(e);\n    // Euler points\n    const Ea = midpoint(A, H, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"purple\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"E_{a}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(Ea);\n    const Eb = midpoint(B, H, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"purple\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"E_{b}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(Eb);\n    const Ec = midpoint(C, H, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"purple\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"E_{c}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(Ec);\n\n    // Euler (nine-point) circle center\n    const N = circle3_center(Ma, Mb, Mc, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"purple\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"N\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(N);\n    // Euler (nine-point) circle\n    const n = circle(N, Ma, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"purple\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"Ec\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(n);\n\n    // Euler circles\n    const cEaA = circle(Ea, A, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"magenta\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(cEaA);\n    const cEbB = circle(Eb, B, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"magenta\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(cEbB);\n    const cEcC = circle(Ec, C, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"magenta\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(cEcC);\n\n    // angle bisector and side bisector intersections\n    const Na = intersectLL(ba, ta, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"N_{a}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"DeepPink\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(Na);\n    const Nb = intersectLL(bb, tb, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"N_{b}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"DeepPink\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(Nb);\n    const Nc = intersectLL(bc, tc, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"N_{c}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"DeepPink\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(Nc);\n\n    const cNaI = circle(Na, I, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"DeepPink\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(cNaI);\n    const cNbI = circle(Nb, I, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"DeepPink\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(cNbI);\n    const cNcI = circle(Nc, I, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"DeepPink\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(cNcI);\n\n    // angle bisector feet projections onto other triangle sides\n    const Ta_b = foot(b, Ta, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"Olive\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"T_{ab}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(Ta_b);\n    const Ta_c = foot(c, Ta, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"Olive\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"T_{ac}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(Ta_c);\n    const cTa = circle(Ta, Ta_b, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"Olive\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"c_{Ta}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(cTa);\n\n    const Tb_a = foot(a, Tb, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"Olive\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"T_{ba}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(Tb_a);\n    const Tb_c = foot(c, Tb, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"Olive\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"T_{bc}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(Tb_c);\n    const cTb = circle(Tb, Tb_a, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"Olive\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"c_{Tb}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(cTb);\n\n    const Tc_a = foot(a, Tc, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"Olive\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"T_{ca}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(Tc_a);\n    const Tc_b = foot(b, Tc, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"Olive\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"T_{cb}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(Tc_b);\n    const cTc = circle(Tc, Tc_a, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"Olive\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"c_{Tc}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(cTc);\n\n\n    // out angle bisectors\n    const sa = drop_perp(ta, A, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"tomato\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"s_{a}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(sa);\n    const sb = drop_perp(tb, B, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"tomato\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"s_{b}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(sb);\n    const sc = drop_perp(tc, C, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"tomato\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"s_{c}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(sc);\n\n    // outcircle centers\n    const Ia = intersectLL(sb, sc, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"tomato\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"I_{a}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(Ia);\n    const Ib = intersectLL(sa, sc, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"tomato\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"I_{b}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(Ib);\n    const Ic = intersectLL(sa, sb, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"tomato\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"I_{c}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(Ic);\n\n    // outcenters perpendicular projections onto triangle sides\n    const Spa = foot(a, Ia, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"tomato\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"S'_{a}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(Spa);\n    const Spb = foot(b, Ib, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"tomato\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"S'_{b}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(Spb);\n    const Spc = foot(c, Ic, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"tomato\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"S'_{b}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(Spc);\n\n    // outcircles\n    const ia = circle(Ia, Spa, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"tomato\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"i_{a}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(ia);\n    const ib = circle(Ib, Spb, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"tomato\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"i_{b}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(ib);\n    const ic = circle(Ic, Spc, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"tomato\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"i_{c}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(ic);\n\n    // out angle bisector feet\n    const Sa = intersectLL(sa, a, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"tomato\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"S_{a}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(Sa);\n    const Sb = intersectLL(sb, b, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"tomato\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"S_{b}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(Sb);\n    const Sc = intersectLL(sc, c, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"tomato\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"S_{c}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(Sc);\n\n    // circles over segments formed by inner and outer angle bisector feet\n    const cTaSa = circle_over_segment(Ta, Sa, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"IndianRed\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(cTaSa);\n    const cTbSb = circle_over_segment(Tb, Sb, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"IndianRed\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(cTbSb);\n    const cTcSc = circle_over_segment(Tc, Sc, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"IndianRed\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(cTcSc);\n\n    // some parallel lines :)\n    const IMa = line(I, Ma, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"DarkGray\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).width(1.5, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(IMa);\n    const ASpa = line(A, Spa, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"DarkGray\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).width(1.5, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(ASpa);\n\n    const IMb = line(I, Mb, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"DarkGray\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).width(1.5, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(IMb);\n    const BSpb = line(B, Spb, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"DarkGray\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).width(1.5, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(BSpb);\n\n    const IMc = line(I, Mc, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"DarkGray\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).width(1.5, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(IMc);\n    const CSpc = line(C, Spc, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"DarkGray\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).width(1.5, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(CSpc);\n\n    elements.map(obj => obj.hide());\n    return elements;\n}\n\n\n\n\n\n//# sourceURL=webpack://ArgoDG/./src/dg/rc.js?");

/***/ }),

/***/ "./src/dg/tool.js":
/*!************************!*\
  !*** ./src/dg/tool.js ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Highlighter\": () => (/* binding */ Highlighter),\n/* harmony export */   \"Tool\": () => (/* binding */ Tool)\n/* harmony export */ });\n/* harmony import */ var _view_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./view.js */ \"./src/dg/view.js\");\n\n\n// -----------------------------------------------------------------------------\n// highlighting specific objects as the mouse moves over them\n// -----------------------------------------------------------------------------\nclass Highlighter {\n    // this should be overridden\n    shouldHighlight(obj) {\n        return false;\n    }\n}\n\n// -----------------------------------------------------------------------------\n// handling of mouse and keyboard events on a view\n// -----------------------------------------------------------------------------\nclass Tool {\n    constructor(view) {\n        this._view = view;\n    }\n\n    mousemove(x, y, worldToScreen, screenToWorld) {\n    }\n\n    mousedown(x, y, worldToScreen, screenToWorld) {\n    }\n\n    mouseup(x, y, worldToScreen, screenToWorld) {\n    }\n    \n    keydown(e, worldToScreen, screenToWorld) {\n    }\n\n\n    highlightAt(x, y, worldToScreen) {\n        if (!this._highlighter)\n            return;\n        this._construction.highlightAt(x, y, worldToScreen, this._highlighter);\n    }\n\n    getObject() {\n        return undefined;\n    }\n}\n\n\n\n\n//# sourceURL=webpack://ArgoDG/./src/dg/tool.js?");

/***/ }),

/***/ "./src/dg/tool_images.js":
/*!*******************************!*\
  !*** ./src/dg/tool_images.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"bisector\": () => (/* binding */ bisector),\n/* harmony export */   \"circle\": () => (/* binding */ circle),\n/* harmony export */   \"drag\": () => (/* binding */ drag),\n/* harmony export */   \"intersectCC_both\": () => (/* binding */ intersectCC_both),\n/* harmony export */   \"intersectCC_other\": () => (/* binding */ intersectCC_other),\n/* harmony export */   \"intersectLC_both\": () => (/* binding */ intersectLC_both),\n/* harmony export */   \"intersectLC_other\": () => (/* binding */ intersectLC_other),\n/* harmony export */   \"intersectLL\": () => (/* binding */ intersectLL),\n/* harmony export */   \"line\": () => (/* binding */ line),\n/* harmony export */   \"midpoint\": () => (/* binding */ midpoint),\n/* harmony export */   \"parallel\": () => (/* binding */ parallel),\n/* harmony export */   \"perp\": () => (/* binding */ perp),\n/* harmony export */   \"save_svg\": () => (/* binding */ save_svg)\n/* harmony export */ });\nconst drag = \"data:image/png;base64,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\";\n\nconst line = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAMAAABg3Am1AAABfGlDQ1BpY2MAACiRfZE9SMNAHMVfU4siFQWLFHHIUJ0sSBVx1CoUoUKoFVp1MLl+QpOGJMXFUXAtOPixWHVwcdbVwVUQBD9AHJ2cFF2kxP8lhRYxHhz34929x907QGhUmGp2TQCqZhmpRFzMZFfF7lcEEMYAYhiSmanPSVISnuPrHj6+3kV5lve5P0dfLm8ywCcSzzLdsIg3iKc3LZ3zPnGIleQc8TnxuEEXJH7kuuLyG+eiwwLPDBnp1DxxiFgsdrDSwaxkqMRTxJGcqlG+kHE5x3mLs1qpsdY9+QuDeW1lmes0R5DAIpYgQYSCGsqowEKUVo0UEynaj3v4hx2/RC6FXGUwciygChWy4wf/g9/dmoXJmJsUjAOBF9v+GAW6d4Fm3ba/j227eQL4n4Erre2vNoCZT9LrbS1yBPRvAxfXbU3ZAy53gPCTLhuyI/lpCoUC8H5G35QFBm+B3jW3t9Y+Th+ANHWVvAEODoGxImWve7y7p7O3f8+0+vsBk6pytKr5MIYAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAAAZhQTFRF////+fn5z8/P/v7+3d3dkZGRi4uL7e3tpqamhYWFxMTE+Pj4v7+/g4ODrKys8fHx/f391tbWjIyMlpaW4uLi/f799/j1+/z66enpn5+fh4eHzc3N+/v78fLxl5KhYlGFeW+Oz8/QuLi4goKCtLS09PT0lY+iPQapUQDsRwDPPShnkpOR6Ojo9vj0XEeGWwD/PQ2ZyMnI7e3rUEJtSADYXAD/VgD4QR2K19fW+vr6x8fHhoaGiIiKVDmIQAmoQxqSlY+h+/v6kpKS29vb4+TiuLi5z9DP+vv67u7u/v7//v3/vr6+hISEq6urjY2N4eHhnp6e9fX1tra2tbW19/j3t7a6ioSXrqyy8PHvj4+Po6Oj5ubm/v/+nJenPQ2YRwDOPgmjW1JtioqJ7u/sUTiFVADyWAD6PhyC2tvY6ernRy57VADxVwD5RSSJ4OHfkZKRX1ppQRGcPgmkhX2V+vv5xcXF9PTzurm9iIKVsK61/f3/9/f3/Pz/+/v/lZWV/Pz8zs7OiYmJnZ2d5+fnk5OT1NTU9vb2AAAAsFlNxwAAAAFiS0dEh/vZC8sAAAAJcEhZcwAALiMAAC4jAXilP3YAAAAHdElNRQfmBRgUOSfhJZFCAAABI0lEQVRIx2NgGAWjAAtgZCJJOTMLKxsp6tk5OLkYiVfOzcPLx0+8cgFBIWERZqKUioqJMzBISEpJyxBntKycvIKikrKKKrFuUVPX0NTS1iHa7bp6Gvr6BobEe9bI2MTUzNyCWOWWVtY2tnb2Do7EKQdGrJMzs4urmztx6j2AEWsJZXt6gkgvTzzKub19fBERS1CDgKCfsD9xEQsGEgFERywIBAYpBxMZsSGhYeERTJFR0UQaHRMbF5+QmCRItOOTU1JN09IzoGFCBMjMyjbNyc0j1nxmlvyCwvii4hIi1QNzbGlZeUUlNHw8q/Arr0bPsTW1+JQDI7YOLcfiTTck5FgQCAziJTZiQaC+obGpmXjlDAwtbK0CpKhn4GojSfkoGCQAALaIK+SuHFb+AAAAGXRFWHRDb21tZW50AENyZWF0ZWQgd2l0aCBHSU1QV4EOFwAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAyMi0wNS0yNFQxODo1NzozOSswMjowMPnS8RMAAAAldEVYdGRhdGU6bW9kaWZ5ADIwMjItMDUtMjRUMTg6NTc6MzkrMDI6MDCIj0mvAAAAG3RFWHRpY2M6Y29weXJpZ2h0AFB1YmxpYyBEb21haW62kTFbAAAAInRFWHRpY2M6ZGVzY3JpcHRpb24AR0lNUCBidWlsdC1pbiBzUkdCTGdBEwAAABV0RVh0aWNjOm1hbnVmYWN0dXJlcgBHSU1QTJ6QygAAAA50RVh0aWNjOm1vZGVsAHNSR0JbYElDAAAAAElFTkSuQmCC\";\n\nconst circle = \"data:image/png;base64,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\";\n\nconst midpoint = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAMAAABg3Am1AAABfGlDQ1BpY2MAACiRfZE9SMNAHMVfU4siFQWLFHHIUJ0sSBVx1CoUoUKoFVp1MLl+QpOGJMXFUXAtOPixWHVwcdbVwVUQBD9AHJ2cFF2kxP8lhRYxHhz34929x907QGhUmGp2TQCqZhmpRFzMZFfF7lcEEMYAYhiSmanPSVISnuPrHj6+3kV5lve5P0dfLm8ywCcSzzLdsIg3iKc3LZ3zPnGIleQc8TnxuEEXJH7kuuLyG+eiwwLPDBnp1DxxiFgsdrDSwaxkqMRTxJGcqlG+kHE5x3mLs1qpsdY9+QuDeW1lmes0R5DAIpYgQYSCGsqowEKUVo0UEynaj3v4hx2/RC6FXGUwciygChWy4wf/g9/dmoXJmJsUjAOBF9v+GAW6d4Fm3ba/j227eQL4n4Erre2vNoCZT9LrbS1yBPRvAxfXbU3ZAy53gPCTLhuyI/lpCoUC8H5G35QFBm+B3jW3t9Y+Th+ANHWVvAEODoGxImWve7y7p7O3f8+0+vsBk6pytKr5MIYAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAAAPxQTFRF////2NjXlJCd29zbUTaEQgDAk4+dQwDAXQD/QgC+2NnYQwDB/f397u7u6Ojo+fn529vak4+c/v7+qampOTk5KSkpdXV109PTICAgAAAAAwMDkJCQrq6uW1tb0NDQGxsbAQEBioqK/Pz8oaGhMTExISEhbW1t6urq8vPxtbO4mpWlxcXG+vr55+fn3t7e+Pj4+vv6h3+ZOwicQgDCPhaMr6y2/v7/1tfURR+PWAD8XAD/UQDsW0aF8fPv/v3/09TRQhqQWgD9UwDvVkCD8PHu/f3/9vf1dmqOPgOwRwDTPg2bnJim///+7e3soJyogXiTs7K4+Pj3+vn/+ff/Sj6iCwAAAAFiS0dEGexutYgAAAAJcEhZcwAALiMAAC4jAXilP3YAAAAHdElNRQfmBRgVCQnjd8BJAAAAyklEQVQYGe3BWVsBYRgG4McYDMZaqU+2ivbQ9pRdoaJR4f//F9NJnc28c+a6zH3D59t2AU0LwIOgHgrpQciFI4YRCUNOixpGVINcTI/H9RicmIlkCv/SmUwaTrI7u3u5BOT2D5TKH0KukFdKFU2IlcpKVY4gd3xSrZ2ewcn5xeXVNf6YN/UGnDRv7+4fHvGLJNw9PbfanW4PNvYJd4PhS/t1NIaNE8Ld2/vHdPZpwcY+ITD/+v5ZgBMChIhlWQCXhCdcEZ6QhM+3qdbucxRge/nozQAAABl0RVh0Q29tbWVudABDcmVhdGVkIHdpdGggR0lNUFeBDhcAAAAldEVYdGRhdGU6Y3JlYXRlADIwMjItMDUtMjRUMTk6MDk6MDkrMDI6MDDFVbOEAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDIyLTA1LTI0VDE5OjA5OjA5KzAyOjAwtAgLOAAAABt0RVh0aWNjOmNvcHlyaWdodABQdWJsaWMgRG9tYWlutpExWwAAACJ0RVh0aWNjOmRlc2NyaXB0aW9uAEdJTVAgYnVpbHQtaW4gc1JHQkxnQRMAAAAVdEVYdGljYzptYW51ZmFjdHVyZXIAR0lNUEyekMoAAAAOdEVYdGljYzptb2RlbABzUkdCW2BJQwAAAABJRU5ErkJggg==\";\n\nconst bisector = \"data:image/png;base64,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\"\n\nconst perp = \"data:image/png;base64,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\";\n\nconst parallel = \"data:image/png;base64,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\";\n\nconst intersectLL = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAAAAAByaaZbAAAACXBIWXMAAC4jAAAuIwF4pT92AAAAB3RJTUUH5gUYFRAvqnrsrAAAAAJiS0dEAACqjSMyAAABx0lEQVRIx5XVWS9DURAA4JP02bOEN7/C//ATvPIHPNHovbSlC60lEXurKCK2ECRSxFL7EktK0bRUVanqXXLGC1Xae+6Z+3Ym8yX3zEzOEGB82aZIQYywQNgi4cCSB3DAvYcDr0ISBw7bKQ745gEFZGsIByLNWRxYHQQc6N4qEkxrg3cxXhBLzpq0wanjf1ET042esDbwz/w9P08YPVGqfQel9TLvRJ/GGkZilHXpqPjxmx7zNYw+UnaVAr259KjX6I/rlrVn/Ts94mmcSuj3IS3GAADow5Bp5oWncRc2FYDeDwhzrzydpqmhSaDhfmEhxTUa6khlac1Zn7j4xjlLwXJCDFXL79zD5zUQQqpV4ATqZV0JIQYn8AH1rF1c6yirqI1zAeXE2RTIwHV9SAIOIB85zBufADA/pjnEeUA+sFu3swAAtO1YH8h7dlvw+z8SQkoPSEGbY1/+Ce52AhtIO63OQ+U3OLzMBNmtlrbjvHSQzHcMkNm0uk6VP7Fbi8QAgvv8/wwsehkPLgkphWthH4CnD7m1YEriwIGL4oBvAVBAttzgwEPRtcAAK4OAA13bOPAmPuNA4VrQAeOzgAJKyxUOPAlpNvgCGUCt2ns2PH8AAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDIyLTA1LTI0VDE5OjE2OjQ3KzAyOjAwIaVCbgAAACV0RVh0ZGF0ZTptb2RpZnkAMjAyMi0wNS0yNFQxOToxNjo0NyswMjowMFD4+tIAAAAbdEVYdGljYzpjb3B5cmlnaHQAUHVibGljIERvbWFpbraRMVsAAAAidEVYdGljYzpkZXNjcmlwdGlvbgBHSU1QIGJ1aWx0LWluIHNSR0JMZ0ETAAAAFXRFWHRpY2M6bWFudWZhY3R1cmVyAEdJTVBMnpDKAAAADnRFWHRpY2M6bW9kZWwAc1JHQltgSUMAAAAASUVORK5CYII=\";\n\nconst intersectLC_both = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAMAAABg3Am1AAABfGlDQ1BpY2MAACiRfZE9SMNAHMVfU4siFQWLFHHIUJ0sSBVx1CoUoUKoFVp1MLl+QpOGJMXFUXAtOPixWHVwcdbVwVUQBD9AHJ2cFF2kxP8lhRYxHhz34929x907QGhUmGp2TQCqZhmpRFzMZFfF7lcEEMYAYhiSmanPSVISnuPrHj6+3kV5lve5P0dfLm8ywCcSzzLdsIg3iKc3LZ3zPnGIleQc8TnxuEEXJH7kuuLyG+eiwwLPDBnp1DxxiFgsdrDSwaxkqMRTxJGcqlG+kHE5x3mLs1qpsdY9+QuDeW1lmes0R5DAIpYgQYSCGsqowEKUVo0UEynaj3v4hx2/RC6FXGUwciygChWy4wf/g9/dmoXJmJsUjAOBF9v+GAW6d4Fm3ba/j227eQL4n4Erre2vNoCZT9LrbS1yBPRvAxfXbU3ZAy53gPCTLhuyI/lpCoUC8H5G35QFBm+B3jW3t9Y+Th+ANHWVvAEODoGxImWve7y7p7O3f8+0+vsBk6pytKr5MIYAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAAAhZQTFRF/////f39/v7+9fX12NjYsrKyoqKimpqak5OTlpaWnp6ep6enxsbG6urq/Pz86enppKSkgYGBioqKrq6uxMTEzc3N09PTyMjIvLy8nZ2dhYWFjo6O+vr69vb2t7e3hISEra2t5eXl+/v78/Pzzs7OlJSU3d3d7+/vmZmZoKCg6Ojox8fHurq6tbW1sLCw9PT08vLy4uLi4+PjkZGRwMDAU1NTCgoKAAAA6+vr3NzcnJycjIyMiIiI5ubmg4OD5+fnNTU1GBgYfHx8iYmJj4+PzMzM8PDwh4eHv7+/8fHx39/ftLS0fn5+HBwcHR0d+Pj4xcXFqKior6+v9/f32trawsLCi4uLsbGx29vb7e3td3d3BgYGZWVl+fn5ExMTAgICEBAQ0NDQvb29paWlqampgoKCJSUlLy8vmJiYwcHB19fXrKysdnZ2Dg4OLi4ukpKSpqamubm50dHRXl5eBQUFf39/2dnZ5OTkWVlZ5ebjy8zK+Pj30dDRVz2GQAqlPxWQjYWc+vv5/fz//v3//v7//Pz6c2qJRwDTXAD/WAD9QhmUy8vK/f3/1NTUl5eX+Pn2ZFSFUADoWwD/QAujubq6m5ejPgikUADrVz6G5ufk9vb1oJuoYlKEc2mJ0NDR+/r/w8PDhoaG7u7u/f799/j2+/v6oaGhgICAy8vLtra2kJCQysrKycnJ3t7e7Ozsn5+f4eHh/v//fNLwIgAAAAFiS0dENzC4uEcAAAAJcEhZcwAALiMAAC4jAXilP3YAAAAHdElNRQfmBRgVGzm9WoA2AAACV0lEQVRIx2NgGAUUAEYmopUyMbOwsrFzcHJx8/DyEaGeX0BQSFhElEVMXEJSSlpchoByWTl5BUUlmF3KKtKqanjdpq6hqYUiIKMtr6MrpKcPMUDJwBBVvZGxCSO6GYqmZuZmUrIWliJ6VtY21ihytnYqmKFl72Bubu7o5OzCputqqK6ELOfm7oEcWEqeXqLemsY+vkANfq7+6Fb7BwTKB0H8xxTMGxIqzB5mI80ezhMRGRVtbh4Ti2EzR1x8gjCTsm1iUjKHkI2xgJyKkRskFtxSfFJdlNA1qKUBLU4Xcg/LCMzM0gpGs1/GRRzhVFl+Fo9sjZxcoIa8RDd/7KGuYg03wljIOb+gsEitON68pBRnHBkIwqOnjB/i/3LTigw33DHKLoIuwuuuj8yt1KmqRuZLcKNrMApDDoia2rr6hkaGpmYGhpYWkIA4F7qGMg4kD7S2tXd0dnWDNfQ0g0TEONE19PYhcfonTJzUMXkKmA2xgUUVPUC8pJEzy9Rp09tnzIQqBgFRdnQbbJ2Rs8qs2XPmzmNgmN8EE1jAhq7Bc+EiZO7iJUsZkDUosGKENKcoZujDncTnzIIhKbEMT04sF2TGELNdboFbQ7YANsEUnOrt5fmxFQALLXEValxyWMVXSOFw1MpVstgldKWxSqy2w+U7RgUNdcySc42zIe4S2MR4LVqaCfbm5MdXEKu4p6xD4iupWLN5IsVjC6YWt+zS9SsWyfAxMSkFb1gpFCaGlCZbmluwWWKrky/lLN3HEeYexp0YjJpSNuJwmKetV2+ZEW/saL06aAEA5SpymkPuM5EAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDIyLTA1LTI0VDE5OjI3OjU3KzAyOjAwmy9PzwAAACV0RVh0ZGF0ZTptb2RpZnkAMjAyMi0wNS0yNFQxOToyNzo1NyswMjowMOpy93MAAAAbdEVYdGljYzpjb3B5cmlnaHQAUHVibGljIERvbWFpbraRMVsAAAAidEVYdGljYzpkZXNjcmlwdGlvbgBHSU1QIGJ1aWx0LWluIHNSR0JMZ0ETAAAAFXRFWHRpY2M6bWFudWZhY3R1cmVyAEdJTVBMnpDKAAAADnRFWHRpY2M6bW9kZWwAc1JHQltgSUMAAAAASUVORK5CYII=\";\n\nconst intersectLC_other = \"data:image/png;base64,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\";\n\nconst intersectCC_both = \"data:image/png;base64,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\";\n\nconst intersectCC_other = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAMAAABg3Am1AAABfGlDQ1BpY2MAACiRfZE9SMNAHMVfU4siFQWLFHHIUJ0sSBVx1CoUoUKoFVp1MLl+QpOGJMXFUXAtOPixWHVwcdbVwVUQBD9AHJ2cFF2kxP8lhRYxHhz34929x907QGhUmGp2TQCqZhmpRFzMZFfF7lcEEMYAYhiSmanPSVISnuPrHj6+3kV5lve5P0dfLm8ywCcSzzLdsIg3iKc3LZ3zPnGIleQc8TnxuEEXJH7kuuLyG+eiwwLPDBnp1DxxiFgsdrDSwaxkqMRTxJGcqlG+kHE5x3mLs1qpsdY9+QuDeW1lmes0R5DAIpYgQYSCGsqowEKUVo0UEynaj3v4hx2/RC6FXGUwciygChWy4wf/g9/dmoXJmJsUjAOBF9v+GAW6d4Fm3ba/j227eQL4n4Erre2vNoCZT9LrbS1yBPRvAxfXbU3ZAy53gPCTLhuyI/lpCoUC8H5G35QFBm+B3jW3t9Y+Th+ANHWVvAEODoGxImWve7y7p7O3f8+0+vsBk6pytKr5MIYAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAAAkNQTFRF/////v7+9PT04ODgxsbGs7Ozra2ttbW1ysrK5OTk9vb28vLyx8fHsLCwxcXF29vb4+Pj2NjYwcHBr6+vzs7O2trasrKy0tLS9fX18fHxzMzM/Pz8ubm58PDw6enp7+/v4uLi4eHh+Pj4/v//1dbW8/Pzv7+/3t7e2dnZtra2t7e30NDQwsLCycfH9sbG/+bm8snJ24eH+fT0u7u75ubm3d3d6urq+/v74Nvb821t/1dX6ra20p2d9kdH/pGR//z85+fnsbGx9/f309PT6Ojo/v7//vDw7np65g4O5AEBviQk4dnZ/f39zc3NyMjI//7/2aSk5AUF8QAAtAkJzbS07OzsrKys+fn5+vr6/97e/lhYsxsbYgwM1BYW+llZ/+Tk7e3t/6en/5WVubCwp6mpyLGx0mVl/83N+Pn2+fr30dHR19fX//7+//j4//v7ycnJ9/j4urm58O7uysXVelu3gGW22dbfvb29vr6+1tfX8vPwakmtUgDzTwDqf2up+vz45eXlw8PD1tbWqqqqakmrUgDxTwDogGuo+/z4/v795eTm19Xb9vf26+vrurq67u7u///+z8rZeFm0gWa33NriwMDA08/baDq+VhnHm4bD+fr439/f/v/++/v5mIW9UgDtWQD/XijD4uLj5OPktqzJVBPOUgDld1W58PHw9fX2vLXLp5q/4N/j/f3/xMTE1dXVoaGhjIyMfX19XV1dAAAABwcHkJCQvLy8Nzc3ZWVlioqKExMTJSUliYmJ3NzctLS0z8/Pdk3CsgAAAAFiS0dEtEQJat0AAAAJcEhZcwAALiMAAC4jAXilP3YAAAAHdElNRQfmBRgXBA1SMK5zAAACe0lEQVRIx2NgGAXDFDAykqCWiZmFlY2NnYOTixhdjNw8vHz8zJwCzIJCwiJchNWLiolLQA1mlJRiFSCgXlpERhaZL8cqiO4saXlOBUUBOSWwuLIKnxKqtKqaOgpfSUNTi09Km0eHVVdPn4HBwNAI3U4mYxMkB5vySpmZQ0LGwtLK2sbWzh7DlQ6OTnDXOMu4AF3i6grmubl7eHp5Y/EXizOU4ePrB9Tr7w/VwBAQGBQcgkVDaFg4hCEuEwEyHqqcITIqOiY2Lh5Tg4+jA5hOcAQFoKsrTEtiUnJKalo61HcZmYjgzBIEUzzZEC5UQ05uXn5oQWERRLC4pLQMroFZG0TKlkdA+TA3+VRIMlT6gZlV1TW1dfWw8GhoBJFNLBhuBWoIbQYbU9XS2tbeAbMcokGNGaaws6u7B8zw62Xw6esHsSZMnDR5CgPMexAnTZWDaZg2fcbMWSCX+c5mYNDpBYvNmTV3AiyCGLRBvvXhgSWyCfPmL1i4CCS7GOhKKReEG6EapHlBwcrYGAoTX7J02fIVIK+v1JJg4DHDiIdeSMSVN8AEnFatXsOwFmRavjaDWiiGhnXrwZRUFlxkwgQGiAbJDRs3mWEmPkiKdyhHyRlg9zpt3rJ1G5p61e1QX0kLOWAmsx1btuw0R1VvDM9As2WkMaJu1+49e5GzKKMDOz/cIT5qUugaJDX59qlrcTBB1fjIrpNpQJLm6jNFVS8xFWS9qt9+mSx1F4d9IprsB5xQDZyqjexgF81ssNGMXKY6On48U/kUlNCd4MSnJeADda2E335FwkUlI7NQeb5Gg5y6eKOalARRBal0qFQ5H4uQELMTI21K6lEwoAAAvu2AEin5SFEAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDIyLTA1LTI0VDIxOjA0OjEzKzAyOjAwfhORUgAAACV0RVh0ZGF0ZTptb2RpZnkAMjAyMi0wNS0yNFQyMTowNDoxMyswMjowMA9OKe4AAAAbdEVYdGljYzpjb3B5cmlnaHQAUHVibGljIERvbWFpbraRMVsAAAAidEVYdGljYzpkZXNjcmlwdGlvbgBHSU1QIGJ1aWx0LWluIHNSR0JMZ0ETAAAAFXRFWHRpY2M6bWFudWZhY3R1cmVyAEdJTVBMnpDKAAAADnRFWHRpY2M6bW9kZWwAc1JHQltgSUMAAAAASUVORK5CYII=\";\n\nconst save_svg = \"data:image/png;base64,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NGEyMC1iNjNkLWIwMWU0M2I0OGI2OSIKICAgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDplY2E5NTgwNi1iNGY2LTRlMDYtYWU5NS1jZTllNGM4YWUxN2QiCiAgIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo1NDQ2ZDRmNS04YmM5LTRhZGYtYTczNi03NmFkNDA1MTgyZTkiCiAgIGRjOkZvcm1hdD0iaW1hZ2UvcG5nIgogICBHSU1QOkFQST0iMi4wIgogICBHSU1QOlBsYXRmb3JtPSJMaW51eCIKICAgR0lNUDpUaW1lU3RhbXA9IjE2ODM5OTcxNzgxNjc3NzIiCiAgIEdJTVA6VmVyc2lvbj0iMi4xMC4zMCIKICAgdGlmZjpPcmllbnRhdGlvbj0iMSIKICAgeG1wOkNyZWF0b3JUb29sPSJHSU1QIDIuMTAiPgogICA8eG1wTU06SGlzdG9yeT4KICAgIDxyZGY6U2VxPgogICAgIDxyZGY6bGkKICAgICAgc3RFdnQ6YWN0aW9uPSJzYXZlZCIKICAgICAgc3RFdnQ6Y2hhbmdlZD0iLyIKICAgICAgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDphNDNkNzhkNi1jYmQ5LTRjODItOWU0Mi00YzE1MzEzZTFiNjAiCiAgICAgIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkdpbXAgMi4xMCAoTGludXgpIgogICAgICBzdEV2dDp3aGVuPSIyMDIzLTA1LTEzVDE4OjU5OjM4KzAyOjAwIi8+CiAgICA8L3JkZjpTZXE+CiAgIDwveG1wTU06SGlzdG9yeT4KICA8L3JkZjpEZXNjcmlwdGlvbj4KIDwvcmRmOlJERj4KPC94OnhtcG1ldGE+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAKPD94cGFja2V0IGVuZD0idyI/PiQMsewAAAAGYktHRAAAAAAAAPlDu38AAAAJcEhZcwAACxMAAAsTAQCanBgAAAAHdElNRQfnBQ0QOyYPhh+CAAAC70lEQVRYw+3YTYiVZRQH8N+9950aIwctTYIyFxYSVKjFSC6ENopOXyBUqyAoN2Jl0KIIVKRNYIglqIRQILZwEfQFFWhQDlGLxIy0r6lMIym0ZNQZ57roP3AJ73jve2+zsQPv5n2e9/mfc55z/uect+IfKdCPR7EQU1HRuZzHn/gQu/D1+EIVA3lRxyhO4+8uPMMYC/g+LBFrbsW7uB5vYzN+igKdSg3z8Txuwwd4HLZhBO/gpi65tVEquBnfxdUPV6PJX3gTQ12ysFHqAdyBaVhQRR9O4YD/TuqJmTHMriaQxnCuTZfVSkQy9FRLaj4HG3FtmY/Lgs5Nml03maByJfXJBi0t/4NefqBX4uo2+LhIWax1Ano/duKWFgGXZ/+NnYAeCklvw4JLnLMM63AiXF4a9CCexhlswu1N9i0PLX6G9fij00D6Ck+FsDel6FcaiH8pXoqCL+BYN6K3jm+wNvf2cgi/wD14EYNYg99bjeDD+D4WXEoW4pMU5VMp+q9jVgulcCDe2tNunn6BZ+LCXuzFc/itnUOKErk9iFVYkbbyl3YPKEqSyqFcy8hk0mC9LODlRfhFC0pNQU+6xbMpAsNxcU/2nMv73qTFcMaTUqB34gncgM/xFh7CloweA5iJjzJ89aeLfwPvpY9qy71XJDXuCCH8GIvuSvWZgUdCDE9Ggb1RZs5E5XAi0FEcST3tz94j+BQrQ/6zsT/ru6PY/FSmtgNpSgrxTqxOTq7GYmzNhLcWPyRnT8fNhzMi3j2RQUWTdxty2PRofj7lbQRHM2veh2fxK/ZEqZlpwIdaid5Kg2b1WPBz3DkLVyV4BhMcr2bt/XyzHSexCB9nAhy9COmPN+m+xPFwabMKUbR4NbUJrvGxGLS1im9xDe7NXV6M8kabjBXNJrN/y9Sk1FkcqCUIHsC8JPVQPi6S/J08vWnSNqalOYhXKllcl0DoS0rs64TQG2RawOYmRtbjtfHFvoAOxvJ6F58T+cHx4HhsXADMX9TZwBwCMwAAAABJRU5ErkJggg==\";\n\n\n\n\n//# sourceURL=webpack://ArgoDG/./src/dg/tool_images.js?");

/***/ }),

/***/ "./src/dg/tools.js":
/*!*************************!*\
  !*** ./src/dg/tools.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ConstructionToolbar\": () => (/* binding */ ConstructionToolbar),\n/* harmony export */   \"ToolDragFree\": () => (/* binding */ ToolDragFree)\n/* harmony export */ });\n/* harmony import */ var _view_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./view.js */ \"./src/dg/view.js\");\n/* harmony import */ var _rc_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rc.js */ \"./src/dg/rc.js\");\n/* harmony import */ var _tool_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./tool.js */ \"./src/dg/tool.js\");\n/* harmony import */ var _tool_images_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./tool_images.js */ \"./src/dg/tool_images.js\");\n\n\n\n\n\n// -----------------------------------------------------------------------------\n// highlighting specific objects as the mouse moves over them\n// -----------------------------------------------------------------------------\nclass HighlighterFreePoints extends _tool_js__WEBPACK_IMPORTED_MODULE_2__.Highlighter {\n    shouldHighlight(obj) {\n        return obj.isFreePoint();\n    }\n}\nconst highlighterFreePoints = new HighlighterFreePoints();\n\nclass HighlighterPoints extends _tool_js__WEBPACK_IMPORTED_MODULE_2__.Highlighter  {\n    shouldHighlight(obj) {\n        return obj.isPoint();\n    }\n}\nconst highlighterPoints = new HighlighterPoints();\n\nclass HighlighterLines extends _tool_js__WEBPACK_IMPORTED_MODULE_2__.Highlighter  {\n    shouldHighlight(obj) {\n        return obj.isLine();\n    }\n}\nconst highlighterLines = new HighlighterLines();\n\nclass HighlighterCircles extends _tool_js__WEBPACK_IMPORTED_MODULE_2__.Highlighter  {\n    shouldHighlight(obj) {\n        return obj.isCircle();\n    }\n}\nconst highlighterCircles = new HighlighterCircles();\n\n\n// -----------------------------------------------------------------------------\n// handling of mouse and keyboard events on a view\n// -----------------------------------------------------------------------------\nclass ToolDragFree extends _tool_js__WEBPACK_IMPORTED_MODULE_2__.Tool {\n    constructor(view, construction) {\n        super(view);\n\n        this._highlighter = highlighterFreePoints;\n        \n        // mouse button is not yet pressed\n        this._mousedown = false;\n        // point dragged by the mouse\n        this._dragPoint = undefined;\n        // point moved by the keyboard\n        this._keyboardTarget = undefined;\n        // construction whose points can be dragged\n        // (if not specified all existing points free points can be dragged)\n        this._construction = construction;\n    }\n\n    mousemove(x, y, worldToScreen, screenToWorld) {\n        if (this._mousedown && this._dragPoint !== undefined) {\n            const [xw, yw] = screenToWorld(x, y);\n            if (!this._dragPoint.moveTo(xw, yw)) {\n                const N = 10;\n                for (let d = 1; d <= N; d++) {\n                    let ring = [];\n                    for (let x = -d; x <= d; x++)\n                        ring.push([x, -d]);\n                    for (let y = -d+1; y <= d; y++)\n                        ring.push([d, y]);\n                    for (let x = d-1; x >= -d; x--)\n                        ring.push([x, d]);\n                    for (let y = d-1; y >= -d+1; y--)\n                        ring.push([-d, y]);\n\n                    for (let i = 0; i < ring.length; i++) {\n                        const [dx, dy] = ring[i];\n                        const [xw, yw] = screenToWorld(x+dx, y+dy);\n                        if (this._dragPoint.moveTo(xw, yw)) {\n                            return;\n                        }\n                    }\n                }\n            }\n        }\n        this.highlightAt(x, y, worldToScreen);\n    }\n\n    mousedown(x, y, worldToScreen, screenToWorld) {\n        this._mousedown = true;\n        this._dragPoint = this._construction.findFreePointAt(x, y, worldToScreen);\n        this._keyboardTarget = this._dragPoint;\n    }\n\n    mouseup(x, y, worldToScreen, screenToWorld) {\n        this._mousedown = false;\n        this._dragPoint = undefined;\n    }\n\n    keydown(e, worldToScreen, screenToWorld) {\n        if (!this._keyboardTarget)\n            return;\n        const p = this._keyboardTarget;\n        let [x, y] = [p.x(), p.y()];\n        let [xt, yt] = worldToScreen(x, y);\n        let move = false;\n        const speed = 0.5;\n        if (e.key == \"ArrowRight\") {\n            e.preventDefault();\n            xt += speed;\n            move = true;\n        }\n        else if (e.key == \"ArrowLeft\") {\n            e.preventDefault();\n            xt -= speed;\n            move = true;\n        }\n        else if (e.key == \"ArrowUp\") {\n            e.preventDefault();\n            yt -= speed;\n            move = true;\n        }\n        else if (e.key == \"ArrowDown\") {\n            e.preventDefault();\n            yt += speed;\n            move = true;\n        }\n\n        if (!move) return;\n\n        [x, y] = screenToWorld(xt, yt)\n        p.moveTo(x, y);\n    }\n}\n\n\nclass Tool_ConstructObject extends _tool_js__WEBPACK_IMPORTED_MODULE_2__.Tool {\n    constructor(view, types, construction, callback) {\n        super(view);\n        this._object = undefined;\n        this._types = types;\n        this._selected = [];\n        this._construction = construction;\n        this._callback = callback;\n\n        this._view.message(\"Select a \" + this.typeName(this._types[0]));\n        this._highlighter = this.highlighter(this._types[0]);\n    }\n\n    typeName(t) {\n        if (t == 'p') return \"point\";\n        if (t == 'l') return \"line\";\n        if (t == 'c') return \"circle\";\n    }\n\n    highlighter(t) {\n        if (t == 'p') return highlighterPoints;\n        if (t == 'l') return highlighterLines;\n        if (t == 'c') return highlighterCircles;\n    }\n\n    mouseup(x, y, worldToScreen, screenToWorld) {\n        let obj;\n        const k = this._selected.length;\n        if (this._types[k] == \"p\")\n            obj = this._construction.findPointAt(x, y, worldToScreen);\n        else if (this._types[k] == \"l\")\n            obj = this._construction.findLineAt(x, y, worldToScreen);\n        else if (this._types[k] == \"c\")\n            obj = this._construction.findCircleAt(x, y, worldToScreen);\n        if (!obj)\n            return;\n\n        this._selected.push(obj);\n        \n        if (this._selected.length == this._types.length) {\n            this._object = this.construct(...this._selected);\n            if (this._callback) {\n                if (Array.isArray(this._object))\n                    this._object.forEach(obj => this._callback(obj));\n                else\n                    this._callback(this._object);\n            }\n            this._selected = [];\n        }\n\n        let msg = \"\";\n        this._selected.forEach((obj, i) => {msg += \"Selected \" + this.typeName(this._types[i]) + \" \" + obj.label() + \". \"});\n        msg += \"Select a \" + this.typeName(this._types[this._selected.length]);\n        this._view.message(msg);\n        this._highlighter = this.highlighter(this._types[this._selected.length]);\n    }\n\n    mousemove(x, y, worldToScreen, screenToWorld) {\n        this.highlightAt(x, y, worldToScreen, screenToWorld);\n    }\n    \n    getObject() {\n        return this._object;\n    }\n}\n\n\nclass ToolLine extends Tool_ConstructObject {\n    constructor(view, construction, callback) {\n        super(view, \"pp\", construction, callback);\n    }\n    \n    construct(p1, p2) {\n        return _rc_js__WEBPACK_IMPORTED_MODULE_1__.line(p1, p2);\n    }\n}\n\nclass ToolMidpoint extends Tool_ConstructObject {\n    constructor(view, construction, callback) {\n        super(view, \"pp\", construction, callback);\n    }\n    \n    construct(p1, p2) {\n        return _rc_js__WEBPACK_IMPORTED_MODULE_1__.midpoint(p1, p2);\n    }\n}\n\nclass ToolBisector extends Tool_ConstructObject {\n    constructor(view, construction, callback) {\n        super(view, \"pp\", construction, callback);\n    }\n    \n    construct(p1, p2) {\n        return _rc_js__WEBPACK_IMPORTED_MODULE_1__.bisector(p1, p2);\n    }\n}\n\nclass ToolCircle extends Tool_ConstructObject {\n    constructor(view, construction, callback) {\n        super(view, \"pp\", construction, callback);\n    }\n    \n    construct(p1, p2) {\n        return _rc_js__WEBPACK_IMPORTED_MODULE_1__.circle(p1, p2);\n    }\n}\n\nclass ToolDropPerp extends Tool_ConstructObject {\n    constructor(view, construction, callback) {\n        super(view, \"pl\", construction, callback);\n    }\n\n    construct(p, l) {\n        return _rc_js__WEBPACK_IMPORTED_MODULE_1__.drop_perp(l, p);\n    }\n}\n\nclass ToolParallel extends Tool_ConstructObject {\n    constructor(view, construction, callback) {\n        super(view, \"pl\", construction, callback);\n    }\n\n    construct(p, l) {\n        return _rc_js__WEBPACK_IMPORTED_MODULE_1__.parallel(l, p);\n    }\n}\n\nclass ToolIntersectLL extends Tool_ConstructObject {\n    constructor(view, construction, callback) {\n        super(view, \"ll\", construction, callback);\n    }\n\n    construct(l1, l2) {\n        return _rc_js__WEBPACK_IMPORTED_MODULE_1__.intersectLL(l1, l2);\n    }\n}\n\nclass ToolIntersectLC extends Tool_ConstructObject {\n    constructor(view, construction, callback) {\n        super(view, \"lcp\", construction, callback);\n    }\n\n    construct(l, c, p) {\n        return _rc_js__WEBPACK_IMPORTED_MODULE_1__.intersectLC_other(l, c, p);\n    }\n}\n\nclass ToolIntersectLCBoth extends Tool_ConstructObject {\n    constructor(view, construction, callback) {\n        super(view, \"lc\", construction, callback);\n    }\n\n    construct(l, c) {\n        return _rc_js__WEBPACK_IMPORTED_MODULE_1__.intersectLC_both(l, c);\n    }\n}\n\nclass ToolIntersectCC extends Tool_ConstructObject {\n    constructor(view, construction, callback) {\n        super(view, \"ccp\", construction, callback);\n    }\n\n    construct(c1, c2, p) {\n        return _rc_js__WEBPACK_IMPORTED_MODULE_1__.intersectCC_other(c1, c2, p);\n    }\n}\n\nclass ToolIntersectCCBoth extends Tool_ConstructObject {\n    constructor(view, construction, callback) {\n        super(view, \"cc\", construction, callback);\n    }\n\n    construct(c1, c2, p) {\n        return _rc_js__WEBPACK_IMPORTED_MODULE_1__.intersectCC_both(c1, c2);\n    }\n}\n\n\nclass ConstructionToolbar {\n    constructor(construction, view, element, callback) {\n        this._construction = construction;\n        this._view = view;\n        this._tool_callback = callback;\n        \n        const divTools = document.createElement(\"div\");\n        element.prepend(divTools);\n        \n        const self = this;\n        \n        function createButton(title, src, onClick) {\n            const img = document.createElement(\"img\");\n            img.style.border = \"1px solid #555\";\n            img.style.borderRadius = \"5px\";\n            img.style.margin = \"1px\";\n            img.style.width = \"32px\";\n            img.src = src;\n            img.title = title;\n            img.addEventListener(\"click\", function() {\n                [...divTools.getElementsByTagName(\"img\")].forEach(img => { img.style.filter = \"brightness(100%)\"; });\n                img.style.filter = \"brightness(80%)\";\n                onClick();\n            });\n            divTools.append(img);\n        }\n\n        \n        createButton(\"drag free points\", _tool_images_js__WEBPACK_IMPORTED_MODULE_3__.drag, function() {\n            self._view.message(\"\");\n            self.setTool(new ToolDragFree(self._view, self._construction));\n        });\n\n        createButton(\"line\", _tool_images_js__WEBPACK_IMPORTED_MODULE_3__.line, function() {\n            self.setTool(new ToolLine(self._view, self._construction, self._tool_callback));\n        });\n\n        createButton(\"circle\", _tool_images_js__WEBPACK_IMPORTED_MODULE_3__.circle, function() {\n            self.setTool(new ToolCircle(self._view, self._construction, self._tool_callback));\n        });\n\n        createButton(\"midpoint\", _tool_images_js__WEBPACK_IMPORTED_MODULE_3__.midpoint, function() {\n            self.setTool(new ToolMidpoint(self._view, self._construction, self._tool_callback));\n        });\n\n        createButton(\"segment bisector\", _tool_images_js__WEBPACK_IMPORTED_MODULE_3__.bisector, function() {\n            self.setTool(new ToolBisector(self._view, self._construction, self._tool_callback));\n        });\n\n        createButton(\"drop perpendicular\", _tool_images_js__WEBPACK_IMPORTED_MODULE_3__.perp, function() {\n            self.setTool(new ToolDropPerp(self._view, self._construction, self._tool_callback));\n        });\n\n        createButton(\"parallel\", _tool_images_js__WEBPACK_IMPORTED_MODULE_3__.parallel, function() {\n            self.setTool(new ToolParallel(self._view, self._construction, self._tool_callback));\n        });\n\n        divTools.append(document.createElement(\"br\"));\n        \n        createButton(\"intersect two lines\", _tool_images_js__WEBPACK_IMPORTED_MODULE_3__.intersectLL, function() {\n            self.setTool(new ToolIntersectLL(self._view, self._construction, self._tool_callback));\n        });\n\n        createButton(\"both intersections of line and circle\", _tool_images_js__WEBPACK_IMPORTED_MODULE_3__.intersectLC_both, function() {\n            self.setTool(new ToolIntersectLCBoth(self._view, self._construction, self._tool_callback));\n        });\n\n        createButton(\"other intersection of line and circle\", _tool_images_js__WEBPACK_IMPORTED_MODULE_3__.intersectLC_other, function() {\n            self.setTool(new ToolIntersectLC(self._view, self._construction, self._tool_callback));\n        });\n        \n        createButton(\"both intersections of two circles\", _tool_images_js__WEBPACK_IMPORTED_MODULE_3__.intersectCC_both, function() {\n            self.setTool(new ToolIntersectCCBoth(self._view, self._construction, self._tool_callback));\n        });\n\n        createButton(\"other intersection of two circles\", _tool_images_js__WEBPACK_IMPORTED_MODULE_3__.intersectCC_other, function() {\n            self.setTool(new ToolIntersectCC(self._view, self._construction, self._tool_callback));\n        });\n    }\n\n    setTool(tool) {\n        this._view.setTool(tool);\n    }    \n}\n\n\n\n\n//# sourceURL=webpack://ArgoDG/./src/dg/tools.js?");

/***/ }),

/***/ "./src/dg/view.js":
/*!************************!*\
  !*** ./src/dg/view.js ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"View\": () => (/* binding */ View)\n/* harmony export */ });\n// -----------------------------------------------------------------------------\n//  view enables displaying objects\n// -----------------------------------------------------------------------------\nclass View {\n    constructor() {\n        // constructions that are shown by this view\n        this._constructions = [];\n    }\n\n    setConstruction(construction) {\n        this._constructions = [construction];\n        construction.drawView(this);\n    }\n\n    addConstruction(construction) {\n        this._constructions.push(construction);\n        construction.drawView(this);\n    }\n\n    drawObject(obj) {\n        obj.draw(this);\n    }\n\n    drawObjects(objects) {\n        objects.forEach(obj => {\n            this.drawObject(obj);\n        });\n    }\n\n    redraw() {\n        this.clear();\n        this._constructions.forEach(construction => {\n            construction.drawView(this);\n        });\n    }\n\n    // this should be overriden\n    clear() {\n    }\n}\n\n\n\n\n//# sourceURL=webpack://ArgoDG/./src/dg/view.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/chunk loaded */
/******/ 	(() => {
/******/ 		var deferred = [];
/******/ 		__webpack_require__.O = (result, chunkIds, fn, priority) => {
/******/ 			if(chunkIds) {
/******/ 				priority = priority || 0;
/******/ 				for(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];
/******/ 				deferred[i] = [chunkIds, fn, priority];
/******/ 				return;
/******/ 			}
/******/ 			var notFulfilled = Infinity;
/******/ 			for (var i = 0; i < deferred.length; i++) {
/******/ 				var [chunkIds, fn, priority] = deferred[i];
/******/ 				var fulfilled = true;
/******/ 				for (var j = 0; j < chunkIds.length; j++) {
/******/ 					if ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {
/******/ 						chunkIds.splice(j--, 1);
/******/ 					} else {
/******/ 						fulfilled = false;
/******/ 						if(priority < notFulfilled) notFulfilled = priority;
/******/ 					}
/******/ 				}
/******/ 				if(fulfilled) {
/******/ 					deferred.splice(i--, 1)
/******/ 					var r = fn();
/******/ 					if (r !== undefined) result = r;
/******/ 				}
/******/ 			}
/******/ 			return result;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"DG": 0
/******/ 		};
/******/ 		
/******/ 		// no chunk on demand loading
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		__webpack_require__.O.j = (chunkId) => (installedChunks[chunkId] === 0);
/******/ 		
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = (parentChunkLoadingFunction, data) => {
/******/ 			var [chunkIds, moreModules, runtime] = data;
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0;
/******/ 			if(chunkIds.some((id) => (installedChunks[id] !== 0))) {
/******/ 				for(moduleId in moreModules) {
/******/ 					if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 						__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 					}
/******/ 				}
/******/ 				if(runtime) var result = runtime(__webpack_require__);
/******/ 			}
/******/ 			if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			for(;i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					installedChunks[chunkId][0]();
/******/ 				}
/******/ 				installedChunks[chunkId] = 0;
/******/ 			}
/******/ 			return __webpack_require__.O(result);
/******/ 		}
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunkArgoDG"] = self["webpackChunkArgoDG"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/dg.js");
/******/ 	__webpack_exports__ = __webpack_require__.O(__webpack_exports__);
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});