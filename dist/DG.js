/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["DG"] = factory();
	else
		root["DG"] = factory();
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/complex_geom.js":
/*!*****************************!*\
  !*** ./src/complex_geom.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CP1\": () => (/* reexport safe */ _complex_geom_cp1_js__WEBPACK_IMPORTED_MODULE_1__.CP1),\n/* harmony export */   \"Circline\": () => (/* reexport safe */ _complex_geom_circline_js__WEBPACK_IMPORTED_MODULE_4__.Circline),\n/* harmony export */   \"Complex\": () => (/* reexport safe */ _complex_geom_complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex),\n/* harmony export */   \"ComplexMatrix2x2\": () => (/* reexport safe */ _complex_geom_complex_matrix_js__WEBPACK_IMPORTED_MODULE_2__.ComplexMatrix2x2),\n/* harmony export */   \"INCLUDE_FICTIVE\": () => (/* reexport safe */ _complex_geom_circline_js__WEBPACK_IMPORTED_MODULE_4__.INCLUDE_FICTIVE),\n/* harmony export */   \"Moebius\": () => (/* reexport safe */ _complex_geom_moebius_js__WEBPACK_IMPORTED_MODULE_3__.Moebius),\n/* harmony export */   \"PoincareDisc\": () => (/* reexport safe */ _complex_geom_poincare_js__WEBPACK_IMPORTED_MODULE_5__.PoincareDisc),\n/* harmony export */   \"PoincareHalfPlane\": () => (/* reexport safe */ _complex_geom_poincare_js__WEBPACK_IMPORTED_MODULE_5__.PoincareHalfPlane)\n/* harmony export */ });\n/* harmony import */ var _complex_geom_complex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./complex_geom/complex.js */ \"./src/complex_geom/complex.js\");\n/* harmony import */ var _complex_geom_cp1_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./complex_geom/cp1.js */ \"./src/complex_geom/cp1.js\");\n/* harmony import */ var _complex_geom_complex_matrix_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./complex_geom/complex_matrix.js */ \"./src/complex_geom/complex_matrix.js\");\n/* harmony import */ var _complex_geom_moebius_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./complex_geom/moebius.js */ \"./src/complex_geom/moebius.js\");\n/* harmony import */ var _complex_geom_circline_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./complex_geom/circline.js */ \"./src/complex_geom/circline.js\");\n/* harmony import */ var _complex_geom_poincare_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./complex_geom/poincare.js */ \"./src/complex_geom/poincare.js\");\n\n\n\n\n\n\n\n\n//# sourceURL=webpack://ArgoDG/./src/complex_geom.js?");

/***/ }),

/***/ "./src/complex_geom/circline.js":
/*!**************************************!*\
  !*** ./src/complex_geom/circline.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Circline\": () => (/* binding */ Circline),\n/* harmony export */   \"INCLUDE_FICTIVE\": () => (/* binding */ INCLUDE_FICTIVE)\n/* harmony export */ });\n/* harmony import */ var _complex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./complex.js */ \"./src/complex_geom/complex.js\");\n/* harmony import */ var _cp1_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cp1.js */ \"./src/complex_geom/cp1.js\");\n/* harmony import */ var _complex_matrix_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./complex_matrix.js */ \"./src/complex_geom/complex_matrix.js\");\n/* harmony import */ var _moebius_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./moebius.js */ \"./src/complex_geom/moebius.js\");\n\n\n\n\n\nclass Circline {\n    // Circline is represented by a Hermitean matrix\n    constructor(A, B, C, D) {\n        if (arguments[0] instanceof _complex_matrix_js__WEBPACK_IMPORTED_MODULE_2__.ComplexMatrix2x2)\n            this.H = arguments[0];\n        else\n            this.H = new _complex_matrix_js__WEBPACK_IMPORTED_MODULE_2__.ComplexMatrix2x2(A, B, C, D);\n        this.normalize();\n    }\n\n    normalize() {\n        this.H = Circline.normalizeOriented(this.H);\n        this.H_unoriented = Circline.normalizeUnoriented(this.H);\n    }\n\n    // convert the H matrix to canonical form (used for easy circline comparison)\n    // A is set to 1 if possible,\n    // otherwise B is set to unit modulus and nonegative argument\n    // WARNING: this can change orientation\n    static normalizeUnoriented(H) {\n        if (!H.A.is_zero()) {\n            return H.multC(H.A.reciprocal());\n        } else {\n            const arg = H.B.arg();\n            if (0 <= arg && arg < Math.PI)\n                return H.multC(1 / H.B.norm());\n            else\n                return H.multC(- 1 / H.B.norm());\n        }\n    }\n\n    static normalizeOriented(H) {\n        if (!H.A.is_zero()) {\n            return H.multC(1 / H.A.norm());\n        } else {\n            return H.multC(1 / H.B.norm());\n        }\n    }\n\n\n    // Circline that represents an Euclidean circle with center in a (finite) complex number a\n    // that has a radius r\n    static mk_circle(a, r) {\n        return new Circline(_complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.one, a.uminus(),\n                            a.cnj().uminus(), a.mult(a.cnj()).sub(_complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.of_real(r*r)));\n    }\n\n    // Circline that represents an Euclidean line that joins two given (finite) complex numbers \n    static mk_line(z1, z2) {\n        const B = z2.sub(z1).mult(_complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.i);\n        return new Circline(_complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.zero, B,\n                            B.cnj(), _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.cnj_mix(B.uminus(), z1));\n    }\n\n    // Circline determined by tree points (either complex or CP1)\n    static mk_circline3(z1, z2, z3) {\n        if (!(z1 instanceof _cp1_js__WEBPACK_IMPORTED_MODULE_1__.CP1)) z1 = z1.cp1();\n        if (!(z2 instanceof _cp1_js__WEBPACK_IMPORTED_MODULE_1__.CP1)) z2 = z2.cp1();\n        if (!(z3 instanceof _cp1_js__WEBPACK_IMPORTED_MODULE_1__.CP1)) z3 = z3.cp1();\n        const M = _moebius_js__WEBPACK_IMPORTED_MODULE_3__.Moebius.moebius_01inf(z1, z2, z3);\n        return M.inv().moebius_circline(Circline.x_axis());\n    }\n\n    // oposite oriented circline\n    opposite() {\n        return new Circline(this.H.multC(-1));\n    }\n\n    // several special circlines\n    \n    static unit_circle() {\n        return new Circline(_complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.one, _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.zero, _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.zero, _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.minus_one);\n    }\n\n    static x_axis() {\n        return new Circline(_complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.zero, _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.i, _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.minus_i, _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.zero);\n    }\n\n    static y_axis() {\n        return new Circline(_complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.zero, _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.one, _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.one, _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.zero);\n    }\n\n    // check if this circline is an Euclidean line\n    is_line() {\n        return this.H.A.is_zero();\n    }\n\n    // check if this circline is an Euclidean circle\n    is_circle() {\n        return !this.is_line();\n    }\n\n    // Euclidean center of the current circline (works only if this is an Euclidean circle)\n    circle_center() {\n        return this.H.B.uminus().div(this.H.A);\n    }\n\n    // CP1 (euclidean center of infinity)\n    center() {\n        if (this.is_line())\n            return _cp1_js__WEBPACK_IMPORTED_MODULE_1__.CP1.inf;\n        else\n            return _cp1_js__WEBPACK_IMPORTED_MODULE_1__.CP1.of_complex(this.circle_center());\n    }\n\n    // Euclidean radius of the current circline (works only if this is an Euclidean circle)\n    circle_radius() {\n        return Math.sqrt(this.H.B.mult(this.H.C).sub(this.H.A.mult(this.H.D)).div(this.H.A.mult(this.H.A)).re());\n    }\n\n    // Two points on the current circline (works only if this is an Euclidean line)\n    line_points() {\n        const z1 = this.H.D.mult(this.H.B).uminus().div(this.H.B.mult(this.H.C).scale(2));\n        const z2 = z1.add(_complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.i.mult((this.H.B.arg() > 0 ? this.H.B.uminus() : this.H.B).sgn()));\n        return [z1, z2];\n    }\n\n    // precision for checking in/on/out\n    static EPS = 1e-10;\n\n    quad_form(z) {\n        if (!(z instanceof _cp1_js__WEBPACK_IMPORTED_MODULE_1__.CP1))\n            z = z.cp1();\n\n        return z.cnj().vec_mult(this.H.multCP1(z, false)).re();\n    }\n    \n    // checks if the given CP1 point lies on this circline (precision can be changed)\n    on_circline(z, eps) {\n        if (!eps)\n            eps = Circline.EPS;\n        return Math.abs(this.quad_form(z)) < eps;\n    }\n\n    // checks if the given CP1 point lines within the disc surounded by this circline (precision\n    // can be changed)\n    in_disc(z, eps) {\n        if (!eps)\n            eps = Circline.EPS;\n        return this.quad_form(z) < -eps;\n    }\n\n    static cross_ratio(w1, z1, w2, z2) {\n        if (!(z1 instanceof _cp1_js__WEBPACK_IMPORTED_MODULE_1__.CP1)) z1 = z1.cp1();\n        if (!(w1 instanceof _cp1_js__WEBPACK_IMPORTED_MODULE_1__.CP1)) w1 = w1.cp1();\n        if (!(z2 instanceof _cp1_js__WEBPACK_IMPORTED_MODULE_1__.CP1)) z2 = z2.cp1();\n        if (!(w2 instanceof _cp1_js__WEBPACK_IMPORTED_MODULE_1__.CP1)) w2 = w2.cp1();\n        return _cp1_js__WEBPACK_IMPORTED_MODULE_1__.CP1.cross_ratio(w1, z1, w2, z2);\n    }\n\n    // check if w1, z1, w2, and z2 all lie on the same circline\n    // w1, z1, w2, z2 are either all CP1 elements, or can be converted to those by means of\n    // cp1 method\n    static same_circline(w1, z1, w2, z2, eps) {\n        if (!eps)\n            eps = Circline.EPS;\n        const cr = Circline.cross_ratio(w1, z1, w2, z2);\n        return cr.is_inf() || cr.to_complex().is_real(eps);\n    }\n\n    // check if z1 and z2 lie on the same arc determined by w1 and w2 (i.e., if z2 is on the\n    // same arc as z1 between w1 and w2, on the circline determined by w1, z1 and w2)\n    // w1, z1, w2, z2 are either all CP1 elements, or can be converted to those by means of\n    // cp1 method\n    static same_arc(w1, z1, w2, z2, eps) {\n        if (!eps)\n            eps = Circline.EPS;\n        const cr = Circline.cross_ratio(w1, z1, w2, z2);\n        return !cr.is_inf() && cr.to_complex().is_real(eps) && cr.to_complex().re() >= eps;\n    }\n    \n    // check if z1 and z2 lie different arcs determined by w1 and w2 (i.e., if z2 is on the\n    // on the circline determined by w1, z1 and w2, but not on the same arc between w1 and w2\n    // as z1)\n    // w1, z1, w2, z2 are either all CP1 elements, or can be converted to those by means of\n    // cp1 method\n    static other_arc(w1, z1, w2, z2, eps) {\n        if (!eps)\n            eps = Circline.EPS;\n        const cr = Circline.cross_ratio(w1, z1, w2, z2);\n        return !cr.is_inf() && cr.to_complex().is_real(eps) && cr.to_complex().re() < -eps;\n    }\n\n    // check if w is between z1 and z2 (in Euclidean sense)\n    // w, z1, z2 are either all CP1 elements, or can be converted to those by means of\n    // cp1 method\n    static between(z1, w, z2, eps) {\n        return Circline.other_arc(_cp1_js__WEBPACK_IMPORTED_MODULE_1__.CP1.inf, z1, w, z2, eps);\n    }\n\n    // check if z1, z2, and z3 are collinear (in Euclidean sense)\n    // z1, z2, z3 are either all CP1 elements, or can be converted to those by means of\n    // cp1 method\n    static collinear(z1, z2, z3, eps) {\n        return Circline.same_circline(z1, z2, z3, _cp1_js__WEBPACK_IMPORTED_MODULE_1__.CP1.inf, eps);\n    }\n\n    // check if w1 and w2 are on the same side of z (on the same Euclidean half-line)\n    // w1, w2, z are either all CP1 elements, or can be converted to those by means of\n    // cp1 method\n    static same_side(w1, w2, z, eps) {\n        return Circline.collinear(w1, w2, z, eps) && !Circline.between(w1, z, w2, eps);\n    }\n\n    // check if w is h-betwen z1 and z2 on the Poincare line joining z1 and z2 within the unit disc\n    // z1, w, z2 are either all CP1 elements, or can be converted to those by means of\n    // cp1 method\n    static h_between(z1, w, z2, eps) {\n        if (!(w instanceof _cp1_js__WEBPACK_IMPORTED_MODULE_1__.CP1))\n            w = w.cp1();\n        return unit_circle.in_disc(w, eps) && Circline.other_arc(w, z1, w.inversion(), z2, eps) \n    }\n\n    static h_between_hp(z1, w, z2, eps) {\n        if (!(w instanceof _cp1_js__WEBPACK_IMPORTED_MODULE_1__.CP1))\n            w = w.cp1();\n        return !x_axis.in_disc(w, eps) && Circline.other_arc(w, z1, w.cnj(), z2, eps) \n    }\n\n    // cosine of the angle between two circlines\n    static cosAngle(c1, c2) {\n        function det12(H1, H2) {\n            return H1.A.mult(H2.D).add(H2.A.mult(H1.D)).sub(H1.B.mult(H2.C)).sub(H2.B.mult(H1.C));\n        }\n        return - det12(c1.H, c2.H).re() / (2 * Math.sqrt(c1.H.det().re() * c2.H.det().re()));\n    }\n\n    // random three different points on this circline\n    three_points() {\n        if (!this._three_points) {\n            if (this.is_line()) {\n                const [z1, z2] = this.line_points();\n                this._three_points = [z1, z2, z1.add(z2.sub(z1).scale(2))];\n            } else {\n                const c = this.circle_center();\n                const r = this.circle_radius();\n                this._three_points = [c.add(_complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.of_real(r)), c.add(_complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.of_real(-r)), c.add(_complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.of_imag(r))];\n            }\n        }\n        return this._three_points;\n    }\n\n    // a single random point on this circline\n    random_point() {\n        const [z1, z2, z3] = this.three_points().map(p => _cp1_js__WEBPACK_IMPORTED_MODULE_1__.CP1.of_complex(p));\n        const M = _moebius_js__WEBPACK_IMPORTED_MODULE_3__.Moebius.moebius_01inf(z1, z2, z3);\n        const part = Math.floor(Math.random() * 3);\n        let x;\n        if (part == 0)\n            // [0, 1]\n            x = Math.random();\n        else if (part == 1)\n            // [1, infty]\n            x = 1 / Math.random();\n        else\n            // [-infty, 0]\n            x = 1 - 1 / Math.random();\n\n        return M.inv().moebius_pt(_cp1_js__WEBPACK_IMPORTED_MODULE_1__.CP1.of_real(x));\n    }\n\n    // random point on this circline that lies within the given disc (usually the unit disc)\n    random_point_in_disc(disc) {\n        const [p1, p2] = this.intersect(disc, true);\n        const [z1, z2, z3] = this.three_points().map(p => _cp1_js__WEBPACK_IMPORTED_MODULE_1__.CP1.of_complex(p));\n        const M = _moebius_js__WEBPACK_IMPORTED_MODULE_3__.Moebius.moebius_01inf(z1, z2, z3);\n        const [x1, x2] = [p1, p2].map(p => M.moebius_pt(p).to_complex().re()).sort()\n        let p;\n        const MAX_ITER = 100;\n        let iter = 0;\n        do {\n            let x;\n            if (Math.random() < 0.5)\n                x = x1 + Math.random() * (x2 - x1);\n            else {\n                const k = Math.floor(5*Math.random());\n                const d = Math.pow(10, k)*Math.random();\n                x = Math.random() < 0.5 ? x1 - d : x2 + d;\n            }\n            p = M.inv().moebius_pt(_cp1_js__WEBPACK_IMPORTED_MODULE_1__.CP1.of_real(x));\n            iter++;\n        } while (!disc.in_disc(p) && iter < MAX_ITER);\n        return iter < MAX_ITER ? p : null;\n    }\n\n    // Moebius transformation that maps this circline to x-axis\n    moebius_to_x_axis() {\n        if (!this._moebius_to_x_axis) {\n            const [z1, z2, z3] = this.three_points().map(p => _cp1_js__WEBPACK_IMPORTED_MODULE_1__.CP1.of_complex(p));\n            this._moebius_to_x_axis = _moebius_js__WEBPACK_IMPORTED_MODULE_3__.Moebius.moebius_01inf(z1, z2, z3);\n        }\n        return this._moebius_to_x_axis;\n    }\n\n    // intersection of this and other circline (fictive intersections can also be returned)\n    intersect(other, includeFictive) {\n        const M = this.moebius_to_x_axis();\n        const cm = M.moebius_circline(other);\n        const [A, B, D] = [cm.H.A, cm.H.B, cm.H.D];\n        let p1, p2;\n        if (A.is_zero()) {\n            p1 = _cp1_js__WEBPACK_IMPORTED_MODULE_1__.CP1.inf;\n            if (B.is_imag())\n                return [p1, p1];\n            p2 = _cp1_js__WEBPACK_IMPORTED_MODULE_1__.CP1.of_real(- D.re() / (2 * B.re()));\n            return [p1, p2].map(p => M.moebius_inv_pt(p));\n        } else {\n            let discr = B.re() * B.re() - A.re() * D.re();\n            ////////////////////////////////////\n            if (Math.abs(discr) < 1e-12)\n                discr = 0;\n            ////////////////////////////////////\n            if (discr < 0) {\n                if (includeFictive) {\n                    // fictive intersections\n                    const sqrt = Math.sqrt(-discr);\n                    const [p1, p2] = [new _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex(-B.re() / A.re(), +sqrt / A.re()),\n                                      new _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex(-B.re() / A.re(), -sqrt / A.re())];\n                    return [p1, p2].map(p => M.moebius_inv_pt(_cp1_js__WEBPACK_IMPORTED_MODULE_1__.CP1.of_complex(p)));\n                } else\n                    return [];\n            } else {\n                const sqrt = Math.sqrt(discr);\n                const [p1, p2] = [(-B.re() + sqrt) / A.re(),\n                                  (-B.re() - sqrt) / A.re()];\n                return [p1, p2].map(p => M.moebius_inv_pt(_cp1_js__WEBPACK_IMPORTED_MODULE_1__.CP1.of_real(p)));\n            }\n        }\n    }\n\n    // apply the given Moebius transform (given by a function that acts on pairs of coordinates)\n    // to this circline\n    transform(t) {\n        let three_points = this.three_points();\n        if (three_points.some(p => isNaN(p.re())))\n            return this;\n        three_points = three_points.map(p => {\n            const [re, im] = t(p.re(), p.im());\n            return _cp1_js__WEBPACK_IMPORTED_MODULE_1__.CP1.of_complex(new _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex(re, im));\n        });\n        return Circline.mk_circline3(...three_points);\n    }\n\n    // check if this circline is equal to the other one (ignoring orientation)\n    eq(other, eps) {\n        return this.H_unoriented.eq(other.H_unoriented, eps);\n    }\n}\n\nconst unit_circle = Circline.unit_circle();\nconst x_axis = Circline.x_axis();\n\nconst INCLUDE_FICTIVE = true;\n\n\n\n\n//# sourceURL=webpack://ArgoDG/./src/complex_geom/circline.js?");

/***/ }),

/***/ "./src/complex_geom/complex.js":
/*!*************************************!*\
  !*** ./src/complex_geom/complex.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Complex\": () => (/* binding */ Complex)\n/* harmony export */ });\n/**\n * Complex number\n */\nclass Complex {\n    constructor(re, im) {\n        this._re = re;\n        this._im = im;\n    }\n\n    static of_real(re) {\n        return new Complex(re, 0);\n    }\n\n    static of_imag(im) {\n        return new Complex(0, im);\n    }\n\n    static of_xy(x, y) {\n        return new Complex(x, y);\n    }\n\n    static of_polar(rho, theta) {\n        return new Complex(rho * Math.cos(theta), rho * Math.sin(theta));\n    }\n\n    // some special complex numbers\n    \n    static get zero() {\n        return zero;\n    }\n\n    static get one() {\n        return one;\n    }\n\n    static get minus_one() {\n        return minus_one;\n    }\n\n    static get i() {\n        return i;\n    }\n    \n    static get minus_i() {\n        return minus_i;\n    }\n\n\n    // copy of this object\n    clone() {\n        return new Complex(this.re(), this.im());\n    }\n\n    // getting basic properties\n    re() {\n        return this._re;\n    }\n\n    x() {\n        return this.re();\n    }\n\n    im() {\n        return this._im;\n    }\n\n    y() {\n        return this.im();\n    }\n    \n    coords() {\n        return [this.re(), this.im()];\n    }\n\n    // precision for checking zero\n    static EPS = 1e-8;\n\n    // check if this complex number is zero (up to the given precision)\n    is_zero(eps) {\n        if (eps === undefined)\n            eps = Complex.EPS;\n        return this.norm2() < eps * eps;\n    }\n\n    // check if two numbers are equal (up to the given precision)\n    eq(other, eps) {\n        if (other == undefined)\n            return false;\n        // default relative error\n        if (eps === undefined)\n            eps = 1e-8;\n        return this.sub(other).norm() <= eps * (this.norm() + other.norm()) / 2;\n    }\n\n    // check if this complex number is real (up to the given precision)\n    is_real(eps) {\n        if (eps === undefined)\n            eps = Complex.EPS;\n        return Math.abs(this.im()) < eps;\n    }\n\n    // check if this complex number is pure imaginary (up to the given precision)\n    is_imag(eps) {\n        if (eps === undefined)\n            eps = Complex.EPS;\n        \n        return Math.abs(this.re()) < eps;\n    }\n\n    // all complex numbers are finite\n    is_inf() {\n        return false;\n    }\n\n    // just in case that a conversion to complex is called on a complex number\n    to_complex() {\n        return this;\n    }\n\n    // Arithmetic operations\n\n    // addition\n    add(other) {\n        return new Complex(this.re() + other.re(), this.im() + other.im());\n    }\n\n    // unary minus\n    uminus() {\n        return this.scale(-1);\n    }\n\n    // subtraction\n    sub(other) {\n        return this.add(other.uminus());\n    }\n\n    // multiplication\n    mult(other) {\n        if (typeof other == \"number\")\n            return this.scale(other);\n        return new Complex(this.re() * other.re() - this.im() * other.im(),\n                           this.re() * other.im() + this.im() * other.re());\n    }\n\n    // multiplication (scaling) by a real scalar\n    scale(k) {\n        return new Complex(k * this.re(), k * this.im());\n    }\n    \n    // division\n    div(other) {\n        return this.mult(other.reciprocal());\n    }\n\n\n    // Euclidean norm\n    norm() {\n        return Math.sqrt(this.norm2());\n    }\n    \n    // square of Euclidean norm\n    norm2() {\n        return this.re() * this.re() + this.im() * this.im();\n    }\n\n    // argument (angle in (-pi, pi])\n    arg() {\n        return Math.atan2(this.im(), this.re());\n    }\n\n    // signum (z -> z / |z|)\n    sgn() {\n        return this.scale(1 / this.norm());\n    }\n\n    // complex conjugate (x + iy -> x - iy)\n    cnj() {\n        return new Complex(this.re(), -this.im());\n    }\n\n    // reciprocal (z -> 1/z)\n    reciprocal() {\n        return this.cnj().scale(1 / this.norm2())\n    }\n\n    // cnj_mix(x1 + iy2, x2 + iy2) = 2*(x1*x2 + y1*y2) + 0*i\n    static cnj_mix(z1, z2) {\n        return z1.cnj().mult(z2).add(z2.cnj().mult(z1));\n    }\n\n    // scalar product when complex numbers are looked as vectors [x1, y1] [x2, y2]\n    // scalprod(x1 + iy1, x2 + iy2) = x1*x2 + y1*y2\n    static scalprod(z1, z2) {\n        return Complex.cnj_mix(z1, z2).scale(1 / 2).re();\n    }\n}\n\nconst zero      = new Complex( 0,  0);\nconst one       = new Complex( 1,  0);\nconst minus_one = new Complex(-1,  0);\nconst i         = new Complex( 0,  1);\nconst minus_i   = new Complex( 0, -1);\n\n\n\n\n//# sourceURL=webpack://ArgoDG/./src/complex_geom/complex.js?");

/***/ }),

/***/ "./src/complex_geom/complex_matrix.js":
/*!********************************************!*\
  !*** ./src/complex_geom/complex_matrix.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ComplexMatrix2x2\": () => (/* binding */ ComplexMatrix2x2)\n/* harmony export */ });\n/* harmony import */ var _complex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./complex.js */ \"./src/complex_geom/complex.js\");\n/* harmony import */ var _cp1_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cp1.js */ \"./src/complex_geom/cp1.js\");\n\n\n\nclass ComplexMatrix2x2 {\n    constructor(A, B, C, D) {\n        this.A = A;\n        this.B = B;\n        this.C = C;\n        this.D = D;\n    }\n\n    static zero() {\n        return new ComplexMatrix2x2(_complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.zero, _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.zero,\n                                    _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.zero, _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.zero);\n    }\n\n    static eye() {\n        return new ComplexMatrix2x2(_complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.one, _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.zero,\n                                    _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.zero, _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.one);\n    }\n\n    cnj() {\n        return new ComplexMatrix2x2(this.A.cnj(), this.B.cnj(),\n                                    this.C.cnj(), this.D.cnj());\n    }\n\n    transpose() {\n        return new ComplexMatrix2x2(this.A, this.C,\n                                    this.B, this.D);\n    }\n\n    adj() {\n        return this.cnj().transpose();\n    }\n\n    det() {\n        return this.A.mult(this.D).sub(this.B.mult(this.C));\n    }\n\n    inv() {\n        if (!this._inv)\n            this._inv = new ComplexMatrix2x2(this.D, this.B.uminus(),\n                                             this.C.uminus(), this.A).multC(this.det().reciprocal());\n        return this._inv;\n    }\n\n    qr() {\n        if (this._Q == undefined || this._R == undefined) {\n            const s0 = this.C.cnj();\n            const c0 = this.A.cnj();\n            const n = Math.sqrt(s0.norm2() + c0.norm2());\n            const c = c0.scale(1 / n);\n            const s = s0.scale(1 / n);\n            const Qa = new ComplexMatrix2x2(c, s,\n                                            s.cnj().uminus(), c.cnj());\n            this._Q = Qa.adj();\n            this._R = Qa.multM(this);\n        }\n        return [this._Q, this._R];\n    }\n    \n    eq(other, eps) {\n        return this.A.eq(other.A, eps) && this.B.eq(other.B, eps) &&\n               this.C.eq(other.C, eps) && this.D.eq(other.D, eps);\n    }\n\n    is_hermitean() {\n        return this.eq(this.adj());\n    }\n\n    is_zero() {\n        return this.eq(ComplexMatrix2x2.zero());\n    }\n\n    multC(obj) {\n        return new ComplexMatrix2x2(this.A.mult(obj), this.B.mult(obj),\n                                    this.C.mult(obj), this.D.mult(obj));\n    }\n\n    multCP1(obj, normalize) {\n        return new _cp1_js__WEBPACK_IMPORTED_MODULE_1__.CP1(this.A.mult(obj.z1).add(this.B.mult(obj.z2)),\n                       this.C.mult(obj.z1).add(this.D.mult(obj.z2)), normalize);\n    }\n\n    multInvCP1(obj) {\n        const [Q, R] = this.qr();\n        const rhs = Q.adj().multCP1(obj);\n        const z2 = rhs.z2.div(R.D);\n        const z1  = rhs.z1.sub(R.B.mult(z2)).div(R.A);\n        return new _cp1_js__WEBPACK_IMPORTED_MODULE_1__.CP1(z1, z2);\n    }\n\n    multM(obj) {\n        return new ComplexMatrix2x2(this.A.mult(obj.A).add(this.B.mult(obj.C)),\n                                    this.A.mult(obj.B).add(this.B.mult(obj.D)),\n                                    this.C.mult(obj.A).add(this.D.mult(obj.C)),\n                                    this.C.mult(obj.B).add(this.D.mult(obj.D)));\n    }\n\n    congruence(P) {\n        return P.adj().multM(this.multM(P));\n    }\n}\n\n\n\n/*\nclass Matrix3x3 {\n    constructor() {\n        if (arguments.length == 1)\n            this.M = arguments[0];\n        else if (arguments.length == 9)\n            this.M = [[arguments[0], arguments[1], arguments[2]],\n                      [arguments[3], arguments[4], arguments[5]],\n                      [arguments[6], arguments[7], arguments[8]]];\n    }\n\n\n    static zero() {\n        return new Matrix3x3([[0, 0, 0], [0, 0, 0], [0, 0, 0]]);\n    }\n\n    static eye() {\n        return new Matrix3x3([[1, 0, 0], [0, 1, 0], [0, 0, 1]]);\n    }\n\n    transpose() {\n        const M = Matrix3x3.zero();\n        for (let i = 0; i < 3; i++)\n            for (let j = 0; j < 3; j++)\n                M[i][j] = this.M[j][i];\n        return M;\n    }\n\n    det() {\n        const M = this.M;\n        return  M[0][0]*M[1][1]*M[2][2] + M[0][1]*M[1][2]*M[2][0] + M[0][2]*M[1][0]*M[2][1]\n              - M[2][0]*M[1][1]*M[0][2] - M[2][1]*M[1][2]*M[0][0] - M[2][2]*M[1][0]*M[0][1];\n    }\n\n    mult() {\n        if (arguments.length == 1 && typeof arguments[0] == \"number\") {\n            const M = this.M;\n            const MM = new Matrix3x3(M[0][0], M[0][1], M[0][2], M[1][0], M[1][1], M[1][2], M[2][0], M[2][1], M[2][2]);\n            for (let i = 0; i < 3; i++)\n                for (let j = 0; j < 3; j++)\n                    MM.M[i][j] *= arguments[0];\n            return MM;\n        }\n\n        if (arguments.length == 1 && arguments[0] instanceof Matrix3x3) {\n            const M = Matrix3x3.zero();\n            for (let i = 0; i < 3; i++)\n                for (let j = 0; j < 3; j++)\n                    for (let k = 0; k < 3; k++)\n                        M.M[i][j] += this.M[i][k] * arguments[0].M[k][j];\n            return M.M;\n        }\n            \n        throw \"Not supported\";\n    }\n\n    inv() {\n        function d(a, b, c, d) {\n            return a*d - b*c;\n        }\n        const M = this.M;\n        return new Matrix3x3(d(M[1][1], M[1][2], M[2][1], M[2][2]), d(M[0][2], M[0][1], M[2][2], M[2][1]), d(M[0][1], M[0][2], M[1][1], M[1][2]),\n                             d(M[1][2], M[1][0], M[2][2], M[2][0]), d(M[0][0], M[0][2], M[2][0], M[2][2]), d(M[0][2], M[0][0], M[1][2], M[1][0]),\n                             d(M[1][0], M[1][1], M[2][0], M[2][1]), d(M[0][1], M[0][0], M[2][1], M[2][0]), d(M[0][0], M[0][1], M[1][0], M[1][1])).mult(1 / this.det());\n    }\n    \n}\n*/\n\n\n//# sourceURL=webpack://ArgoDG/./src/complex_geom/complex_matrix.js?");

/***/ }),

/***/ "./src/complex_geom/cp1.js":
/*!*********************************!*\
  !*** ./src/complex_geom/cp1.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CP1\": () => (/* binding */ CP1)\n/* harmony export */ });\n/* harmony import */ var _complex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./complex.js */ \"./src/complex_geom/complex.js\");\n\n\n/**\n * Point in CP1 space (complex projective line),\n * given by its complex homogeneous coordinates\n */\nclass CP1 {\n    constructor(z1, z2, normalize) {\n        if (!z2)\n            z2 = _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.one;\n        this.z1 = z1;\n        this.z2 = z2;\n        if (normalize === undefined || normalize)\n            this.normalize();\n    }\n\n    normalize() {\n        if (!this.z2.is_zero()) {\n            this.z1 = this.z1.div(this.z2);\n            this.z2 = _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.one;\n        } else if (!this.z1.is_zero()) {\n            this.z1 = _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.one;\n            this.z2 = _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.zero;\n        }\n    }\n\n    is_valid(eps) {\n        return !this.z1.is_zero(eps) || !this.z2.is_zero(eps);\n    }\n\n    is_zero(eps) {\n        return this.z1.is_zero(eps);\n    }\n    \n    is_inf(eps) {\n        return this.z2.is_zero(eps);\n    }\n\n    static of_complex(z) {\n        return new CP1(z);\n    }\n\n    static of_real(r) {\n        return CP1.of_complex(_complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.of_real(r));\n    }\n    \n    static of_xy(x, y) {\n        return CP1.of_complex(new _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex(x, y));\n    }\n    \n    static get inf() {\n        return inf;\n    }\n    \n    static get zero() {\n        return zero;\n    }\n    \n    static get one() {\n        return one;\n    }\n\n    to_complex() {\n        return this.z1.div(this.z2);\n    }\n\n    coords() {\n        if (!this.is_inf())\n            return this.to_complex().coords();\n        else\n            return null;\n    }\n\n    x() {\n        if (!this.is_inf())\n            return this.to_complex().x();\n        else\n            return null;\n    }\n\n    y() {\n        if (!this.is_inf())\n            return this.to_complex().y();\n        else\n            return null;\n    }    \n    \n    add(other) {\n        if (!this.z2.is_zero() || !other.z2.is_zero())\n            return new CP1(this.z1.mult(other.z2).add(other.z1.mult(this.z2)),\n                           this.z2.mult(other.z2));\n        else\n            return CP1.inf;\n    }\n\n    uminus() {\n        return new CP1(this.z1.uminus(), this.z2);\n    }\n\n    sub(other) {\n        return this.add(other.uminus());\n    }\n\n    mult(other) {\n        if ((this.z1.is_zero() && other.z2.is_zero()) ||\n            (other.z1.is_zero() && this.z2.is_zero()))\n            return CP1.one;\n        else\n            return new CP1(this.z1.mult(other.z1), this.z2.mult(other.z2));\n    }\n\n    reciprocal() {\n        return new CP1(this.z2, this.z1);\n    }\n\n    div(other) {\n        return this.mult(other.reciprocal());\n    }\n\n    cnj() {\n        return new CP1(this.z1.cnj(), this.z2.cnj());\n    }\n\n    inversion() {\n        return this.reciprocal().cnj();\n    }\n\n    eq(other, eps) {\n        if (!other)\n            return false;\n        \n        if (!(other instanceof CP1))\n            other = other.cp1();\n\n        if (!other)\n            return false;\n        \n        this.normalize();\n        other.normalize();\n        \n        if (this.is_inf())\n            return other.is_inf();\n        if (other.is_inf())\n            return this.is_inf();\n        return this.sub(other).is_zero(eps);\n    }\n\n    clone() {\n        return new CP1(this.z1.clone(), this.z2.clone());\n    }\n\n    static ratio(a, b, c) {\n        return (a.sub(b)).div(a.sub(c));\n    }\n\n    static cross_ratio(z, u, v, w) {\n        const n1 = z.z1.mult(u.z2).sub(u.z1.mult(z.z2));\n        const n2 = v.z1.mult(w.z2).sub(w.z1.mult(v.z2));\n        const d1 = z.z1.mult(w.z2).sub(w.z1.mult(z.z2));\n        const d2 = v.z1.mult(u.z2).sub(u.z1.mult(v.z2));\n        if (!n1.mult(n2).is_zero() || !d1.mult(d2).is_zero())\n            return new CP1(n1.mult(n2), d1.mult(d2));\n        else\n            return CP1.one;\n    }\n\n    vec_mult(other) {\n        return this.z1.mult(other.z1).add(this.z2.mult(other.z2));\n    }\n}\n\nconst inf  = new CP1(_complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.one, _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.zero);\nconst zero = CP1.of_real(0);\nconst one  = CP1.of_real(1);\n\n_complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.prototype.cp1 = function() {\n    return CP1.of_complex(this);\n}\n      \n\n\n\n//# sourceURL=webpack://ArgoDG/./src/complex_geom/cp1.js?");

/***/ }),

/***/ "./src/complex_geom/moebius.js":
/*!*************************************!*\
  !*** ./src/complex_geom/moebius.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Moebius\": () => (/* binding */ Moebius)\n/* harmony export */ });\n/* harmony import */ var _complex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./complex.js */ \"./src/complex_geom/complex.js\");\n/* harmony import */ var _complex_matrix_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./complex_matrix.js */ \"./src/complex_geom/complex_matrix.js\");\n/* harmony import */ var _circline_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./circline.js */ \"./src/complex_geom/circline.js\");\n/* harmony import */ var _cp1_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./cp1.js */ \"./src/complex_geom/cp1.js\");\n\n\n\n\n\n/**\n * Moebius transform (az + b) / (cz + d) acting on points of CP1\n */\nclass Moebius {\n    constructor(A, B, C, D) {\n        if (arguments.length == 1 && A instanceof _complex_matrix_js__WEBPACK_IMPORTED_MODULE_1__.ComplexMatrix2x2) {\n            this.construct(A.A, A.B, A.C, A.D);\n        } else {\n            this.construct(A, B, C, D);\n        }\n    }\n\n    construct(A, B, C, D) {\n        if (!A.is_zero()) {\n            B = B.div(A);\n            C = C.div(A);\n            D = D.div(A);\n            A = A.div(A); // must be last\n        }\n        else {\n            const b = B.norm();\n            A = A.scale(1 / b);\n            B = B.scale(1 / b);\n            C = C.scale(1 / b);\n            D = D.scale(1 / b);\n        }\n        this.M = new _complex_matrix_js__WEBPACK_IMPORTED_MODULE_1__.ComplexMatrix2x2(A, B, C, D);\n    }\n\n    moebius_pt(z) {\n        if (!(z instanceof _cp1_js__WEBPACK_IMPORTED_MODULE_3__.CP1))\n            z = z.cp1();\n        return this.M.multCP1(z);\n    }\n\n    moebius_inv_pt(z) {\n        if (!(z instanceof _cp1_js__WEBPACK_IMPORTED_MODULE_3__.CP1))\n            z = z.cp1();\n        return this.M.multInvCP1(z);\n    }\n\n    moebius_circline(c) {\n        return new _circline_js__WEBPACK_IMPORTED_MODULE_2__.Circline(c.H.congruence(this.M.inv()));\n    }\n\n    static id() {\n        return new Moebius(_complex_matrix_js__WEBPACK_IMPORTED_MODULE_1__.ComplexMatrix2x2.eye());\n    }\n\n    inv() {\n        return new Moebius(this.M.inv());\n    }\n\n    comp(other) {\n        return new Moebius(this.M.multM(other.M));\n    }\n\n    static moebius_01inf(w1, w2, w3) {\n        const m23 = w2.z1.mult(w3.z2).sub(w3.z1.mult(w2.z2));\n        const m21 = w2.z1.mult(w1.z2).sub(w1.z1.mult(w2.z2));\n        const m13 = w1.z1.mult(w3.z2).sub(w3.z1.mult(w1.z2));\n        return new Moebius(w1.z2.mult(m23), w1.z1.mult(m23).uminus(),\n                           w3.z2.mult(m21), w3.z1.mult(m21).uminus());\n    }\n}\n\n\n\n\n//# sourceURL=webpack://ArgoDG/./src/complex_geom/moebius.js?");

/***/ }),

/***/ "./src/complex_geom/poincare.js":
/*!**************************************!*\
  !*** ./src/complex_geom/poincare.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"PoincareDisc\": () => (/* binding */ PoincareDisc),\n/* harmony export */   \"PoincareHalfPlane\": () => (/* binding */ PoincareHalfPlane)\n/* harmony export */ });\n/* harmony import */ var _complex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./complex.js */ \"./src/complex_geom/complex.js\");\n/* harmony import */ var _cp1_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cp1.js */ \"./src/complex_geom/cp1.js\");\n/* harmony import */ var _circline_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./circline.js */ \"./src/complex_geom/circline.js\");\n/* harmony import */ var _moebius_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./moebius.js */ \"./src/complex_geom/moebius.js\");\n\n\n\n\n\nclass PoincareDisc {\n    // hyperbolic distance between two given (finite) complex numbers inside the disc\n    static hdist(u, v) {\n        return Math.acosh(1 + (2 * u.sub(v).norm2()) / ((1 - u.norm2()) * (1 - v.norm2())));\n    }\n\n    // cosine of the hyperbolic angle ABC given by three (finite) complex numbers inside the disc\n    static cosPhi(A, B, C) {\n        const l1 = PoincareDisc.mk_line(A, B);\n        const l2 = PoincareDisc.mk_line(C, B);\n        return _circline_js__WEBPACK_IMPORTED_MODULE_2__.Circline.cosAngle(l1, l2);\n    }\n    \n    // Circline that represents a Poincare disc line that joins two given (finite) complex numbers\n    // inside the disc\n    static mk_line(z1, z2) {\n        const A = _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.i.mult((z1.mult(z2.cnj())).sub(z2.mult(z1.cnj())));\n        const B = _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.i.mult(z2.scale(z1.norm2() + 1).sub(z1.scale(z2.norm2() + 1)));\n        return new _circline_js__WEBPACK_IMPORTED_MODULE_2__.Circline(A, B, B.cnj(), A);\n    }\n\n    // Circline that represents a Poincare circle that is centered in a (finite) complex number a\n    // and has the radius r\n    static mk_circle(a, r) {\n        const ae = a.scale(1 / ((1 - a.norm2())*(Math.cosh(r) - 1)/2 + 1));\n        const re = ((1 - a.norm2()) * Math.sinh(r)) / ((1 - a.norm2()) * (Math.cosh(r) - 1) + 2);\n        return _circline_js__WEBPACK_IMPORTED_MODULE_2__.Circline.mk_circle(ae, re);\n    }\n}\n\nconst half_plane_to_disc = new _moebius_js__WEBPACK_IMPORTED_MODULE_3__.Moebius(_complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.one, _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.i.uminus(), _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.one, _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.i);\nconst disc_to_half_plane = half_plane_to_disc.inv();\n\nclass PoincareHalfPlane {\n    // hyperbolic distance between two given (finite) complex numbers inside the upper half plane\n    static hdist(u, v) {\n        return Math.acosh(1 + (u.sub(v).norm2()) / (2*u.im()*v.im()));\n    }\n\n    // cosine of the hyperbolic angle ABC given by three (finite) complex numbers inside the disc\n    static cosPhi(A, B, C) {\n        const l1 = PoincareHalfPlane.mk_line(A, B);\n        const l2 = PoincareHalfPlane.mk_line(C, B);\n        return _circline_js__WEBPACK_IMPORTED_MODULE_2__.Circline.cosAngle(l1, l2);\n    }\n    \n    // Circline that represents a Poincare half plane line that joins\n    // two given (finite) complex numbers inside the disc\n    static mk_line(z1, z2) {\n        // FIXME: find a direct formula\n        const zz1 = half_plane_to_disc.moebius_pt(z1);\n        const zz2 = half_plane_to_disc.moebius_pt(z2);\n        const ll = PoincareDisc.mk_line(zz1.to_complex(), zz2.to_complex());\n        return disc_to_half_plane.moebius_circline(ll);\n    }\n\n    // Circline that represents a Poincare circle that is centered in a (finite) complex number a\n    // and has the radius r\n    static mk_circle(a, r) {\n        // FIXME: find a direct formula\n        const aa = half_plane_to_disc.moebius_pt(a);\n        const cc = PoincareDisc.mk_circle(aa.to_complex(), r);\n        return disc_to_half_plane.moebius_circline(cc);\n    }\n}\n\n\n\n\n//# sourceURL=webpack://ArgoDG/./src/complex_geom/poincare.js?");

/***/ }),

/***/ "./src/dg.js":
/*!*******************!*\
  !*** ./src/dg.js ***!
  \*******************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AnimationButtons\": () => (/* reexport safe */ _dg_animation_buttons_js__WEBPACK_IMPORTED_MODULE_2__.AnimationButtons),\n/* harmony export */   \"ConstructionToolbar\": () => (/* reexport safe */ _dg_tool_js__WEBPACK_IMPORTED_MODULE_3__.ConstructionToolbar),\n/* harmony export */   \"If\": () => (/* reexport safe */ _dg_dg_js__WEBPACK_IMPORTED_MODULE_0__.If),\n/* harmony export */   \"ListView\": () => (/* reexport safe */ _dg_view_js__WEBPACK_IMPORTED_MODULE_4__.ListView),\n/* harmony export */   \"NO_REDRAW\": () => (/* reexport safe */ _dg_objects_js__WEBPACK_IMPORTED_MODULE_1__.NO_REDRAW),\n/* harmony export */   \"REDRAW\": () => (/* reexport safe */ _dg_objects_js__WEBPACK_IMPORTED_MODULE_1__.REDRAW),\n/* harmony export */   \"addObject\": () => (/* reexport safe */ _dg_dg_js__WEBPACK_IMPORTED_MODULE_0__.addObject),\n/* harmony export */   \"animate\": () => (/* reexport safe */ _dg_dg_js__WEBPACK_IMPORTED_MODULE_0__.animate),\n/* harmony export */   \"animationButtons\": () => (/* reexport safe */ _dg_dg_js__WEBPACK_IMPORTED_MODULE_0__.animationButtons),\n/* harmony export */   \"arc\": () => (/* reexport safe */ _dg_dg_js__WEBPACK_IMPORTED_MODULE_0__.arc),\n/* harmony export */   \"center\": () => (/* reexport safe */ _dg_dg_js__WEBPACK_IMPORTED_MODULE_0__.center),\n/* harmony export */   \"circle\": () => (/* reexport safe */ _dg_dg_js__WEBPACK_IMPORTED_MODULE_0__.circle),\n/* harmony export */   \"clone\": () => (/* reexport safe */ _dg_dg_js__WEBPACK_IMPORTED_MODULE_0__.clone),\n/* harmony export */   \"construction\": () => (/* reexport safe */ _dg_dg_js__WEBPACK_IMPORTED_MODULE_0__.construction),\n/* harmony export */   \"constructionToolbar\": () => (/* reexport safe */ _dg_dg_js__WEBPACK_IMPORTED_MODULE_0__.constructionToolbar),\n/* harmony export */   \"container\": () => (/* reexport safe */ _dg_dg_js__WEBPACK_IMPORTED_MODULE_0__.container),\n/* harmony export */   \"findCircleAt\": () => (/* reexport safe */ _dg_dg_js__WEBPACK_IMPORTED_MODULE_0__.findCircleAt),\n/* harmony export */   \"findFreePointAt\": () => (/* reexport safe */ _dg_dg_js__WEBPACK_IMPORTED_MODULE_0__.findFreePointAt),\n/* harmony export */   \"findLineAt\": () => (/* reexport safe */ _dg_dg_js__WEBPACK_IMPORTED_MODULE_0__.findLineAt),\n/* harmony export */   \"findObjectsAt\": () => (/* reexport safe */ _dg_dg_js__WEBPACK_IMPORTED_MODULE_0__.findObjectsAt),\n/* harmony export */   \"findPointAt\": () => (/* reexport safe */ _dg_dg_js__WEBPACK_IMPORTED_MODULE_0__.findPointAt),\n/* harmony export */   \"intersectCC_any\": () => (/* reexport safe */ _dg_dg_js__WEBPACK_IMPORTED_MODULE_0__.intersectCC_any),\n/* harmony export */   \"intersectCC_both\": () => (/* reexport safe */ _dg_dg_js__WEBPACK_IMPORTED_MODULE_0__.intersectCC_both),\n/* harmony export */   \"intersectCC_select\": () => (/* reexport safe */ _dg_dg_js__WEBPACK_IMPORTED_MODULE_0__.intersectCC_select),\n/* harmony export */   \"intersectLC_any\": () => (/* reexport safe */ _dg_dg_js__WEBPACK_IMPORTED_MODULE_0__.intersectLC_any),\n/* harmony export */   \"intersectLC_both\": () => (/* reexport safe */ _dg_dg_js__WEBPACK_IMPORTED_MODULE_0__.intersectLC_both),\n/* harmony export */   \"intersectLC_select\": () => (/* reexport safe */ _dg_dg_js__WEBPACK_IMPORTED_MODULE_0__.intersectLC_select),\n/* harmony export */   \"intersectLL\": () => (/* reexport safe */ _dg_dg_js__WEBPACK_IMPORTED_MODULE_0__.intersectLL),\n/* harmony export */   \"line\": () => (/* reexport safe */ _dg_dg_js__WEBPACK_IMPORTED_MODULE_0__.line),\n/* harmony export */   \"nextAnimationStep\": () => (/* reexport safe */ _dg_dg_js__WEBPACK_IMPORTED_MODULE_0__.nextAnimationStep),\n/* harmony export */   \"num\": () => (/* reexport safe */ _dg_dg_js__WEBPACK_IMPORTED_MODULE_0__.num),\n/* harmony export */   \"poincareDiscCircle\": () => (/* reexport safe */ _dg_dg_js__WEBPACK_IMPORTED_MODULE_0__.poincareDiscCircle),\n/* harmony export */   \"poincareDiscCircleR\": () => (/* reexport safe */ _dg_dg_js__WEBPACK_IMPORTED_MODULE_0__.poincareDiscCircleR),\n/* harmony export */   \"poincareDiscLine\": () => (/* reexport safe */ _dg_dg_js__WEBPACK_IMPORTED_MODULE_0__.poincareDiscLine),\n/* harmony export */   \"poincareHalfPlaneCircle\": () => (/* reexport safe */ _dg_dg_js__WEBPACK_IMPORTED_MODULE_0__.poincareHalfPlaneCircle),\n/* harmony export */   \"poincareHalfPlaneCircleR\": () => (/* reexport safe */ _dg_dg_js__WEBPACK_IMPORTED_MODULE_0__.poincareHalfPlaneCircleR),\n/* harmony export */   \"poincareHalfPlaneLine\": () => (/* reexport safe */ _dg_dg_js__WEBPACK_IMPORTED_MODULE_0__.poincareHalfPlaneLine),\n/* harmony export */   \"point\": () => (/* reexport safe */ _dg_dg_js__WEBPACK_IMPORTED_MODULE_0__.point),\n/* harmony export */   \"pointFun\": () => (/* reexport safe */ _dg_dg_js__WEBPACK_IMPORTED_MODULE_0__.pointFun),\n/* harmony export */   \"prevAnimationStep\": () => (/* reexport safe */ _dg_dg_js__WEBPACK_IMPORTED_MODULE_0__.prevAnimationStep),\n/* harmony export */   \"randomPoint\": () => (/* reexport safe */ _dg_dg_js__WEBPACK_IMPORTED_MODULE_0__.randomPoint),\n/* harmony export */   \"randomPointOnCircle\": () => (/* reexport safe */ _dg_dg_js__WEBPACK_IMPORTED_MODULE_0__.randomPointOnCircle),\n/* harmony export */   \"randomPointOnLine\": () => (/* reexport safe */ _dg_dg_js__WEBPACK_IMPORTED_MODULE_0__.randomPointOnLine),\n/* harmony export */   \"removeObject\": () => (/* reexport safe */ _dg_dg_js__WEBPACK_IMPORTED_MODULE_0__.removeObject),\n/* harmony export */   \"segment\": () => (/* reexport safe */ _dg_dg_js__WEBPACK_IMPORTED_MODULE_0__.segment),\n/* harmony export */   \"setConstruction\": () => (/* reexport safe */ _dg_dg_js__WEBPACK_IMPORTED_MODULE_0__.setConstruction),\n/* harmony export */   \"setup\": () => (/* reexport safe */ _dg_dg_js__WEBPACK_IMPORTED_MODULE_0__.setup),\n/* harmony export */   \"view\": () => (/* reexport safe */ _dg_dg_js__WEBPACK_IMPORTED_MODULE_0__.view)\n/* harmony export */ });\n/* harmony import */ var _dg_dg_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dg/dg.js */ \"./src/dg/dg.js\");\n/* harmony import */ var _dg_objects_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dg/objects.js */ \"./src/dg/objects.js\");\n/* harmony import */ var _dg_animation_buttons_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./dg/animation_buttons.js */ \"./src/dg/animation_buttons.js\");\n/* harmony import */ var _dg_tool_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./dg/tool.js */ \"./src/dg/tool.js\");\n/* harmony import */ var _dg_view_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./dg/view.js */ \"./src/dg/view.js\");\n\n\n\n\n\n\n\n//# sourceURL=webpack://ArgoDG/./src/dg.js?");

/***/ }),

/***/ "./src/dg/animation_buttons.js":
/*!*************************************!*\
  !*** ./src/dg/animation_buttons.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AnimationButtons\": () => (/* binding */ AnimationButtons)\n/* harmony export */ });\nclass AnimationButtons {\n    constructor(construction, element) {\n        const divBtns = document.createElement(\"div\");\n        element.appendChild(divBtns);\n        \n        const btnPrev = document.createElement(\"button\");\n        btnPrev.innerHTML = \"<<\";\n        btnPrev.addEventListener(\"click\", construction.prevAnimationStep.bind(construction));\n        divBtns.appendChild(btnPrev);\n        \n        const btnNext = document.createElement(\"button\");\n        btnNext.innerHTML = \">>\";\n        btnNext.addEventListener(\"click\", construction.nextAnimationStep.bind(construction));\n        divBtns.append(btnNext);\n    }\n}\n\n\n\n\n//# sourceURL=webpack://ArgoDG/./src/dg/animation_buttons.js?");

/***/ }),

/***/ "./src/dg/canvas.js":
/*!**************************!*\
  !*** ./src/dg/canvas.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Canvas\": () => (/* binding */ Canvas)\n/* harmony export */ });\n/* harmony import */ var _latex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./latex.js */ \"./src/dg/latex.js\");\n/* harmony import */ var _colors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./colors.js */ \"./src/dg/colors.js\");\n/* harmony import */ var _complex_geom_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../complex_geom.js */ \"./src/complex_geom.js\");\n\n\n\n\n// -----------------------------------------------------------------------------\n// encapsulate drawing canvas with a few basic drawing primitives\n// -----------------------------------------------------------------------------\nclass Canvas {\n    constructor(element, options) {\n        if (typeof element == \"string\")\n            element = document.getElementById(element);\n\n        if (element instanceof HTMLCanvasElement) {\n            this._canvas = element;\n            this._container = document.createElement(\"div\");\n            this._canvas.parentNode.replaceChild(this._container, this._canvas);\n            this._container.append(this._canvas);\n            this._container.style.width = \"500px\";\n            const h1 = document.getElementsByTagName(\"h1\")[0];\n            h1.style.textAlign = \"center\";\n            h1.style.marginTop = \"45px\";\n        } else {\n            this._container = element;\n            this._canvas = document.createElement(\"canvas\");\n            this._container.innerHTML = \"\";\n            this._container.append(this._canvas);\n            this._canvas.width = this._container.width;\n            this._canvas.height = this._container.height;\n        }\n\n        this._container.style.marginLeft = \"auto\";\n        this._container.style.marginRight = \"auto\";\n\n        const ratio = window.devicePixelRatio;\n        \n        if (options.width) {\n            this._canvas.width = options.width * ratio;\n            this._canvas.style.width = options.width + \"px\";\n        }\n\n        if (options.height) {\n            this._canvas.height = options.height * ratio;\n            this._canvas.style.height = options.height + \"px\";\n        }\n\n        this._ctx = this._canvas.getContext(\"2d\");\n\n        this._ctx.scale(ratio, ratio);\n        \n        if (options.border)\n            this._canvas.style.border = options.border;\n\n        this._defaultColor = \"black\";\n        this._defaultWidth = 1;\n        this._defaultDash = [];\n\n        // add status line paragraph\n        const p = document.createElement(\"p\");;\n        p.id = \"status-line\";\n        this._p_status = p;\n        this._canvas_container = document.createElement(\"div\");\n        this._canvas.parentNode.replaceChild(this._canvas_container, this._canvas);\n        this._canvas_container.style.position = \"relative\";\n        this._canvas_container.append(this._canvas);\n        this._canvas_container.append(p);\n        p.style.position = \"absolute\";\n        p.style.top = \"0px\";\n        p.style.left = \"0px\";\n        p.style.margin = \"5px\";\n        p.style.display = \"none\";\n    }\n\n    addElement(e) {\n        this._canvas_container.append(e);\n    }\n\n    canvas() {\n        return this._canvas;\n    }\n    \n    container() {\n        return this._container;\n    }\n\n    addEventListener(event, fun) {\n        this._canvas.addEventListener(event, fun);\n    }\n\n    width() {\n        const ratio = window.devicePixelRatio;\n        return this._canvas.width / ratio;\n    }\n\n    height() {\n        const ratio = window.devicePixelRatio;\n        return this._canvas.height / ratio;\n    }\n\n    context() {\n        return this._ctx;\n    }\n\n    clear() {\n        const ctx = this.context();\n        ctx.clearRect(0, 0, this.width(), this.height());\n    }\n\n    arc(x, y, r, angle_from, angle_to, counterclockwise, color, width, dash, fill) {\n        // due to bugs in Firefox and Chrome arc primitive large circles are drawn specially\n        if (angle_from == 0 && angle_to == 2 * Math.PI) {\n            if (r > 500 * this.width()) {\n                const intersections = this.circle_endpoints(x, y, r);\n                if (intersections.length == 2) {\n                    this.segment(intersections[0][0], intersections[0][1],\n                                 intersections[1][0], intersections[1][1],\n                                 color, width, dash);\n                }\n                return;\n            }\n\n            // special fix for Firefox - split circle to two arc\n            if (navigator.userAgent.includes(\"Firefox\") &&\n                r > this.width()) {\n                const intersections = this.circle_endpoints(x, y, r);\n                if (intersections.length == 2) {\n                    const P1 = new _complex_geom_js__WEBPACK_IMPORTED_MODULE_2__.Complex(intersections[0][0], intersections[0][1]);\n                    const P2 = new _complex_geom_js__WEBPACK_IMPORTED_MODULE_2__.Complex(intersections[1][0], intersections[1][1]);\n                    this.arc(P1.x(), P1.y(), 2, 0, 2*Math.PI, true, \"green\");\n                    this.arc(P2.x(), P2.y(), 2, 0, 2*Math.PI, true, \"green\");\n                    const c = new _complex_geom_js__WEBPACK_IMPORTED_MODULE_2__.Complex(x, y);\n                    const a1 = P1.sub(c).arg();\n                    const a2 = P2.sub(c).arg();\n                    this.arc(x, y, r, a1, a2, counterclockwise, color, width, dash, fill);\n                    this.arc(x, y, r, a1, a2, !counterclockwise, color, width, dash, fill);\n                    return;\n                }\n            }\n        }\n        \n        color = color || this._defaultColor;\n        width = width || this._defaultWidth;\n        dash = dash || this._defaultDash;\n        if (fill === undefined)\n            fill = false;\n        \n        const ctx = this.context();\n        ctx.lineWidth = width;\n        ctx.setLineDash(dash);\n        ctx.beginPath();\n        ctx.arc(x, y, r, angle_from, angle_to, counterclockwise);\n        if (fill) {\n            ctx.fillStyle = color;\n            ctx.fill();\n            const o = (0,_colors_js__WEBPACK_IMPORTED_MODULE_1__.getOpacity)(color)\n            if (!o)\n                ctx.strokeStyle = \"black\";\n            else\n                ctx.strokeStyle = \"rgba(0, 0, 0, \" + o + \")\";\n            ctx.stroke();\n        } else {\n            ctx.strokeStyle = color;\n            ctx.stroke();\n        }\n    }\n    \n    circle(x, y, r, color, width, dash, fill) {\n        this.arc(x, y, r, 0, 2*Math.PI, true, color, width, dash, fill);\n    }\n\n    segment(x1, y1, x2, y2, color, width, dash) {\n        color = color || this._defaultColor;\n        width = width || this._defaultWidth;\n        dash = dash || this._defaultDash;\n        const ctx = this.context();\n        ctx.beginPath();\n        ctx.moveTo(x1, y1);\n        ctx.lineTo(x2, y2);\n        ctx.lineWidth = width;\n        ctx.strokeStyle = color;\n        ctx.setLineDash(dash);\n        ctx.stroke();\n    }\n\n    segment_complement(x1, y1, x2, y2, color, width, dash) {\n        color = color || this._defaultColor;\n        width = width || this._defaultWidth;\n        dash = dash || this._defaultDash;\n        const [x1l, y1l, x2l, y2l] = this.line_endpoints(x1, y1, x2, y2);\n        this.segment(x1l, y1l, x1, y1);\n        this.segment(x2, y2, x2l, y2l);\n    }\n\n    circle_endpoints(x, y, r) {\n        const [w, h] = [this.width(), this.height()];\n        const inUL = x*x + y*y < r*r;\n        const inUR = (x - w)*(x - w) + y*y < r*r;\n        const inDL = x*x + (y - h) * (y - h);\n        const inDR = (x - w)*(x - w) + (y - h)*(y - h) < r*r;\n\n        const intersections = [];\n        if (inUL != inUR) {\n            const d = Math.sqrt(r*r - y*y);\n            const x0 = x + d;\n            const x1 = x - d;\n            if (0 <= x0 && x0 <= w)\n                intersections.push([x0, 0]);\n            else if (0 <= x1 && x1 <= w)\n                intersections.push([x1, 0]);\n        }\n\n        if (inDL != inDR) {\n            const d = Math.sqrt(r*r - (y - h)*(y - h));\n            const x0 = x + d;\n            const x1 = x - d;\n            if (0 <= x0 && x0 <= w)\n                intersections.push([x0, h]);\n            else if (0 <= x1 && x1 <= w)\n                intersections.push([x1, h]);\n        }\n\n        if (inUL != inDL) {\n            const d = Math.sqrt(r*r - x*x);\n            const y0 = y + d;\n            const y1 = y - d;\n            if (0 <= y0 && y0 <= h)\n                intersections.push([0, y0]);\n            else if (0 <= y1 && y1 <= h)\n                intersections.push([0, y1]);\n        }\n\n        if (inUR != inDR) {\n            const d = Math.sqrt(r*r - (x - w)*(x - w));\n            const y0 = y + d;\n            const y1 = y - d;\n            if (0 <= y0 && y0 <= h)\n                intersections.push([w, y0]);\n            else if (0 <= y1 && y1 <= h)\n                intersections.push([w, y1]);\n        }\n\n        return intersections;\n    }\n\n    line_endpoints(x1, y1, x2, y2) {\n        const [w, h] = [this.width(), this.height()];\n\n        if (x1 == x2)\n            return [x1, 0, x1, h];\n        else if (y1 == y2)\n            return [0, y1, w, y1];\n        else {\n            let intersections = []\n\n            function point(t) {\n                const x = x1 + t * (x2 - x1);\n                const y = y1 + t * (y2 - y1);\n                return [x, y];\n            }\n\n            let t, x, y;\n            \n            t = (0 - x1) / (x2 - x1);\n            [x, y] = point(t);\n\n            if (0 <= y && y <= h)\n                intersections.push.apply(intersections, [x, y]);\n\n            t = (w - x1) / (x2 - x1);\n            [x, y] = point(t);\n\n            if (0 <= y && y <= h)\n                intersections.push.apply(intersections, [x, y]);\n\n            if (intersections.length == 4)\n                return intersections;\n\n            t = (0 - y1) / (y2 - y1);\n            [x, y] = point(t);\n\n            if (0 <= x && x <= w)\n                intersections.push.apply(intersections, [x, y]);\n            \n            if (intersections.length == 4)\n                return intersections;\n            \n            t = (h - y1) / (y2 - y1);\n            [x, y] = point(t);\n\n            if (0 <= x && x <= w)\n                intersections.push.apply(intersections, [x, y]);\n\n            return intersections;\n        }\n    }\n\n    line(x1, y1, x2, y2, color, width, dash) {\n        const [x1l, y1l, x2l, y2l] = this.line_endpoints(x1, y1, x2, y2);\n        this.segment(x1l, y1l, x2l, y2l, color, width, dash);\n    }\n\n    line_label(x1, y1, x2, y2, color, label) {\n        let [x1l, y1l, x2l, y2l] = this.line_endpoints(x1, y1, x2, y2).map(x => Math.round(x));\n        if (y1l > y2l)\n            [x1l, y1l] = [x2l, y2l];\n\n\n        const offset = 15;\n        let x, y;\n        if (x1l == 0) {\n            x = 0;\n            y = y1l;\n        } else if (x1l == this.width()) {\n            x = this.width() - offset;\n            y = y1l;\n        } if (y1l == 0) {\n            x = x1l;\n            y = offset;\n        } else if (y1l == this.height()) {\n            x = x1l;\n            y = this.height() - offset;\n        }\n        this.latex(x + 1, y, label, \"15px Arial\", color);\n    }\n\n    fixRightMargin(x, txt, font) {\n        const ctx = this.context();\n        ctx.font = font;\n        const metrics = ctx.measureText((0,_latex_js__WEBPACK_IMPORTED_MODULE_0__.removeLaTeX)(txt));\n        const width = metrics.width;\n        if (x + metrics.width > this.width())\n            x -= (x + metrics.width - this.width());\n        return x;\n    }\n\n    latex(x, y, txt, font, color) {\n        font = font || \"15px Arial\";\n        x = this.fixRightMargin(x, txt, font);\n\n        function reduceFont(font, df) {\n            const m = font.match(/^(\\d+)((\\w|\\s)+)$/)\n            const size = parseInt(m[1]);\n            return (size-df) + m[2];\n        }\n\n        const m = (0,_latex_js__WEBPACK_IMPORTED_MODULE_0__.splitSubscript)(txt);\n        if (!m.subscript)\n            return this.text(x, y, txt, font, color);\n        else {\n            const x1 = this.text(x, y, m.text, font, color);\n            const x2 = this.latex(x1, y + 2, m.subscript, reduceFont(font, 2), color);\n            if (!m.rest)\n                return x2;\n            \n            return this.latex(x2, y, m.rest, font, color);\n        }\n    }\n    \n    text(x, y, txt, font, color) {\n        const ctx = this.context();\n        ctx.font = font || \"15px Arial\";\n\n        x = this.fixRightMargin(x, txt, ctx.font);\n        \n        ctx.strokeStyle = 'white';\n        ctx.lineWidth = 3;\n        ctx.lineJoin = \"miter\";\n\tctx.miterLimit = 2;\n        ctx.strokeText(txt, x, y);\n        if (color)\n            ctx.fillStyle = color;\n        ctx.fillText(txt, x, y);\n\n        const metrics = ctx.measureText(txt);\n        const width = metrics.width;\n        return x + width;\n    }\n\n    message(msg) {\n        // this.text(5, 15, msg, \"15px Arial\", \"black\");\n        this._p_status.innerHTML = (0,_latex_js__WEBPACK_IMPORTED_MODULE_0__.laTeX2HTML)(msg);\n        if (msg != \"\") {\n            this._p_status.style.display = \"block\";\n        } else \n            this._p_status.style.display = \"none\";\n    }\n\n    addMessage(msg) {\n        if (this._p_status.innerHTML)\n            this._p_status.innerHTML += \"<br/>\";\n        this._p_status.innerHTML += (0,_latex_js__WEBPACK_IMPORTED_MODULE_0__.laTeX2HTML)(msg);\n    }\n}\n\n\n\n\n//# sourceURL=webpack://ArgoDG/./src/dg/canvas.js?");

/***/ }),

/***/ "./src/dg/colors.js":
/*!**************************!*\
  !*** ./src/dg/colors.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"getOpacity\": () => (/* binding */ getOpacity),\n/* harmony export */   \"parseRGB\": () => (/* binding */ parseRGB),\n/* harmony export */   \"rgbColor\": () => (/* binding */ rgbColor),\n/* harmony export */   \"setOpacity\": () => (/* binding */ setOpacity)\n/* harmony export */ });\nconst ctx = document.createElement(\"canvas\").getContext(\"2d\");\n\n// read RGB from rgb or rgba string\nfunction parseRGB(str) {\n    const m = str.match(/^rgba?\\s*\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*(,\\s*(\\d+([.]\\d*)?))?\\s*\\)$/i);\n    return m ? {\n        r: parseFloat(m[1]),\n        g: parseFloat(m[2]),\n        b: parseFloat(m[3])\n    } : null;\n}\n\n\n// convert color in any format to rgb\nfunction rgbColor(str){\n    function hexToRGB(hex) {\n        const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n        return result ? {\n            r: parseInt(result[1], 16),\n            g: parseInt(result[2], 16),\n            b: parseInt(result[3], 16)\n        } : null;\n    }\n\n    ctx.fillStyle = str;\n    const color = ctx.fillStyle;\n    if (color[0] == '#')\n        return hexToRGB(color);\n    else\n        return parseRGB(color);\n}\n\n// extract opacity from color string\nfunction getOpacity(color) {\n    const defaultOpacity = 1;\n    \n    if (!color)\n        return defaultOpacity;\n    const m = color.match(/^rgba\\s*\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+([.]\\d*)?)\\s*\\)$/i);\n    return parseFloat(m ? m[4] : defaultOpacity);\n}\n\n// set opacity to color string\nfunction setOpacity(color, o) {\n    const rgb = rgbColor(color);\n    return \"rgba(\" + rgb.r + \", \" + rgb.g + \", \" + rgb.b + \", \" + o + \")\";\n}\n\n\n//# sourceURL=webpack://ArgoDG/./src/dg/colors.js?");

/***/ }),

/***/ "./src/dg/construction.js":
/*!********************************!*\
  !*** ./src/dg/construction.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Construction\": () => (/* binding */ Construction)\n/* harmony export */ });\n/* harmony import */ var _view_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./view.js */ \"./src/dg/view.js\");\n\n\n/**\n * Construction is a list of DGObjects\n */\nclass Construction {\n    constructor() {\n        this._objects = [];\n        this._views = [];\n        this._listeners = [];        \n        this._animation_step = -1;\n    }\n\n    setView(view) {\n        this._views = [view];\n        view.addConstruction(this);\n    }\n\n    addView(view) {\n        this._views.push(view);\n        view.addConstruction(this);\n    }\n\n    addListener(listener) {\n        this._listeners.push(listener);\n    }    \n\n    addObject(o, redraw) {\n        if (!o) return;\n        this._objects.push(o);\n        o.addConstruction(this);\n        if (redraw === undefined || redraw)\n            this.draw();\n    }\n\n    removeObject(o, redraw) {\n        if (!o) return;\n        this._objects = this._objects.filter(obj => obj != o);\n        o.removeConstruction(this);\n        if (redraw === undefined || redraw)\n            this.draw();\n    }\n\n    forEach(fun) {\n        this._objects.forEach(fun);\n    }\n\n    visibleObjects() {\n        let objects = this.animationInProgress() ?\n                      this._objects.slice(0, this._animation_step+1) :\n                      this._objects;\n        return objects.filter(obj => obj.visible());\n    }\n\n    drawView(view) {\n        view.drawObjects(this.visibleObjects());\n        if (this.animationInProgress()) {\n            const currentAnimationObject = this._objects[this._animation_step];\n            view.message(currentAnimationObject.describe());\n        }\n    }\n\n    draw() {\n        this._views.forEach(view => {\n            view.redraw();\n        });            \n    }\n\n    change(redraw) {\n        if (redraw == undefined || redraw)\n            this.draw();\n        this._listeners.forEach(listener => {\n            listener.change(this);\n        });\n    }    \n\n    animationInProgress() {\n        return this._animation_step != -1;\n    }\n\n    doAnimationStep(increment) {\n        do {\n            const n = this._objects.length;\n            this._animation_step = (this._animation_step + n + increment) % n;\n        } while (!this._objects[this._animation_step].visible());\n        this.draw();\n    }\n\n    nextAnimationStep() {\n        this.doAnimationStep(+1);\n    }\n    \n    prevAnimationStep() {\n        this.doAnimationStep(-1);\n    }\n    \n    animate() {\n        var self = this;\n        window.setInterval(function() {\n            self.nextAnimationStep();\n            self.drawAnimationStep();\n        }, 1000);\n    }\n\n\n    highlightAt(x, y, worldToScreen, highlighter) {\n        this._objects.forEach(obj => {\n            if (obj.visible() && obj.isNear(x, y, worldToScreen) && highlighter.shouldHighlight(obj))\n                obj.highlightOn();\n            else\n                obj.highlightOff();\n        });\n    }\n\n    findObjectsAt(x, y, worldToScreen) {\n        return this.visibleObjects().filter(p => p.isNear(x, y, worldToScreen));\n    }\n\n    findFreePointAt(x, y, worldToScreen) {\n        return this.findObjectsAt(x, y, worldToScreen).find(o => o.isFreePoint());\n    }\n    \n    findPointAt(x, y, worldToScreen) {\n        return this.findObjectsAt(x, y, worldToScreen).find(o => o.isPoint());\n    }\n\n    findLineAt(x, y, worldToScreen) {\n        return this.findObjectsAt(x, y, worldToScreen).find(o => o.isLine());\n    }\n\n    findCircleAt(x, y, worldToScreen) {\n        return this.findObjectsAt(x, y, worldToScreen).find(o => o.isCircle());\n    }\n\n    find(label) {\n        return this._objects.find(o => o.label() == label);\n    }\n\n    includes(label) {\n        // this can be faster if all object labels are put in a hash-set  \n        return this._objects.some(o => o.label() == label);\n    }\n}\n\n\n\n\n//# sourceURL=webpack://ArgoDG/./src/dg/construction.js?");

/***/ }),

/***/ "./src/dg/dg.js":
/*!**********************!*\
  !*** ./src/dg/dg.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"If\": () => (/* binding */ If),\n/* harmony export */   \"addObject\": () => (/* binding */ addObject),\n/* harmony export */   \"animate\": () => (/* binding */ animate),\n/* harmony export */   \"animationButtons\": () => (/* binding */ animationButtons),\n/* harmony export */   \"arc\": () => (/* binding */ arc),\n/* harmony export */   \"center\": () => (/* binding */ center),\n/* harmony export */   \"circle\": () => (/* binding */ circle),\n/* harmony export */   \"clone\": () => (/* binding */ clone),\n/* harmony export */   \"construction\": () => (/* binding */ construction),\n/* harmony export */   \"constructionToolbar\": () => (/* binding */ constructionToolbar),\n/* harmony export */   \"container\": () => (/* binding */ container),\n/* harmony export */   \"findCircleAt\": () => (/* binding */ findCircleAt),\n/* harmony export */   \"findFreePointAt\": () => (/* binding */ findFreePointAt),\n/* harmony export */   \"findLineAt\": () => (/* binding */ findLineAt),\n/* harmony export */   \"findObjectsAt\": () => (/* binding */ findObjectsAt),\n/* harmony export */   \"findPointAt\": () => (/* binding */ findPointAt),\n/* harmony export */   \"intersectCC_any\": () => (/* binding */ intersectCC_any),\n/* harmony export */   \"intersectCC_both\": () => (/* binding */ intersectCC_both),\n/* harmony export */   \"intersectCC_select\": () => (/* binding */ intersectCC_select),\n/* harmony export */   \"intersectLC_any\": () => (/* binding */ intersectLC_any),\n/* harmony export */   \"intersectLC_both\": () => (/* binding */ intersectLC_both),\n/* harmony export */   \"intersectLC_select\": () => (/* binding */ intersectLC_select),\n/* harmony export */   \"intersectLL\": () => (/* binding */ intersectLL),\n/* harmony export */   \"line\": () => (/* binding */ line),\n/* harmony export */   \"nextAnimationStep\": () => (/* binding */ nextAnimationStep),\n/* harmony export */   \"num\": () => (/* binding */ num),\n/* harmony export */   \"poincareDiscCircle\": () => (/* binding */ poincareDiscCircle),\n/* harmony export */   \"poincareDiscCircleR\": () => (/* binding */ poincareDiscCircleR),\n/* harmony export */   \"poincareDiscLine\": () => (/* binding */ poincareDiscLine),\n/* harmony export */   \"poincareHalfPlaneCircle\": () => (/* binding */ poincareHalfPlaneCircle),\n/* harmony export */   \"poincareHalfPlaneCircleR\": () => (/* binding */ poincareHalfPlaneCircleR),\n/* harmony export */   \"poincareHalfPlaneLine\": () => (/* binding */ poincareHalfPlaneLine),\n/* harmony export */   \"point\": () => (/* binding */ point),\n/* harmony export */   \"pointFun\": () => (/* binding */ pointFun),\n/* harmony export */   \"prevAnimationStep\": () => (/* binding */ prevAnimationStep),\n/* harmony export */   \"randomPoint\": () => (/* binding */ randomPoint),\n/* harmony export */   \"randomPointOnCircle\": () => (/* binding */ randomPointOnCircle),\n/* harmony export */   \"randomPointOnLine\": () => (/* binding */ randomPointOnLine),\n/* harmony export */   \"removeObject\": () => (/* binding */ removeObject),\n/* harmony export */   \"segment\": () => (/* binding */ segment),\n/* harmony export */   \"setConstruction\": () => (/* binding */ setConstruction),\n/* harmony export */   \"setup\": () => (/* binding */ setup),\n/* harmony export */   \"view\": () => (/* binding */ view)\n/* harmony export */ });\n/* harmony import */ var _objects_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./objects.js */ \"./src/dg/objects.js\");\n/* harmony import */ var _view_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./view.js */ \"./src/dg/view.js\");\n/* harmony import */ var _construction_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./construction.js */ \"./src/dg/construction.js\");\n/* harmony import */ var _animation_buttons_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./animation_buttons.js */ \"./src/dg/animation_buttons.js\");\n/* harmony import */ var _tool_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./tool.js */ \"./src/dg/tool.js\");\n\n\n\n\n\n\n// -----------------------------------------------------------------------------\n// API and a global register of all DGobjects\n// -----------------------------------------------------------------------------\n\nlet _global_construction = new _construction_js__WEBPACK_IMPORTED_MODULE_2__.Construction();\nlet _global_view = null;\n\n// current construction and view (either global or provided by the user)\nlet _construction = _global_construction;\nlet _view = _global_view;\n\nlet _animation_buttons = null;\nlet _construction_toolbar = null;\n\nfunction setup(element, options, xmin, xmax, ymin, ymax) {\n    if (arguments.length == 2)\n        _global_view = new _view_js__WEBPACK_IMPORTED_MODULE_1__.View(element, options);\n    else\n        _global_view = new _view_js__WEBPACK_IMPORTED_MODULE_1__.View(element, options, xmin, xmax, ymin, ymax);\n\n    _construction = _global_construction;\n    _view = _global_view;\n    \n    _construction.setView(_view);\n    _view.setTool(new _tool_js__WEBPACK_IMPORTED_MODULE_4__.ToolDragFree(_view, _construction));\n}\n\nfunction setConstruction(construction) {\n    _construction = construction ? construction : _global_construction;\n    _construction.setView(_view);\n    _view.setConstruction(_construction);\n    _view.setTool(new _tool_js__WEBPACK_IMPORTED_MODULE_4__.ToolDragFree(_view, _construction));\n}\n\nfunction construction() {\n    return _construction;\n}\n\nfunction view() {\n    return _view;\n}\n\nfunction container() {\n    return this.view().canvas().container();\n}\n\nfunction addObject(o, redraw) {\n    _construction.addObject(o, redraw);\n}\n\nfunction removeObject(o, redraw) {\n    _construction.removeObject(o, redraw);\n}\n\nfunction point(x, y, redraw, validity_check) {\n    const p = new _objects_js__WEBPACK_IMPORTED_MODULE_0__.DGPoint(x, y, validity_check);\n    addObject(p, redraw);\n    return p;\n}\n\nfunction randomPoint(redraw, validity_check, xmin, xmax, ymin, ymax) {\n    const p = new _objects_js__WEBPACK_IMPORTED_MODULE_0__.DGRandomPoint(validity_check, xmin, xmax, ymin, ymax);\n    addObject(p, redraw);\n    return p;\n}\n\nfunction randomPointOnCircline(cl, redraw, validity_check, disc) {\n    const p = new _objects_js__WEBPACK_IMPORTED_MODULE_0__.DGRandomPointOnCircline(cl, {\"validity_check\": validity_check, \"disc\": disc});\n    addObject(p, redraw);\n    return p;\n}\n\nfunction randomPointOnLine(line, redraw, validity_check, disc) {\n    return randomPointOnCircline(line, redraw, validity_check, disc);\n}\n\nfunction randomPointOnCircle(circle, redraw, validity_check, disc) {\n    return randomPointOnCircline(circle, redraw, validity_check, disc);\n}\n\nfunction pointFun(fun, dependent, redraw) {\n    const p = new _objects_js__WEBPACK_IMPORTED_MODULE_0__.DGPointFun(fun, dependent);\n    addObject(p, redraw);\n    return p;\n}\n\nfunction line(P1, P2) {\n    const l = new _objects_js__WEBPACK_IMPORTED_MODULE_0__.DGLine(P1, P2);\n    addObject(l);\n    return l;\n}\n\nfunction circle(C, P, redraw) {\n    const c = new _objects_js__WEBPACK_IMPORTED_MODULE_0__.DGCircle(C, P);\n    addObject(c, redraw);\n    return c;\n}\n\nfunction intersectLL(l1, l2, redraw) {\n    const p = new _objects_js__WEBPACK_IMPORTED_MODULE_0__.DGIntersectLL(l1, l2);\n    addObject(p, redraw);\n    return p;\n}\n\nfunction intersectLC(l, c, redraw, includeFictive) {\n    const p = new _objects_js__WEBPACK_IMPORTED_MODULE_0__.DGIntersectLC(l, c, includeFictive);\n    addObject(p, redraw);\n    return p;\n}\n\nfunction intersectLC_both(l, c, redraw, includeFictive) {\n    const i = intersectLC(l, c, redraw, includeFictive);\n    const [p1, p2] = i.both();\n    addObject(p1, false);\n    addObject(p2, redraw);\n    return [p1, p2];\n}\n\nfunction intersectLC_any(l, c, redraw, includeFictive) {\n    const i = intersectLC(l, c, redraw, includeFictive);\n    const p = i.any();\n    addObject(p, redraw);\n    return p;\n}\n\nfunction intersectLC_select(l, c, select_fun, redraw, includeFictive) {\n    const i = intersectLC(l, c, redraw, includeFictive);\n    const p = i.select(select_fun);\n    addObject(p, redraw);\n    return p;\n}\n\nfunction intersectCC(c1, c2, redraw, includeFictive) {\n    const p = new _objects_js__WEBPACK_IMPORTED_MODULE_0__.DGIntersectCC(c1, c2, includeFictive);\n    addObject(p, redraw);\n    return p;\n}\n\nfunction intersectCC_both(c1, c2, redraw, includeFictive) {\n    const i = intersectCC(c1, c2, redraw, includeFictive);\n    const [p1, p2] = i.both();\n    addObject(p1, false);\n    addObject(p2, redraw);\n    return [p1, p2];\n}\n\nfunction intersectCC_any(c1, c2, redraw, includeFictive) {\n    const i = intersectCC(c1, c2, redraw, includeFictive);\n    const p = i.any();\n    addObject(p, redraw);\n    return p;\n}\n\nfunction intersectCC_select(c1, c2, select_fun, redraw, includeFictive) {\n    const i = intersectCC(c1, c2, redraw, includeFictive);\n    const p = i.select(select_fun);\n    addObject(p, redraw);\n    return p;\n}\n\n\nfunction clone(obj, redraw) {\n    const c = new _objects_js__WEBPACK_IMPORTED_MODULE_0__.DGClone(obj);\n    addObject(c, redraw);\n    return c;\n}\n\nfunction If(cond, then_object, else_object, dependencies, redraw) {\n    const p = new _objects_js__WEBPACK_IMPORTED_MODULE_0__.DGIf(cond, then_object, else_object, dependencies);\n    addObject(p, redraw);\n    return p;\n}\n\nfunction center(c, redraw) {\n    const cc = new _objects_js__WEBPACK_IMPORTED_MODULE_0__.DGCircleCenterPoint(c);\n    addObject(cc, redraw);\n    return cc;\n}\n\nfunction poincareDiscLine(p1, p2, redraw) {\n    const l = new _objects_js__WEBPACK_IMPORTED_MODULE_0__.DGPoincareDiscLine(p1, p2);\n    addObject(l, redraw);\n    return l;\n}\n\nfunction poincareDiscCircle(c, p, redraw) {\n    const pc = new _objects_js__WEBPACK_IMPORTED_MODULE_0__.DGPoincareDiscCircle(c, p);\n    addObject(pc, redraw);\n    return pc;\n}\n\nfunction poincareDiscCircleR(c, r, redraw) {\n    const pc = new _objects_js__WEBPACK_IMPORTED_MODULE_0__.DGPoincareDiscCircleR(c, r);\n    addObject(pc, redraw);\n    return pc;\n}\n\nfunction poincareHalfPlaneLine(p1, p2, redraw) {\n    const l = new _objects_js__WEBPACK_IMPORTED_MODULE_0__.DGPoincareHalfPlaneLine(p1, p2);\n    addObject(l, redraw);\n    return l;\n}\n\nfunction poincareHalfPlaneCircle(o, a, redraw) {\n    const c = new _objects_js__WEBPACK_IMPORTED_MODULE_0__.DGPoincareHalfPlaneCircle(o, a);\n    addObject(c, redraw);\n    return c;\n}\n\nfunction poincareHalfPlaneCircleR(c, r, redraw) {\n    const pc = new _objects_js__WEBPACK_IMPORTED_MODULE_0__.DGPoincareHalfPlaneCircleR(c, r);\n    addObject(pc, redraw);\n    return pc;\n}\n\nfunction segment(p1, p2, redraw) {\n    const s = new _objects_js__WEBPACK_IMPORTED_MODULE_0__.DGSegment(p1, p2);\n    addObject(s, redraw);\n    return s;\n}\n\nfunction arc(p1, p, p2, redraw) {\n    const a = new _objects_js__WEBPACK_IMPORTED_MODULE_0__.DGArc(p1, p, p2);\n    addObject(a, redraw);\n    return a;\n}\n\nfunction num(fun, dependencies, redraw) {\n    const n = new _objects_js__WEBPACK_IMPORTED_MODULE_0__.DGNum(fun, dependencies);\n    addObject(n, redraw);\n    return n;\n}\n\nfunction findFreePointAt(x, y, transform) {\n    return _construction.findFreePointAt(x, y, transform);\n}\n    \nfunction findPointAt(x, y, transform) {\n    return _construction.findPointAt(x, y, transform);\n}\n\nfunction findLineAt(x, y, transform) {\n    return _construction.findLineAt(x, y, transform);\n}\n\nfunction findCircleAt(x, y, transform) {\n    return _construction.findCircleAt(x, y, transform);\n}\n\nfunction findObjectsAt(x, y, transform) {\n    return _construction.findObjectsAt(x, y, transform);\n}\n\nfunction nextAnimationStep() {\n    _construction.nextAnimationStep();\n}\n\nfunction prevAnimationStep() {\n    _construction.prevAnimationStep();\n}\n\nfunction animate() {\n    _construction.animate();\n}\n\nfunction animationButtons() {\n    if (!_animation_buttons)\n        _animation_buttons = new _animation_buttons_js__WEBPACK_IMPORTED_MODULE_3__.AnimationButtons(_construction, _view.canvas().container());\n}\n\nfunction constructionToolbar() {\n    if (!_construction_toolbar)\n        _construction_toolbar = new _tool_js__WEBPACK_IMPORTED_MODULE_4__.ConstructionToolbar(_construction, _view, _view.canvas().container());\n}\n\n\n//# sourceURL=webpack://ArgoDG/./src/dg/dg.js?");

/***/ }),

/***/ "./src/dg/latex.js":
/*!*************************!*\
  !*** ./src/dg/latex.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"laTeX2HTML\": () => (/* binding */ laTeX2HTML),\n/* harmony export */   \"normalizeBraces\": () => (/* binding */ normalizeBraces),\n/* harmony export */   \"removeLaTeX\": () => (/* binding */ removeLaTeX),\n/* harmony export */   \"splitSubscript\": () => (/* binding */ splitSubscript)\n/* harmony export */ });\nfunction fixpointReplace(str, re, replacement) {\n    while(true) {\n        const newStr = str.replace(re, replacement);\n        if (newStr == str)\n            return str;\n        str = newStr;\n    }\n}\n\nfunction normalizeBraces(str) {\n    return str ? fixpointReplace(str, /([\\w'()]+)_(\\w)/g, '$1_{$2}') : \"\";\n}\n\nfunction laTeX2HTML(str) {\n    return str ? fixpointReplace(normalizeBraces(str), /([\\w'()]+)_{([\\w<>/]+)}/g, '$1<sub>$2</sub>') : \"\";\n}\n\nfunction removeLaTeX(str) {\n    return str ? fixpointReplace(normalizeBraces(str), /([\\w'()]+)_{(\\w+)}/g, '$1$2') : \"\";\n}\n\nfunction splitSubscript(str) {\n    if (!str)\n        return {};\n\n    str = normalizeBraces(str);\n\n    let i = 0;\n    while (i < str.length && str[i] != \"_\")\n        i++;\n    let result = {text: str.substring(0, i)};\n    i++;\n    let braces = 0;\n    const subscriptStart = i + 1;\n    while (i < str.length) {\n        if (str[i] == '{')\n            braces++;\n        if (str[i] == '}')\n            braces--;\n        if (braces == 0) {\n            const subscriptEnd = i - 1;\n            result.subscript = str.substring(subscriptStart, subscriptEnd + 1);\n            if (i + 1 < str.length)\n                result.rest = str.substring(i+1);\n            return result;\n        }\n        i++;\n    }\n    return result;\n}\n\n\n\n\n//# sourceURL=webpack://ArgoDG/./src/dg/latex.js?");

/***/ }),

/***/ "./src/dg/objects.js":
/*!***************************!*\
  !*** ./src/dg/objects.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DGArc\": () => (/* binding */ DGArc),\n/* harmony export */   \"DGCircle\": () => (/* binding */ DGCircle),\n/* harmony export */   \"DGCircleCenterPoint\": () => (/* binding */ DGCircleCenterPoint),\n/* harmony export */   \"DGClone\": () => (/* binding */ DGClone),\n/* harmony export */   \"DGConst\": () => (/* binding */ DGConst),\n/* harmony export */   \"DGIf\": () => (/* binding */ DGIf),\n/* harmony export */   \"DGIntersectCC\": () => (/* binding */ DGIntersectCC),\n/* harmony export */   \"DGIntersectLC\": () => (/* binding */ DGIntersectLC),\n/* harmony export */   \"DGIntersectLL\": () => (/* binding */ DGIntersectLL),\n/* harmony export */   \"DGLine\": () => (/* binding */ DGLine),\n/* harmony export */   \"DGNum\": () => (/* binding */ DGNum),\n/* harmony export */   \"DGObject\": () => (/* binding */ DGObject),\n/* harmony export */   \"DGPoincareDiscCircle\": () => (/* binding */ DGPoincareDiscCircle),\n/* harmony export */   \"DGPoincareDiscCircleR\": () => (/* binding */ DGPoincareDiscCircleR),\n/* harmony export */   \"DGPoincareDiscLine\": () => (/* binding */ DGPoincareDiscLine),\n/* harmony export */   \"DGPoincareHalfPlaneCircle\": () => (/* binding */ DGPoincareHalfPlaneCircle),\n/* harmony export */   \"DGPoincareHalfPlaneCircleR\": () => (/* binding */ DGPoincareHalfPlaneCircleR),\n/* harmony export */   \"DGPoincareHalfPlaneLine\": () => (/* binding */ DGPoincareHalfPlaneLine),\n/* harmony export */   \"DGPoint\": () => (/* binding */ DGPoint),\n/* harmony export */   \"DGPointFun\": () => (/* binding */ DGPointFun),\n/* harmony export */   \"DGRandomPoint\": () => (/* binding */ DGRandomPoint),\n/* harmony export */   \"DGRandomPointOnCircline\": () => (/* binding */ DGRandomPointOnCircline),\n/* harmony export */   \"DGSegment\": () => (/* binding */ DGSegment),\n/* harmony export */   \"NO_REDRAW\": () => (/* binding */ NO_REDRAW),\n/* harmony export */   \"REDRAW\": () => (/* binding */ REDRAW)\n/* harmony export */ });\n/* harmony import */ var _complex_geom_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../complex_geom.js */ \"./src/complex_geom.js\");\n/* harmony import */ var _colors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./colors.js */ \"./src/dg/colors.js\");\n\n\n\nconst REDRAW = true;\nconst NO_REDRAW = false;\n\n// -----------------------------------------------------------------------------\n// the base class for all geometric objects\n// -----------------------------------------------------------------------------\nclass DGObject {\n    // global number of created objects\n    static num_objects = 0;\n    \n    constructor(construction) {\n        // unique object identifier\n        this._ID = DGObject.num_objects++;\n        \n        // objects dependent on the current one (the ones constructed\n        // using this object)\n        this._dependent_objects = [];\n\n        // some objects can be invalid (e.g., intersection point\n        // selected by some given criteria, when no selection point exists)\n        this._valid = true;\n\n        // style (visibility, color, width, size, dashed, ...)\n        this._style = {};\n\n        // no object is highlighted by default\n        this._style._isHighlighted = false;\n\n        // each object can be a part of one or more constructions\n        this._constructions = [];\n        if (construction)\n            this.addConstruction(construction);\n    }\n\n    addConstruction(construction) {\n        this._constructions.push(construction);\n    }\n\n    removeConstruction(construction) {\n        this._constructions = this._constructions.filter(c => c != construction);\n    }\n\n    type() {\n        return \"object\";\n    }\n\n    valid() {\n        return this._valid;\n    }\n\n    isFreePoint() {\n        return false;\n    }\n\n    isPoint() {\n        return false;\n    }\n\n    isLine() {\n        return false;\n    }\n\n    isCircle() {\n        return false;\n    }\n\n    // fire event that this object has changed\n    fireChangeEvent() {\n        // redraw constructions where this object occurs\n        this._constructions.forEach(construction => {\n            construction.change();\n        });\n    }\n\n    // get or set whole style subobject\n    getStyle() {\n        return this._style;\n    }\n\n    setStyle(style, redraw) {\n        this._style = style;\n        if (redraw === undefined || redraw)\n            this.fireChangeEvent();\n    }\n\n    style(style, redraw) {\n        if (style === undefined)\n            return this.getStyle();\n        this.setStyle(style, redraw);\n        return this;\n    }\n\n    getProperty(prop, defaultValue) {\n        return this._style[prop] !== undefined ? this._style[prop] : defaultValue;\n    }\n\n    setProperty(prop, value, redraw) {\n        if (this._style[prop] === value)\n            return;\n        \n        this._style[prop] = value;\n        if (redraw === undefined || redraw)\n            this.fireChangeEvent();\n    }\n\n    // set object visibility\n    setVisibility(visible, redraw) {\n        this.setProperty(\"_hide\", !visible, redraw);\n    }\n    \n    // set that this object should be visible\n    show(redraw) {\n        this.setVisibility(true, redraw);\n        return this;\n    }\n\n    // set that this object should not be visible\n    hide(redraw) {\n        this.setVisibility(false, redraw);\n        return this;\n    }\n\n    // check if the object is hidden (not visible)\n    hidden() {\n        return this.getProperty(\"_hide\");\n    }\n\n    // check if the object is visible (not hidden)\n    visible() {\n        return !this.hidden();\n    }\n\n    // get or set the color of the object\n    getColor() {\n        // return color that has been set or black otherwise\n        return this.getProperty(\"_color\", \"black\");\n    }\n\n    setColor(c, redraw) {\n        this.setProperty(\"_color\", c, redraw);\n    }\n\n    color(c, redraw) {\n        // if c is undefined get the color\n        if (c === undefined)\n            return this.getColor();\n\n        // otherwise set the color\n        this.setColor(c, redraw);        \n        return this;\n    }\n\n    // get or set opacity of the object\n    getOpacity() {\n        return (0,_colors_js__WEBPACK_IMPORTED_MODULE_1__.getOpacity)(this.color());\n    }\n\n    setOpacity(o, redraw) {\n        this.color((0,_colors_js__WEBPACK_IMPORTED_MODULE_1__.setOpacity)(this.color(), o), redraw);\n    }\n\n    opacity(o, redraw) {\n        // o is undefined get the opacity\n        if (o === undefined)\n            return this.getOpacity();\n\n        // otherwise set the opacity\n        this.setOpacity(o, redraw);\n        return this;\n    }\n\n    // get or set the size of the object (for drawing points)\n    getSize() {\n        // return size that has been set or 1 if it is undefined\n        return this.getProperty(\"_size\", 1);\n    }\n\n    setSize(s, redraw) {\n        this.setProperty(\"_size\", s, redraw);\n    }\n    \n    size(s, redraw) {\n        // if s is undefined get the size\n        if (s === undefined)\n            return this.getSize();\n\n        // otherwise set the size\n        this.setSize(s, redraw);\n        return this;\n    }\n\n    // get or set the line width of the object\n    getWidth() {\n        // return width that has been set or 1 if it is undefined\n        return this.getProperty(\"_width\", 1);\n    }\n\n    setWidth(w, redraw) {\n        this.setProperty(\"_width\", w, redraw);\n    }\n    \n    width(w, redraw) {\n        // w is undefined get the width\n        if (w === undefined)\n            return this.getWidth();\n\n        // otherwise set the width\n        this.setWidth(w, redraw);\n        return this;\n    }\n\n\n    // set dashed pattern\n    dashed(redraw) {\n        this.setProperty(\"_dash\", [8, 4], redraw);\n        return this;\n    }\n\n    // set solid line\n    solid(redraw) {\n        this.setProperty(\"_dash\", [], redraw);\n        return this;\n    }\n\n    // get the dash pattern\n    dash() {\n        return this.getProperty(\"_dash\", []);\n    }\n\n    isDashed() {\n        return this.dash().length > 0;\n    }\n\n    // default label for the object (if label is not set)\n    defaultLabel() {\n        return this.type() + \"(\" + this._ID + \")\";\n    }\n\n    // get/set the label of the object\n    getLabel() {\n        // if the label is not set, get the default label\n        return this.getProperty(\"_label\", this.defaultLabel());\n    }\n\n    setLabel(str, redraw) {\n        this.setProperty(\"_label\", str, redraw);\n    }\n    \n    label(str, redraw) {\n        // str is undefined get the label\n        if (str === undefined)\n            return this.getLabel();\n        \n        // otherwise set the label\n        this.setLabel(str, redraw);\n        return this;\n    }\n\n    // does this object have a non-generic label\n    hasLabel() {\n        return this.getProperty(\"_label\") !== undefined;\n    }\n\n    // set or get label visibility\n    setLabelVisibility(visible, redraw) {\n        this.setProperty(\"_label_visible\", visible, redraw);\n    }\n    \n    showLabel(redraw) {\n        this.setLabelVisibility(true, redraw);\n        return this;\n    }\n\n    hideLabel(redraw) {\n        this.setLabelVisibility(false, redraw);\n        return this;\n    }\n\n    // check if the label should be shown\n    showingLabel() {\n        return this.getProperty(\"_label_visible\", true);\n    }\n\n    // default description for the object (if description is not set)\n    defaultDescription() {\n        return \"\";\n    }\n\n    // get or set the description\n    getDescription() {\n        // if the description is not set - get the default description\n        return this.getProperty(\"_description\", this.defaultDescription());\n    }\n\n    hasDescription() {\n        return this.getProperty(\"_description\") !== undefined;\n    }\n\n    setDescription(desc, redraw) {\n        this.setProperty(\"_description\", desc, redraw);\n    }\n\n    description(desc, redraw) {\n        if (desc === undefined) {\n            // description is not given, so get the description\n            return this.getDescription();\n        } else {\n            // otherwise set the description\n            this.setDescription(desc, redraw);\n            return this;\n        }\n    }\n\n    // append string to the existing description\n    addDescription(desc, redraw) {\n        this.setDescription(this._style._description + desc, redraw);\n    }\n\n    // returns a nice description for the object that might contain a label (if its given)\n    // and description (given or default)\n    describe() {\n        let result;\n        if (this.hasLabel()) {\n            result = this.label();\n            if (this.isPoint())\n                console.log(this.x(), this.y());\n            if (this.hasDescription())\n                result += \": \" + this.description();\n            else\n                result = this.type() + \" \" + result;\n        } else {\n            if (this.description())\n                result = this.description();\n            else\n                result = this.label();\n        }\n        return result;\n    }\n\n    // get or set highlight (that shows that mouse is on the object) \n    isHighlighted() {\n        return this.getProperty(\"_isHighlighted\", false);\n    }\n\n    setHighlight(highlight, redraw) {\n        this.setProperty(\"_isHighlighted\", highlight, redraw);\n    }\n\n    highlightOn(redraw) {\n        this.setHighlight(true, redraw);\n        return this;\n    }\n\n    highlightOff(redraw) {\n        this.setHighlight(false, redraw);\n        return this;\n    }\n\n    // draw object on the given View\n    // this is a template method and the real drawing is done within\n    // the polimorphic drawMe method\n    draw(view) {\n        if (this.hidden())\n            return;\n        if (!this.valid())\n            return;\n        this.drawMe(view);\n        if (this.showingLabel())\n            this.drawLabel(view);\n    }\n\n    // this should be overridden\n    drawMe(view) {\n    }\n\n    // this should be overridden\n    drawLabel(view) {\n    }\n    \n    // Register a DGObject to depend on the current object, so that it\n    // is updated whenever the current object changes\n    addDependent(o) {\n        this._dependent_objects.push(o);\n    }\n\n    // Recaculate the position of all dependent objects when this object changes\n    // this is a template method that handles the order of\n    // recalculations, while the coordinate calculations happen within\n    // the polimorphic recalceMe method\n    recalc() {\n        // a topological sort is performed to determine the optimal\n        // order of recalculation of dependent objects\n\n        // first a BFS traversal is used to calculate the number of objects that \n        // each relevant object depends on (its degree)\n        \n        let queue = {\n            elements: [],\n            start: 0,\n            init: function() {\n                this.elements = [];\n                this.start = 0;\n            },\n            push: function(x) {\n                this.elements.push(x);\n            },\n            empty: function() {\n                return this.start == this.elements.length;\n            },\n            shift() {\n                return this.elements[this.start++];\n            }\n        };\n\n        const n = DGObject.num_objects;\n        const degree = new Array(n).fill(0);\n        const objects = new Array(n).fill(null);\n        \n        function enqueue(obj) {\n            degree[obj._ID]++;\n            if (objects[obj._ID] == null) {\n                objects[obj._ID] = obj;\n                queue.push(obj);\n            }\n        }\n\n        objects[this._ID] = this;\n        this._dependent_objects.forEach(enqueue);\n        while (!queue.empty()) {\n            const obj = queue.shift();\n            obj._dependent_objects.forEach(enqueue);\n        }\n\n        // next the Kahn's algoritm is performed\n        queue.init();\n        queue.push(this._ID);\n        while (!queue.empty()) {\n            const id = queue.shift();\n            objects[id].recalcMe();\n            objects[id]._dependent_objects.forEach(obj => {\n                if (--degree[obj._ID] == 0)\n                    queue.push(obj._ID);\n            });\n        }\n    }\n\n    // this should be overridden\n    recalcMe() {\n    }\n\n    // check if this point is near the given point on the screen\n    // (world-to-screen coordinate transform is given)\n    isNear(x, y, worldToScreen) {\n        return false;\n    }\n    \n    // check if two objects are equal\n    eq(other, eps) {\n        if (this.isPoint() && other.isPoint()) {\n            return this.cp1().eq(other.cp1(), eps);\n        }\n        if (this instanceof DGCircline && other instanceof DGCircline) {\n            if (!this.valid() || !other.valid())\n                return false;\n            return this.circline().eq(other.circline(), eps)\n        }\n        return false;\n    }\n\n    // data used when this object is passed as a function argument in DGPointFun\n    funArg() {\n        return null;\n    }\n\n    // clone\n    clone() {\n        return new DGClone(this);\n    }\n}\n\n// -----------------------------------------------------------------------------\n// clone - shallow copy of object that can have its own style and visibility\n// -----------------------------------------------------------------------------\n\nclass DGClone extends DGObject {\n    constructor(object) {\n        super();\n        this._object = object;\n        this._style = {...this._object.style()};\n        return new Proxy(this, this);\n    }\n\n    type() {\n        return \"clone\";\n    }\n\n    valid() {\n        return this._object.valid();\n    }\n\n    drawMe(view) {\n        const old_style = this._object.style();\n        this._object.style(this._style, NO_REDRAW);\n        this._object.drawMe(view);\n        this._object.style(old_style, NO_REDRAW);\n    }\n\n    drawLabel(view) {\n        const old_style = this._object.style();\n        this._object.style(this._style, NO_REDRAW);\n        this._object.drawLabel(view);\n        this._object.style(old_style, NO_REDRAW);\n    }\n\n    isPoint() {\n        return this._object.isPoint();\n    }\n\n    isFreePoint() {\n        return this._object.isFreePoint();\n    }\n\n    isLine() {\n        return this._object.isLine();\n    }\n\n    isCircle() {\n        return this._object.isCircle();\n    }\n    \n    get(target, prop, receiver) {\n        if (prop in this)\n            return this[prop];\n        else\n            return this._object[prop].bind(this._object);\n    }\n}\n\n// \"free\" numeric constant whose value can be changed that can be used in numeric expressions\nclass DGConst extends DGObject {\n    constructor(value) {\n        super();\n        this.setValue(value);\n    }\n\n    value() {\n        return this._value;\n    }\n\n    funArg() {\n        return this.value();\n    }\n\n    setValue(value, redraw) {\n        this._value = value;\n        // update all dependent objects\n        this.recalc();\n        \n        if (redraw == undefined || redraw)\n            this.fireChangeEvent();\n    }\n}\n\n// numeric expression that can depend on numeric constants, points (i.e., their coordinates) etc.\nclass DGNum extends DGObject {\n    constructor(fun, dependencies) {\n        super();\n        this._fun = fun;\n        this._dependencies = dependencies;\n        \n        dependencies.forEach(obj => {\n            obj.addDependent(this);\n        });\n        this.recalcMe();\n        this.hide(false);\n    }\n\n    value() {\n        return this._value;\n    }\n    \n    funArg() {\n        return this.value();\n    }\n    \n    recalcMe() {\n        this._valid = this._dependencies.every(obj => obj.valid());\n        if (!this._valid)\n            return;\n        const args = this._dependencies.map(obj => obj.funArg());\n        this._value = this._fun(...args);\n        this._valid = isFinite(this._value);\n    }\n}\n\n\n// -----------------------------------------------------------------------------\n// free point\n// -----------------------------------------------------------------------------\n// the point is internally represented by a CP1 object\nclass DGPoint extends DGObject {\n    constructor(x, y, validity_check) {\n        super();\n        \n        this._validity_check = validity_check;\n        this._coords = _complex_geom_js__WEBPACK_IMPORTED_MODULE_0__.CP1.of_xy(x, y);\n        this._valid = !this._validity_check || this._validity_check(this.cp1());\n\n        return this;\n    }\n\n    type() {\n        return \"point\";\n    }\n\n    // fix the point so that it cannot be moved\n    fix() {\n        this._fixed = true;\n        return this;\n    }\n\n    // free the point so that it can be moved\n    unfix() {\n        this._fixed = false;\n        return this;\n    }\n\n    // this is the only class that defines free points (points that\n    // can be moved by using the mouse, unless they are fixed)\n    isFreePoint() {\n        if (this._fixed)\n            return false;\n        return true;\n    }\n\n    // this object is a point\n    isPoint() {\n        return true;\n    }\n\n    // user can constrain this point to satisfy some criteria defined\n    // by the function fun cp1 -> bool\n    validityCheck(fun) {\n        this._validity_check = fun;\n        return this;\n    }\n\n    // trying to move the point to the given position\n    // moving is not allowed if the target position does not satisfy\n    // the validity check\n    moveTo(x, y, redraw) {\n        const cp1 = _complex_geom_js__WEBPACK_IMPORTED_MODULE_0__.CP1.of_xy(x, y);\n        if (!this._validity_check || this._validity_check(cp1)) {\n            // update the internal CP1 object\n            this._coords = cp1;\n            this._valid = true; \n            // update all dependent objects\n            this.recalc();\n\n            if (redraw == undefined || redraw)\n                this.fireChangeEvent();\n            // the point was successfully moved\n            return true;\n        }\n        // the point could not be moved\n        return false;\n    }\n\n    // theoretically, the point can be infinite\n    is_inf() {\n        return this._coords.is_inf();\n    }\n\n    // conversion to complex number (unless infinite)\n    to_complex() {\n        return this._coords.to_complex();\n    }\n\n    // x coordinate (unless infinite)\n    x() {\n        const c = this.to_complex();\n        return c.re();\n    }\n\n    // y coordinate (unless infinite)\n    y() {\n        const c = this.to_complex();\n        return c.im();\n    }\n    \n    // both coordinates (unless infinite)\n    coords() {\n        return this.to_complex().coords();\n    }\n\n    // internal cp1 representation\n    cp1() {\n        return this._coords;\n    }\n\n    funArg() {\n        return this.cp1();\n    }\n\n    // check equality of two points (other can represented by a complex number of cp1)\n    eq(other, eps) {\n        if (other instanceof _complex_geom_js__WEBPACK_IMPORTED_MODULE_0__.CP1)\n            return this.cp1().eq(other, eps);\n        if (other instanceof _complex_geom_js__WEBPACK_IMPORTED_MODULE_0__.Complex)\n            return !this.is_inf() && this.to_complex().eq(other, eps);\n        if (other.isPoint()) {\n            if (!this.valid() || !other.valid())\n                return false;\n            return this.cp1().eq(other.cp1(), eps);\n        }\n        return false;\n    }\n\n    // distance to the other point (unless one of them is infinite)\n    distance(other) {\n        return this.to_complex().sub(other.to_complex()).norm();\n    }\n\n    // check if this point is near the given point on the screen\n    // (world-to-screen coordinate transform is given)\n    isNear(x, y, worldToScreen) {\n        if (!this.valid())\n            return false;\n        const [xt, yt] = worldToScreen ? worldToScreen(this.x(), this.y()) : [x, y];\n        const dist2 = (xt - x)*(xt - x) + (yt - y)*(yt - y);\n        let EPS = 5;\n        EPS *= this.size();\n        return dist2 <= EPS * EPS;\n    }\n\n    // drawing the point on the given View\n    drawMe(view) {\n        if (!this.is_inf()) {\n            if (this.isHighlighted()) {\n                view.point(this.x(), this.y(), {color: (0,_colors_js__WEBPACK_IMPORTED_MODULE_1__.setOpacity)(this.color(), 0.5*this.opacity()), size: 1.5*this.size()});\n            }\n            view.point(this.x(), this.y(), {color: this.color(), size: this.size()});\n            \n        }\n    }\n\n    // drawing the point label on the given View \n    drawLabel(view) {\n        if (!this.is_inf() && this._style._label)\n            view.text(this.x(), this.y(), this._style._label);\n    }\n}\n\n\n// -----------------------------------------------------------------------------\n// functionally dependent point\n// -----------------------------------------------------------------------------\n\nclass DGPointFun extends DGPoint {\n    constructor(fun, dependencies) {\n        super();\n        this._fun = fun;\n        this._dependencies = dependencies;\n        \n        dependencies.forEach(obj => {\n            obj.addDependent(this);\n        });\n        this.recalcMe();\n    }\n\n    // point is not free\n    isFreePoint() {\n        return false;\n    }\n    \n    recalcMe() {\n        this._valid = this._dependencies.every(obj => obj.valid());\n        if (!this._valid)\n            return;\n        \n        const args = this._dependencies.map(obj => obj.funArg());\n        const c = this._fun(...args);\n        if (c instanceof _complex_geom_js__WEBPACK_IMPORTED_MODULE_0__.CP1)\n            this._coords = c;\n        else if (Array.isArray(c))\n            this._coords = new _complex_geom_js__WEBPACK_IMPORTED_MODULE_0__.CP1(new _complex_geom_js__WEBPACK_IMPORTED_MODULE_0__.Complex(c[0], c[1]));\n        else\n            this._coords = new _complex_geom_js__WEBPACK_IMPORTED_MODULE_0__.CP1(c);\n    }\n}\n\n\n\n// -----------------------------------------------------------------------------\n// random point\n// -----------------------------------------------------------------------------\nclass DGRandomPoint extends DGPoint {\n    constructor(validity_check, xmin, xmax, ymin, ymax) {\n        super();\n        \n        xmin = xmin || -1;\n        xmax = xmax || 1;\n        ymin = ymin || -1;\n        ymax = ymax || 1;\n        this._xmin = xmin; this._xmax = xmax;\n        this._ymin = ymin; this._ymax = ymax;\n        this._validity_check = validity_check ? validity_check : (p => true);\n        this.recalcMe();\n    }\n\n    type() {\n        return \"random point\";\n    }\n    \n    // random point is not free\n    isFreePoint() {\n        return false;\n    }\n\n    recalcMe() {\n        const MAX_ITER = 100;\n        let x, y;\n        let i = 0;\n        do {\n            x = this._xmin + Math.random() * (this._xmax - this._xmin);\n            y = this._ymin + Math.random() * (this._ymax - this._ymin);\n            this._coords = new _complex_geom_js__WEBPACK_IMPORTED_MODULE_0__.CP1(new _complex_geom_js__WEBPACK_IMPORTED_MODULE_0__.Complex(x, y));\n            i++;\n        } while (!this._validity_check(this._coords) && i < MAX_ITER);\n        if (i == MAX_ITER) {\n            this._valid = false;\n        } else\n            this._valid = true;\n    }\n}\n\n// -----------------------------------------------------------------------------\n// joint class for circles and lines\n// -----------------------------------------------------------------------------\n\nclass DGCircline extends DGObject {\n    constructor() {\n        super();\n    }\n\n    type() {\n        return \"circline\";\n    }\n\n    drawMe(view) {\n        function doDraw(cl, style) {\n            if (cl._circline.is_line()) {\n                const [p1, p2] = cl._circline.line_points();\n                const [x1, y1] = p1.coords();\n                const [x2, y2] = p2.coords();\n                view.line(x1, y1, x2, y2, style);\n            } else {\n                const c = cl._circline.circle_center();\n                const r = cl._circline.circle_radius();\n                const [x, y] = c.coords();\n                view.circle(x, y, r, style);\n            }\n        }\n        \n        const style = {\n            color: this.color(),\n            width: this.width(),\n            dash: this.dash()\n        };\n        doDraw(this, style);\n        \n        if (this.isHighlighted()) {\n            const style = {\n                color: (0,_colors_js__WEBPACK_IMPORTED_MODULE_1__.setOpacity)(this.color(), 0.5*(0,_colors_js__WEBPACK_IMPORTED_MODULE_1__.getOpacity)(this.color())),\n                width: 3*this.width(),\n                dash: this.dash()\n            };\n            doDraw(this, style);\n        }\n    }\n\n    // drawing the line label on the given View \n    drawLabel(view) {\n        if (this._circline.is_line() && this._style._label) {\n            const [p1, p2] = this._circline.line_points();\n            const [x1, y1] = p1.coords();\n            const [x2, y2] = p2.coords();\n            view.line_label(x1, y1, x2, y2, this.color(), this.label());\n        }\n    }\n\n    // check if this line is near the given point on the screen\n    // (world-to-screen coordinate transform is given)\n    isNear(x, y, worldToScreen) {\n        if (!this.valid())\n            return false;\n        if (!worldToScreen)\n            worldToScreen = (x, y) => [x, y];\n        return this._circline.transform(worldToScreen).on_circline(_complex_geom_js__WEBPACK_IMPORTED_MODULE_0__.CP1.of_xy(x, y));\n    }\n    \n    // return internal representation (FIXME: this should be private)\n    circline() {\n        return this._circline;\n    }\n\n    // return the center of the circline\n    center() {\n        return new DGCircleCenterPoint(this);\n    }\n\n    funArg() {\n        return this.circline();\n    }\n\n    // find intersection of two circlines in cp1 (fictive intersections can be included)\n    static intersect(cl1, cl2, includeFictive) {\n        return cl1.circline().intersect(cl2.circline(), includeFictive);\n    }\n    \n    // find intersection of two lines (infinite point if the lines are parallel)\n    static intersectLL(l1, l2) {\n        const p = DGCircline.intersect(l1, l2, false);\n        if (p.length == 0)\n            return _complex_geom_js__WEBPACK_IMPORTED_MODULE_0__.CP1.inf;\n        if (!p[0].is_inf())\n            return p[0];\n        if (!p[1].is_inf())\n            return p[1];\n        // both points are infinite (lines are parallel)\n        return _complex_geom_js__WEBPACK_IMPORTED_MODULE_0__.CP1.inf;\n    }\n}\n\n// -----------------------------------------------------------------------------\n// straight line between two given points\n// -----------------------------------------------------------------------------\n// internally the line is represented by a CP1 circline (a Hermitean matrix)\nclass DGLine extends DGCircline {\n    // construct a line given the two points\n    constructor(p1, p2) {\n        super();\n        \n        this._p1 = p1;\n        this._p2 = p2;\n        // if any of the two points move, this line must be updated\n        p1.addDependent(this);\n        p2.addDependent(this);\n        // initialize the internal circline representation (Hermitean matrix)\n        this.recalcMe();\n    }\n\n    type() {\n        return \"line\";\n    }\n\n    defaultDescription() {\n        return \"line \" + this._p1.label() + this._p2.label();\n    }\n\n    // recalculate the coordinates\n    recalcMe() {\n        this._valid = this._p1.valid() && this._p2.valid();\n        if (!this._valid)\n            return;\n        this._circline = _complex_geom_js__WEBPACK_IMPORTED_MODULE_0__.Circline.mk_circline3(this._p1.cp1(), this._p2.cp1(), _complex_geom_js__WEBPACK_IMPORTED_MODULE_0__.CP1.inf);\n    }\n\n\n    isLine() {\n        return true;\n    }\n\n    circline() {\n        return this._circline;\n    }\n}\n\n// -----------------------------------------------------------------------------\n// a line segment\n// -----------------------------------------------------------------------------\nclass DGSegment extends DGLine {\n    constructor(p1, p2) {\n        super(p1, p2);\n    }\n\n    type() {\n        return \"segment\";\n    }\n\n    defaultDescription() {\n        return \"segment \" + this._p1.label() + this._p2.label();\n    }\n\n    drawMe(view) {\n        const [x1, y1] = this._p1.coords();\n        const [x2, y2] = this._p2.coords();\n        view.segment(x1, y1, x2, y2, {color: this._style._color, width: this._style._width, dash: this._style._dash});\n    }\n\n    // drawing the segment label on the given View \n    drawLabel(view) {\n        // TODO\n    }\n\n    // FIXME: isNear\n}\n\n// -----------------------------------------------------------------------------\n// a random point on a  circline\n// -----------------------------------------------------------------------------\nclass DGRandomPointOnCircline extends DGPoint {\n    constructor(l, params) {\n        super();\n        if (params === undefined)\n            params = {};\n        \n        this._line = l;\n        this._validity_check = params.validity_check ? params.validity_check : p => true;\n        this._disc = params.disc;\n        // if the line moves, this point must be updated\n        l.addDependent(this);\n        // initialize (randomly) the point coordinates\n        this.recalcMe();\n        // fix the point so that it cannot be moved\n        this.fix();\n    }\n\n    type() {\n        return \"point on circline\";\n    }\n\n    // point on circline is not free\n    isFreePoint() {\n        return false;\n    }\n\n    // recalculate the coordinates\n    recalcMe() {\n        this._valid = this._line.valid();\n        if (!this._valid)\n            return;\n        const MAX_ITER = 100;\n        let iter = 0;\n        do {\n            if (this._disc)\n                this._coords = this._line.circline().random_point_in_disc(this._disc);\n            else\n                this._coords = this._line.circline().random_point();\n            iter++;\n        } while ((this._coords === null || !this._validity_check(this._coords)) && iter < MAX_ITER);\n        if (!this._coords || iter == MAX_ITER) {\n            this._valid = false;\n        }\n    }\n}\n\n// -----------------------------------------------------------------------------\n// a circle with a given center and point\n// -----------------------------------------------------------------------------\n// internally the line is represented by a CP1 circline (a Hermitean matrix)\nclass DGCircle extends DGCircline {\n    constructor(c, p) {\n        super();\n        \n        this._c = c;\n        this._p = p;\n        // if any of the two points move, this line must be updated\n        c.addDependent(this);\n        p.addDependent(this);\n        // initialize the internal circline representation (Hermitean matrix)\n        this.recalcMe();\n    }\n\n    type() {\n        return \"circle\";\n    }\n\n    defaultDescription() {\n        return \"circle c(\" + this._c.label() + \", \" + this._p.label() + \")\";\n    }\n\n    // this is a circle\n    isCircle() {\n        return true;\n    }\n\n    // recalculate the coordinates\n    recalcMe() {\n        this._valid = this._c.valid() && this._p.valid();\n        if (!this._valid)\n            return;\n        this._r = this._c.distance(this._p);\n        this._circline = _complex_geom_js__WEBPACK_IMPORTED_MODULE_0__.Circline.mk_circle(this._c.to_complex(), this._r);\n    }\n\n    // check if the given CP1 object lies in the current circle disc (boundary excluded)\n    inDisc(p) {\n        return this._circline.in_disc(p);\n    }\n\n    // check if the point (x, y) lies in the current circle disc (boundary excluded)\n    inDiscXY(x, y) {\n        return this.inDisc(_complex_geom_js__WEBPACK_IMPORTED_MODULE_0__.CP1.of_xy(x, y));\n    }\n\n    // check if the given CP1 object lies on the current circle\n    onCircle(p) {\n        return this._circline.on_circline(p);\n    }\n\n    // check if the point (x, y) lies on the current circle\n    onCircleXY(x, y) {\n        return this.onCircle(_complex_geom_js__WEBPACK_IMPORTED_MODULE_0__.CP1.of_xy(x, y));\n    }\n}\n\n// -----------------------------------------------------------------------------\n// Circular arc\n// -----------------------------------------------------------------------------\n\nclass DGArc extends DGCircline {\n    constructor(p1, p, p2) {\n        super();\n        this._p1 = p1;\n        this._p = p;\n        this._p2 = p2;\n        p1.addDependent(this);\n        p.addDependent(this);\n        p2.addDependent(this);\n        this.recalcMe();\n    }\n\n    type() {\n        return \"arc\";\n    }\n    \n    recalcMe() {\n        this._valid = this._p1.valid() && this._p.valid() && this._p2.valid();\n        if (!this._valid)\n            return;\n        this._circline = _complex_geom_js__WEBPACK_IMPORTED_MODULE_0__.Circline.mk_circline3(this._p1, this._p, this._p2);\n    }\n\n    drawMe(view) {\n        function canonAngle(alpha) {\n            const k = Math.floor((alpha + Math.PI) / (2 * Math.PI));\n            let res = alpha - 2*k*Math.PI;\n            if (res < 0)\n                res += 2*Math.PI;\n            return res;\n        }\n        \n        function doDraw(cl, style) {\n            if (cl._circline.is_line()) {\n                const [x1, y1] = cl._p1.coords();\n                const [x, y] = cl._p.coords();\n                const [x2, y2] = cl._p2.coords();\n                if (_complex_geom_js__WEBPACK_IMPORTED_MODULE_0__.Circline.between(cl._p1, cl._p, cl._p2))\n                    view.segment(x1, y1, x2, y2, style);\n                else\n                    view.segment_complement(x1, y1, x2, y2, style);\n            } else {\n                const c = cl._circline.circle_center();\n                const r = cl._circline.circle_radius();\n                const a1 = -cl._p1.cp1().to_complex().sub(c).arg();\n                const a = -cl._p.cp1().to_complex().sub(c).arg();\n                const a2 = -cl._p2.cp1().to_complex().sub(c).arg();\n                const [x, y] = c.coords();\n                view.arc(x, y, r, a1, a2, canonAngle(a2 - a1) < canonAngle(a - a1), style);\n            }\n        }\n        doDraw(this, {color: this.color(), width: this.width(), dash: this.dash()});\n    }\n}\n\n// -----------------------------------------------------------------------------\n// center of the given circle\n// -----------------------------------------------------------------------------\nclass DGCircleCenterPoint extends DGPoint {\n    constructor(c) {\n        super();\n        \n        this._circle = c;\n        // if the circle moves, this point must be updated\n        c.addDependent(this);\n        // initialize center coordinates\n        this.recalcMe();\n    }\n\n    type() {\n        return \"circle center\";\n    }\n\n    // circle center point is not free\n    isFreePoint() {\n        return false;\n    }\n\n    defaultDescription() {\n        return \"center of \" + this._circle.label();\n    }\n\n    // recalculate the coordinates\n    recalcMe() {\n        this._valid = this._circle.valid();\n        if (!this._valid)\n            return;\n        this._coords = this._circle.circline().center();\n    }\n}\n\n// -----------------------------------------------------------------------------\n// intersection of two lines\n// -----------------------------------------------------------------------------\n// a finte CP1 point, unless lines are parallel\nclass DGIntersectLL extends DGPoint {\n    constructor(l1, l2) {\n        super();\n        this._l1 = l1;\n        this._l2 = l2;\n        // if any of the two line line changes, the intersection must be updated\n        l1.addDependent(this);\n        l2.addDependent(this);\n\n        // initialize the coordinates of the intersection\n        this.recalcMe();\n    }\n\n    type() {\n        return \"intersectLL\";\n    }\n\n    defaultDescription() {\n        return \"intersection of \" + this._l1.label() + \" and \" + this._l2.label();\n    }\n\n    // although the intersection is a point, it is not a free point\n    isFreePoint() {\n        return false;\n    }\n\n    // recalculate the coordinates\n    recalcMe() {\n        this._valid = this._l1.valid() && this._l2.valid();\n        if (!this._valid)\n            return;\n\n        this._coords = DGCircline.intersectLL(this._l1, this._l2);\n    }\n}\n\n\n// -----------------------------------------------------------------------------\n// object that represents the set of all intersection points between two\n// geometric objects (e.g. a line and a circle, or two circles)\n// -----------------------------------------------------------------------------\nclass DGIntersections extends DGObject {\n    constructor() {\n        super();\n        this.hide(false);\n    }\n\n    type() {\n        return \"intersections\";\n    }\n    \n    // creates a single intersection point based on the given\n    // selection criterion cp1 -> bool\n    intersectionPoint(selectionCriterion) {\n        const p = new DGIntersectPoint(this, selectionCriterion, this.description());\n        // if this set of all intersection points changes, then the\n        // single selected intersection point must be updated\n        this.addDependent(p);\n        return p;\n    }\n\n    // return any intersection point\n    any() {\n        return this.intersectionPoint(p => true);\n    }\n\n    // return both intersection points\n    both() {\n        return [this.intersectionPoint(0), this.intersectionPoint(1)];\n    }\n\n    // return any point that satisfies the given criterion (the point\n    // is invalid if no intersections satisfy the given criterion)\n    select(selectionFun, redraw) {\n        return this.intersectionPoint(selectionFun, redraw);\n    }\n\n    // perform the selection based on the given criterion (this method\n    // is called by the single intersection point objects)\n    selectPoint(selectionCriterion) {\n        if (typeof selectionCriterion == \"function\") {\n            const selected = this._intersections.filter(selectionCriterion);\n            if (selected.length > 0)\n                return selected[0];\n            return null;\n        }\n        \n        if (typeof selectionCriterion == \"number\") {\n            if (this._intersections.length <= selectionCriterion)\n                return null;\n            return this._intersections[selectionCriterion];\n        }\n\n        throw \"Unknown criterion\";\n    }\n\n    isNear(x, y, worldToScreen) {\n        // FIXME: perform the check\n        return false;\n    }\n}\n\n// -----------------------------------------------------------------------------\n// all intersections of two circlines\n// -----------------------------------------------------------------------------\nclass DGIntersect extends DGIntersections {\n    constructor(cl1, cl2, includeFictive) {\n        super();\n        this._cl1 = cl1;\n        this._cl2 = cl2;\n        this._includeFictive = includeFictive;\n        // if the circle or the line changes, the intersection must be updated\n        cl1.addDependent(this);\n        cl2.addDependent(this);\n        // initialize the intersection coordinates\n        this.recalcMe();\n    }\n\n    type() {\n        return \"intersect circlines\";\n    }\n\n    defaultDescription() {\n        return \"intersection of \" + this._cl1.label() + \" and \" + this._cl2.label();\n    }\n\n    // recalculate the coordinates\n    recalcMe() {\n        this._valid = this._cl1.valid() && this._cl2.valid();\n        if (!this._valid)\n            return;\n        this._intersections = DGCircline.intersect(this._cl1, this._cl2, this._includeFictive);\n    }\n}\n\n// -----------------------------------------------------------------------------\n// all intersections of line and circle\n// -----------------------------------------------------------------------------\nclass DGIntersectLC extends DGIntersect {\n    constructor(l, c, includeFictive) {\n        super(l, c, includeFictive);\n    }\n}\n\nclass DGIntersectCL extends DGIntersect {\n    constructor(c, l, includeFictive) {\n        super(c, l, includeFictive);\n    }\n}\n\n// -----------------------------------------------------------------------------\n// all intersections of two circles\n// -----------------------------------------------------------------------------\nclass DGIntersectCC extends DGIntersect {\n    constructor(c1, c2, includeFictive) {\n        super(c1, c2, includeFictive);\n    }\n}\n\n// -----------------------------------------------------------------------------\n// a single intersection point selected from the set of all intersection points\n// by some criteria\n// -----------------------------------------------------------------------------\nclass DGIntersectPoint extends DGPoint {\n    constructor(intersections, selectionCriterion, description) {\n        super();\n        this._intersections = intersections;\n        this._selectionCriterion = selectionCriterion;\n        this.description(description, false);\n        \n        // initialize the coordinates\n        this.recalcMe();\n    }\n\n    type() {\n        return \"intersection point\";\n    }\n\n    // although this is a single point, it is not free\n    isFreePoint() {\n        return false;\n    }\n\n    // change the selection criterion\n    setSelectionCriterion(selectionCriterion) {\n        this._selectionCriterion = selectionCriterion;\n        this.recalc();\n    }\n\n    // get the selection criterion\n    getSelectionCriterion(selectionCriterion) {\n        return this._selectionCriterion;\n    }\n    \n    // recalculate the coordinates\n    recalcMe() {\n        // if no point satisfies the selection criterion, then this point is invalid\n        this._valid = this._intersections.valid();\n        if (!this._valid)\n            return;\n        this._coords = this._intersections.selectPoint(this._selectionCriterion);\n        this._valid = this._coords != null;\n    }\n}\n\n// -----------------------------------------------------------------------------\n// condition\n// -----------------------------------------------------------------------------\n\nclass DGIf extends DGObject {\n    constructor(condition, thenObject, elseObject, dependencies) {\n        super();\n        this._condition = condition;\n        // both subobjects should be hidden\n        this._thenObject = thenObject.hide(NO_REDRAW);\n        this._elseObject = elseObject.hide(NO_REDRAW);\n        this._dependencies = dependencies;\n        thenObject.addDependent(this);\n        elseObject.addDependent(this);\n        dependencies.forEach(o => o.addDependent(this));\n        this.recalcMe();\n        return new Proxy(this, this);\n    }\n\n    get(target, prop, receiver) {\n        if (prop in this)\n            return this[prop];\n        else\n            return this._object[prop].bind(this._object);\n    }\n\n    isPoint() {\n        return this._object.isPoint();\n    }\n\n    isLine() {\n        return this._object.isLine();\n    }\n    \n    isCircle() {\n        return this._object.isCircle();\n    }\n\n    type() {\n        return \"if\";\n    }\n\n    // both subobjects must be hidden, and DGIf has its own visibility\n    hidden() {\n        return super.getProperty(\"_hide\");\n    }\n\n    setVisibility(visible, redraw) {\n        super.setProperty(\"_hide\", !visible, redraw);\n    }\n\n    // other properties are delegated to subobjects\n    getProperty(prop, defaultValue) {\n        return this._object.getProperty(prop, defaultValue);\n    }\n\n    setProperty(prop, value, redraw) {\n        this._thenObject.setProperty(prop, value, NO_REDRAW);\n        this._elseObject.setProperty(prop, value, redraw);\n    }\n\n    getStyle() {\n        return this._object.style();\n    }\n\n    setStyle(style, redraw) {\n        this._thenObject.setStyle(style, NO_REDRAW);\n        this._elseObject.setStyle(style, redraw);\n    }\n\n    funArg() {\n        return this._object.funArg();\n    }\n\n    valid() {\n        return this._valid && this._object.valid();\n    }\n    \n    isNear(x, y, worldToScreen) {\n        return this._object.isNear(x, y, worldToScreen);\n    }\n    \n    eq(other, eps) {\n        return this._object.eq(other, eps);\n    }\n\n\n    drawMe(view) {\n        this._object.drawMe(view);\n    }\n\n    drawLabel(view) {\n        this._object.drawLabel(view);\n    }\n\n    recalcMe() {\n        this._valid = this._dependencies.every(obj => obj.valid());\n\n        if (!this._valid || this._condition(...this._dependencies)) {\n            this._object = this._thenObject;\n        } else {\n            this._object = this._elseObject;\n        }\n        \n        this._valid = this._valid && this._object.valid();\n    }\n}\n\n// -----------------------------------------------------------------------------\n// Poincare disc elements\n// -----------------------------------------------------------------------------\n\nclass DGPoincareDiscLine extends DGCircline {\n    constructor(p1, p2) {\n        super();\n        this._p1 = p1;\n        this._p2 = p2;\n        // if any of the two points move, this line must be updated\n        p1.addDependent(this);\n        p2.addDependent(this);\n        // initialize the internal circline representation (Hermitean matrix)\n        this.recalcMe();\n    }\n\n    type() {\n        return \"Poincare line\";\n    }\n\n    defaultDescription() {\n        return \"Poincare line \" + this._p1.label() + this._p2.label();\n    }\n\n    recalcMe() {\n        this._valid = this._p1.valid() && this._p2.valid();\n        if (!this._valid)\n            return;\n        const u = this._p1.cp1().to_complex();\n        const v = this._p2.cp1().to_complex();\n        this._circline = _complex_geom_js__WEBPACK_IMPORTED_MODULE_0__.PoincareDisc.mk_line(u, v);\n    }\n}\n\nclass DGPoincareDiscCircleR extends DGCircline {\n    constructor(c, r) {\n        super();\n        this._c = c;\n        this._r = r;\n        // if the center moves, this circle must be updated\n        c.addDependent(this);\n        // if r is symbolic and it changes, this circle must be updated\n        if (r instanceof DGNum)\n            r.addDependent(this);\n        // initialize the circline\n        this.recalcMe();\n    }\n\n    type() {\n        return \"Poincare circle\";\n    }\n\n    defaultDescription() {\n        return \"Poincare circle c(\" + this._c.label() + \", \" + this.r() + \")\";\n    }\n\n    r() {\n        return this._r instanceof DGNum ? this._r.value() : this._r;\n    }\n\n    recalcMe() {\n        this._valid = this._c.valid() && (!(this._r instanceof DGNum) || this._r.valid());\n        if (!this._valid)\n            return;\n        const r = this.r();\n        if (r <= 0) {\n            this._valid = false;\n            return;\n        }\n        const u = this._c.cp1().to_complex();\n        this._circline = _complex_geom_js__WEBPACK_IMPORTED_MODULE_0__.PoincareDisc.mk_circle(u, r);\n    }\n}\n\nclass DGPoincareDiscCircle extends DGPoincareDiscCircleR {\n    constructor(c, p) {\n        function r(c, p) {\n            const u = c.to_complex();\n            const v = p.to_complex();\n            return _complex_geom_js__WEBPACK_IMPORTED_MODULE_0__.PoincareDisc.hdist(u, v);\n        }\n        super(c, new DGNum((c, p) => r(c, p), [c, p]));\n        // if the point p moves, this circle must be updated\n        this._p = p;\n        p.addDependent(this);\n        // initialize the circline\n        this.recalcMe();\n    }\n\n    type() {\n        return \"Poincare circle\";\n    }\n\n    defaultDescription() {\n        return \"Poincare circle c(\" + this._c.label() + \", \" + this._p.label() + \")\";\n    }\n}\n\n// -----------------------------------------------------------------------------\n// Poincare upper half plane elements\n// -----------------------------------------------------------------------------\n\nclass DGPoincareHalfPlaneLine extends DGCircline {\n    constructor(p1, p2) {\n        super();\n        this._p1 = p1;\n        this._p2 = p2;\n        // if any of the two points move, this line must be updated\n        p1.addDependent(this);\n        p2.addDependent(this);\n        // initialize the internal circline representation (Hermitean matrix)\n        this.recalcMe();\n    }\n\n    type() {\n        return \"Poincare line\";\n    }\n\n    defaultDescription() {\n        return \"Poincare line \" + this._p1.label() + this._p2.label();\n    }\n\n    recalcMe() {\n        this._valid = this._p1.valid() && this._p2.valid();\n        if (!this._valid)\n            return;\n        const u = this._p1.cp1().to_complex();\n        const v = this._p2.cp1().to_complex();\n        this._circline = _complex_geom_js__WEBPACK_IMPORTED_MODULE_0__.PoincareHalfPlane.mk_line(u, v);\n    }\n}\n\nclass DGPoincareHalfPlaneCircleR extends DGCircline {\n    constructor(c, r) {\n        super();\n        this._c = c;\n        this._r = r;\n        // if the center moves, this circle must be updated\n        c.addDependent(this);\n        // if r is symbolic and it changes, this circle must be updated\n        if (r instanceof DGNum)\n            r.addDependent(this);\n        // initialize the circline\n        this.recalcMe();\n    }\n\n    type() {\n        return \"Poincare circle\";\n    }\n\n    defaultDescription() {\n        return \"Poincare circle c(\" + this._c.label() + \", \" + this.r() + \")\";\n    }\n\n    r() {\n        return this._r instanceof DGNum ? this._r.value() : this._r;\n    }\n\n    recalcMe() {\n        this._valid = this._c.valid() && (!(this._r instanceof DGNum) || this._r.valid());\n        if (!this._valid)\n            return;\n        const r = this.r();\n        if (r <= 0) {\n            this._valid = false;\n            return;\n        }\n        const u = this._c.cp1().to_complex();\n        this._circline = _complex_geom_js__WEBPACK_IMPORTED_MODULE_0__.PoincareHalfPlane.mk_circle(u, r);\n    }\n}\n\nclass DGPoincareHalfPlaneCircle extends DGPoincareHalfPlaneCircleR {\n    constructor(c, p) {\n        function r(c, p) {\n            const u = c.to_complex();\n            const v = p.to_complex();\n            return _complex_geom_js__WEBPACK_IMPORTED_MODULE_0__.PoincareHalfPlane.hdist(u, v);\n        }\n        super(c, new DGNum((c, p) => r(c, p), [c, p]));\n        // if the point p moves, this circle must be updated\n        this._p = p;\n        p.addDependent(this);\n        // initialize the circline\n        this.recalcMe();\n    }\n\n    type() {\n        return \"Poincare circle\";\n    }\n\n    defaultDescription() {\n        return \"Poincare circle c(\" + this._c.label() + \", \" + this._p.label() + \")\";\n    }\n}\n\n\n\n\n\n\n//# sourceURL=webpack://ArgoDG/./src/dg/objects.js?");

/***/ }),

/***/ "./src/dg/rc.js":
/*!**********************!*\
  !*** ./src/dg/rc.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"angle_bisector\": () => (/* binding */ angle_bisector),\n/* harmony export */   \"angle_divide\": () => (/* binding */ angle_divide),\n/* harmony export */   \"bisector\": () => (/* binding */ bisector),\n/* harmony export */   \"circle\": () => (/* binding */ circle),\n/* harmony export */   \"circle3_center\": () => (/* binding */ circle3_center),\n/* harmony export */   \"circle_over_segment\": () => (/* binding */ circle_over_segment),\n/* harmony export */   \"drop_perp\": () => (/* binding */ drop_perp),\n/* harmony export */   \"foot\": () => (/* binding */ foot),\n/* harmony export */   \"free\": () => (/* binding */ free),\n/* harmony export */   \"harmonic_conjugate\": () => (/* binding */ harmonic_conjugate),\n/* harmony export */   \"homothety_line\": () => (/* binding */ homothety_line),\n/* harmony export */   \"intersectCC_both\": () => (/* binding */ intersectCC_both),\n/* harmony export */   \"intersectCC_other\": () => (/* binding */ intersectCC_other),\n/* harmony export */   \"intersectLC_both\": () => (/* binding */ intersectLC_both),\n/* harmony export */   \"intersectLC_other\": () => (/* binding */ intersectLC_other),\n/* harmony export */   \"intersectLL\": () => (/* binding */ intersectLL),\n/* harmony export */   \"line\": () => (/* binding */ line),\n/* harmony export */   \"midpoint\": () => (/* binding */ midpoint),\n/* harmony export */   \"other_tangent\": () => (/* binding */ other_tangent),\n/* harmony export */   \"parallel\": () => (/* binding */ parallel),\n/* harmony export */   \"point\": () => (/* binding */ point),\n/* harmony export */   \"points_of_tangency\": () => (/* binding */ points_of_tangency),\n/* harmony export */   \"reflectL\": () => (/* binding */ reflectL),\n/* harmony export */   \"reflectP\": () => (/* binding */ reflectP),\n/* harmony export */   \"segment\": () => (/* binding */ segment),\n/* harmony export */   \"tangents\": () => (/* binding */ tangents),\n/* harmony export */   \"touching_circle\": () => (/* binding */ touching_circle),\n/* harmony export */   \"towards\": () => (/* binding */ towards),\n/* harmony export */   \"triangle\": () => (/* binding */ triangle)\n/* harmony export */ });\n/* harmony import */ var _dg_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dg.js */ \"./src/dg/dg.js\");\n/* harmony import */ var _complex_geom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../complex_geom.js */ \"./src/complex_geom.js\");\n/* harmony import */ var _objects_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./objects.js */ \"./src/dg/objects.js\");\n\n\n\n\n// free point\nfunction point(x, y, redraw) {\n    return _dg_js__WEBPACK_IMPORTED_MODULE_0__.point(x, y, redraw);\n}\n\nconst free = point;\n\n// line AB\n// det: A != B\nfunction line(A, B, redraw) {\n    return _dg_js__WEBPACK_IMPORTED_MODULE_0__.line(A, B, redraw);\n}\n\n// segment AB\n// det: A != B\nfunction segment(A, B, redraw) {\n    return _dg_js__WEBPACK_IMPORTED_MODULE_0__.segment(A, B, redraw);\n}\n\n// intersection of lines l1 and l2\n// non-deg: !parallel(l1, l2)\n// det: l1 != l2\nfunction intersectLL(l1, l2, redraw, includeFictive) {\n    return _dg_js__WEBPACK_IMPORTED_MODULE_0__.intersectLL(l1, l2, redraw, includeFictive);\n}\n\n// both intersections of line l and circle c\n// non-deg: l intersects c\nfunction intersectLC_both(l, c, redraw, includeFictive) {\n    return _dg_js__WEBPACK_IMPORTED_MODULE_0__.intersectLC_both(l, c, redraw, includeFictive);\n}\n\n// other intersection of line l and circle c (different from given point A)\n// non-deg: l intersects c (in two points)\nfunction intersectLC_other(l, c, A, redraw, includeFictive) {\n    const I = _dg_js__WEBPACK_IMPORTED_MODULE_0__.intersectLC_select(l, c, p => !p.eq(A.cp1()), redraw, includeFictive)\n    return I;\n}\n\n// circle centered at C containing A\n// non-deg: C != A\nfunction circle(C, A, redraw) {\n    return _dg_js__WEBPACK_IMPORTED_MODULE_0__.circle(C, A, redraw);\n}\n\n// both intersection of circles c1 and c2\n// non-deg: c1 intersects c2\n// det: c1 != c2\nfunction intersectCC_both(c1, c2, redraw, includeFictive) {\n    return _dg_js__WEBPACK_IMPORTED_MODULE_0__.intersectCC_both(c1, c2, redraw, includeFictive);\n}\n\n// other intersection of circles c1 and c2 (different from the given point A)\n// non-deg: c1 intersects c2 (in two different points)\n// det: c1 != c2\nfunction intersectCC_other(c1, c2, A, redraw, includeFictive) {\n    return _dg_js__WEBPACK_IMPORTED_MODULE_0__.intersectCC_select(c1, c2, p => !p.eq(A.cp1()), redraw, includeFictive);\n}\n\n// bisector of segment AB\n// nondeg: A != B\nfunction bisector(A, B, redraw) {\n    const c1 = circle(A, B, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    const c2 = circle(B, A, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    const [X1, X2] = intersectCC_both(c1, c2, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).map(p => p.hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW));\n    const m = line(X1, X2, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    m.description(\"Bisector of segment \" + A.label() + B.label(), redraw);\n    return m;\n}\n\n\n// midpoint of segment AB\nfunction midpoint(A, B, redraw) {\n    const m = bisector(A, B, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    const l = line(A, B, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    const M = intersectLL(m, l, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    const Mp = _dg_js__WEBPACK_IMPORTED_MODULE_0__.If((A, B) => A.eq(B), _dg_js__WEBPACK_IMPORTED_MODULE_0__.clone(B, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW), M, [A, B], _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    Mp.description(\"Midpoint of segment \" + A.label() + B.label(), redraw);\n    return Mp;\n}\n\n\n// circle over segment AB\n// non-deg: A != B\nfunction circle_over_segment(A, B, redraw) {\n    const l1 = line(A, B, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    const l2 = bisector(A, B, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    const M = intersectLL(l1, l2, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    const c = circle(M, A, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW)\n    c.description(\"Circle over segment \" + A.label() + B.label(), redraw);\n    return c;\n}\n\n// line perpendicular to line l containing point A\nfunction drop_perp(l, A, redraw) {\n    const B = _dg_js__WEBPACK_IMPORTED_MODULE_0__.randomPointOnLine(l, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); // FIXME: diffferent from A\n    const c = circle(A, B, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    const [X1, X2] = intersectLC_both(l, c, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).map(p => p.hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW));\n    const m = bisector(X1, X2, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    m.description(\"Drop perpendicular from point \" + A.label() + \" onto line \" + l.label(), redraw);\n    return m;\n}\n\n// foot of the perpendicular projection of point A onto line l\nfunction foot(l, A, redraw)  {\n    const p = drop_perp(l, A, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    const X = intersectLL(p, l, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    X.description(\"Project point \" + A.label() + \" onto line \" + l.label(), redraw);\n    return X;\n}\n\n// circle centered at point A that touches line l\n// non-deg: A not on l\nfunction touching_circle(A, l, redraw) {\n    const p = drop_perp(l, A, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    const M = intersectLL(p, l, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    const c = circle(A, M, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    c.description(\"Circle centered in \" + A.label() + \" touching line \" + l.label(), redraw);\n    return c;\n}\n\nfunction points_of_tangency(A, c, redraw) {\n    const O = _dg_js__WEBPACK_IMPORTED_MODULE_0__.center(c, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    const c1 = circle_over_segment(O, A, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    const [X1, X2] = intersectCC_both(c, c1, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    const A_on_c = (A, c) => c.circline().on_circline(A);\n    const X = A.clone();\n    return [_dg_js__WEBPACK_IMPORTED_MODULE_0__.If(A_on_c, X, X1, [A, c], redraw), _dg_js__WEBPACK_IMPORTED_MODULE_0__.If(A_on_c, X, X2, [A, c], redraw)];\n}\n\n// both tangents from point A that touch circle c\n// non-deg: A outside c or on c\nfunction tangents(A, c, redraw) {\n    const O = _dg_js__WEBPACK_IMPORTED_MODULE_0__.center(c, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    const c1 = circle_over_segment(O, A, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    const [X1, X2] = intersectCC_both(c, c1, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).map(obj => obj.hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW));\n    const t1 = line(A, X1, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    const t2 = line(A, X2, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    const OA = line(O, A).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    const t = drop_perp(OA, A).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    const A_on_c = (A, c) => c.circline().on_circline(A, 1e-8);\n    return [_dg_js__WEBPACK_IMPORTED_MODULE_0__.If(A_on_c, t, t1, [A, c]), _dg_js__WEBPACK_IMPORTED_MODULE_0__.If(A_on_c, t, t2, [A, c])].map(l => l.description(\n        \"Tangent from point \" + A.label() + \" to circle \" + c.label(), redraw\n    ));\n}\n\n\n\n// tangent from point A that touch circle c, that is different from the given line t\n// non-deg: A outside c\nfunction other_tangent(A, c, t, redraw) {\n    const [t1, t2] = tangents(A, c, false).map(t => t.hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW));\n    const t_ = _dg_js__WEBPACK_IMPORTED_MODULE_0__.If((x, y) => x.eq(y), t2, t1, [t, t1], _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    t_.show(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    t_.description(\"Tangent from point \" + A.label() + \" to circle \" + c.label(), redraw);\n    return t_;\n}\n\n// homothety of a line\nfunction homothety_line() {\n    // TODO\n}\n\n// parallel line to line l that contains point A\nfunction parallel(l, A, redraw) {\n    const n = drop_perp(l, A, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    const p = drop_perp(n, A, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    p.description(\"Parallel to line \" + l.label() + \" containing point \" + A.label(), redraw);\n    return p;\n}\n\n\n// point Z such that XY : XZ = p : q\nfunction towards_aux(X, Y, p, q, redraw) {\n    const pp = Math.abs(p), qq = Math.abs(q);\n    const M = _dg_js__WEBPACK_IMPORTED_MODULE_0__.randomPoint(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    // change M whenever X and Y change\n    X.addDependent(M); Y.addDependent(M);\n    const l = line(X, M, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    const points = [X, M];\n    for (let i = 0; i < Math.max(pp, qq); i++) {\n        const O = points[points.length - 1];\n        const A = points[points.length - 2];\n        const c = circle(O, A, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n        const MM = intersectLC_other(l, c, A, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n        points.push(MM);\n    }\n\n    const p1 = line(Y, points[pp], _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    const p2 = parallel(p1, points[qq], _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    const xy = line(X, Y, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    let Z =  intersectLL(xy, p2, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n\n    if (p*q < 0)\n        Z = reflectP(X, Z, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n\n    return _dg_js__WEBPACK_IMPORTED_MODULE_0__.If((X, Y) => X.eq(Y), _dg_js__WEBPACK_IMPORTED_MODULE_0__.clone(X, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW), Z, [X, Y], redraw).show(redraw);\n}\n\n// point B such that vector AB equals vector XY\nfunction translate_vec(X, Y, A, redraw) {\n    const xy = line(X, Y, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    const xa = line(X, A, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    const p1 = parallel(xy, A, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    const p2 = parallel(xa, Y, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    const B = intersectLL(p1, p2, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    return _dg_js__WEBPACK_IMPORTED_MODULE_0__.If((X, Y) => X.eq(Y),\n                 _dg_js__WEBPACK_IMPORTED_MODULE_0__.clone(A, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW),\n                 _dg_js__WEBPACK_IMPORTED_MODULE_0__.If((X, A) => X.eq(A),\n                       _dg_js__WEBPACK_IMPORTED_MODULE_0__.clone(Y, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW),\n                       B,\n                       [X, A]).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW),\n                 [X, Y], _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).show(redraw);\n}\n\n// point W such that XY : ZW = p : q\nfunction towards(X, Y, Z, p, q, redraw) {\n    const YY = towards_aux(X, Y, p, q, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    const w = translate_vec(X, YY, Z, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    let description;\n    if (X == Z && p == 2 && q == 1)\n        description = \"Midpoint of segment \" + X.label() + Y.label();\n    else if (X == Z && p == 1 && q == 2)\n        description = \"Reflection of point \" + X.label() + \" about point \" + Y.label();\n    else if (X == Z && p == 1 && q == -1)\n        description = \"Reflection of point \" + Y.label() + \" about point \" + X.label();\n    else\n        description = \"Point X such that \" + X.label() + Y.label() + \":\" + Z.label() + \"X\" + \" = \" + p + \":\" + q;\n    w.description(description, redraw);\n    return w;\n}\n\n\n// angle divide\nfunction angle_divide() {\n    // TODO\n}\n\n// a line that bisect the angle BAC\nfunction angle_bisector(B, A, C, redraw) {\n    const k = circle(A, B, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    const c = line(A, B, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    const b = line(A, C, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    const X = _dg_js__WEBPACK_IMPORTED_MODULE_0__.intersectLC_select(b, k, p => _complex_geom_js__WEBPACK_IMPORTED_MODULE_1__.Circline.same_side(p, C, A), _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    const k1 = circle(B, X, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    const k2 = circle(X, B, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    const Y = _dg_js__WEBPACK_IMPORTED_MODULE_0__.intersectCC_any(k1, k2, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    const l = line(A, Y, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    l.description(\"Angle \" + B.label() + A.label() + C.label() + \" bisector\", redraw);\n    return l;\n}\n\n// reflection of point B around point O\nfunction reflectP(O, B, redraw) {\n    const l = line(O, B, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    const c = circle(O, B, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    const BB = intersectLC_other(l, c, B, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    const r = _dg_js__WEBPACK_IMPORTED_MODULE_0__.If((O, B) => O.eq(B), _dg_js__WEBPACK_IMPORTED_MODULE_0__.clone(B, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW), BB, [O, B], _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    r.description(\"Reflect point \" + B.label() + \" about point \" + O.label(), redraw);\n    return r;\n}\n\n// reflection of point A around line l\nfunction reflectL(l, A, redraw) {\n    const p = drop_perp(l, A, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    const M = intersectLL(p, l, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    const c = circle(M, A, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    const AA = intersectLC_other(p, c, A, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    const r = _dg_js__WEBPACK_IMPORTED_MODULE_0__.If((A, M) => A.eq(M), _dg_js__WEBPACK_IMPORTED_MODULE_0__.clone(A, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW), AA, [A, M], _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    r.description(\"Reflect point \" + A.label() + \" about line \" + l.label(), redraw);\n    return r;\n}\n\n// reflection of line l around point O \nfunction reflectP_line(O, l, redraw) {\n    var B1 = _dg_js__WEBPACK_IMPORTED_MODULE_0__.randomPointOnLine(l, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide();\n    var B2 = _dg_js__WEBPACK_IMPORTED_MODULE_0__.randomPointOnLine(l, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW, p => !B1.eq(p)).hide();\n    var B1p = reflectP(O, B1, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    var B2p = reflectP(O, B2, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    var lp = line(B1p, B2p, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    lp.description(\"Reflect line \" + l.label() + \" about point \" + O.label(), redraw);\n    return lp;\n}\n\n// circumcenter of triangle ABC\nfunction circle3_center(A, B, C, redraw) {\n    const ma = bisector(B, C, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    const mb = bisector(A, C, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    const O = intersectLL(ma, mb, redraw);\n    return O;\n}\n\n// point D such that H(A, B, C, D)=-1\n// non-deg: collinear A, B, C and C != A and C != B and C is not midpoint of AB\nfunction harmonic_conjugate(A, B, C, redraw) {\n    const R = _dg_js__WEBPACK_IMPORTED_MODULE_0__.randomPoint(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    A.addDependent(R); B.addDependent(R); C.addDependent(R);\n    const ra = line(R, A, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    const rb = line(R, B, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    const Q = _dg_js__WEBPACK_IMPORTED_MODULE_0__.randomPointOnLine(la, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    const qc = line(Q, C, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    const P = intersectLL(rb, qc, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    const ap = line(A, P, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    const bq = line(B, Q, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    const S = intersectLL(ap, bq, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    const ab = line(A, B, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    const rs = line(R, S, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).hide(_objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW);\n    return intersectLL(ab, rs, redraw);\n}\n\n// all significant points of the triangle\nfunction triangle(A, B, C) {\n    const elements = [A, B, C];\n    // sides\n    const a = line(B, C, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"a\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"black\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).width(2, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(a);\n    const b = line(A, C, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"b\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"black\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).width(2, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(b);\n    const c = line(A, B, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"c\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"black\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).width(2, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(c);\n\n    // side bisectors\n    const ba = bisector(B, C, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"blue\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"b_{a}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(ba);\n    const bb = bisector(A, C, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"blue\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"b_{b}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(bb);\n    const bc = bisector(A, B, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"blue\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"b_{c}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(bc);\n\n    // circumcenter\n    const O = intersectLL(ba, bb, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"blue\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"O\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(O);\n    // circumcircle\n    const o = circle(O, A, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"blue\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(o);\n\n    // side midpoints\n    const Ma = midpoint(B, C, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"green\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"M_{a}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(Ma);\n    const Mb = midpoint(A, C, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"green\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"M_{b}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(Mb);\n    const Mc = midpoint(A, B, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"green\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"M_{c}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(Mc);\n\n    // angle bisectors\n    const ta = angle_bisector(B, A, C, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"orange\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"t_{a}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(ta);\n    const tb = angle_bisector(A, B, C, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"orange\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"t_{b}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(tb);\n    const tc = angle_bisector(B, C, A, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"orange\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"t_{c}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(tc);\n    // incenter\n    const I = intersectLL(ta, tb, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"orange\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"I\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(I);\n\n    // angle bisector feet\n    const Ta = intersectLL(ta, a, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"orange\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"T_{a}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(Ta);\n    const Tb = intersectLL(tb, b, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"orange\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"T_{b}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(Tb);\n    const Tc = intersectLL(tc, c, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"orange\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"T_{c}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(Tc);\n\n    // incenter perpendicular projections onto triangle sides\n    const tpa = drop_perp(a, I, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"Chocolate\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"t'_{a}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(tpa);\n    const tpb = drop_perp(b, I, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"Chocolate\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"t'_{b}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(tpb);\n    const tpc = drop_perp(c, I, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"Chocolate\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"t'_{c}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(tpc);\n\n    // incenter projection feet\n    const Tpa = intersectLL(tpa, a, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"Chocolate\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"T'_{a}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(Tpa);\n    const Tpb = intersectLL(tpb, b, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"Chocolate\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"T'_{b}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(Tpb);\n    const Tpc = intersectLL(tpc, c, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"Chocolate\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"T'_{c}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(Tpc);\n\n    // incircle\n    const i = circle(I, Tpa, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"orange\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"i\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(i);\n\n    // altitudes\n    const ha = drop_perp(a, A, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"red\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"h_{a}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(ha);\n    const hb = drop_perp(b, B, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"red\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"h_{b}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(hb);\n    const hc = drop_perp(c, C, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"red\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"h_{c}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(hc);\n\n    // orthocenter\n    const H = intersectLL(ha, hb, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"red\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"H\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(H);\n\n    // altitude feet\n    const Ha = intersectLL(ha, a, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"red\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"H_{a}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(Ha);\n    const Hb = intersectLL(hb, b, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"red\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"H_{b}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(Hb);\n    const Hc = intersectLL(hc, c, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"red\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"H_{c}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(Hc);\n\n    // circles over triangle sides\n    const ca = circle(Ma, B, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"DimGray\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"c(B, C)\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(ca);\n    const cb = circle(Mb, A, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"DimGray\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"c(A, C)\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(cb);\n    const cc = circle(Mc, A, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"DimGray\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"c(A, B)\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(cc);\n\n    // medians\n    const ma = line(A, Ma, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"green\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"m_{a}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(ma);\n    const mb = line(B, Mb, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"green\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"m_{b}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(mb);\n    const mc = line(C, Mc, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"green\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"m_{c}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(mc);\n\n    // centroid\n    const G = intersectLL(ma, mb, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"green\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"G\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(G);\n\n    // midlines\n    const MaMb = line(Ma, Mb, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"DarkTurquoise\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"MaMb\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(MaMb);\n    const MaMc = line(Ma, Mc, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"DarkTurquoise\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"MaMc\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(MaMc);\n    const MbMc = line(Mb, Mc, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"DarkTurquoise\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"MbMc\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(MbMc);\n\n    // Euler line\n    const e = line(O, H, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"purple\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"e\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(e);\n    // Euler points\n    const Ea = midpoint(A, H, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"purple\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"E_{a}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(Ea);\n    const Eb = midpoint(B, H, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"purple\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"E_{b}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(Eb);\n    const Ec = midpoint(C, H, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"purple\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"E_{c}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(Ec);\n\n    // Euler (nine-point) circle center\n    const N = circle3_center(Ma, Mb, Mc, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"purple\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"N\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(N);\n    // Euler (nine-point) circle\n    const n = circle(N, Ma, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"purple\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"Ec\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(n);\n\n    // Euler circles\n    const cEaA = circle(Ea, A, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"magenta\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(cEaA);\n    const cEbB = circle(Eb, B, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"magenta\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(cEbB);\n    const cEcC = circle(Ec, C, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"magenta\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(cEcC);\n\n    // angle bisector and side bisector intersections\n    const Na = intersectLL(ba, ta, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"N_{a}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"DeepPink\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(Na);\n    const Nb = intersectLL(bb, tb, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"N_{b}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"DeepPink\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(Nb);\n    const Nc = intersectLL(bc, tc, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"N_{c}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"DeepPink\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(Nc);\n\n    const cNaI = circle(Na, I, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"DeepPink\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(cNaI);\n    const cNbI = circle(Nb, I, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"DeepPink\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(cNbI);\n    const cNcI = circle(Nc, I, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"DeepPink\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(cNcI);\n\n    // angle bisector feet projections onto other triangle sides\n    const Ta_b = foot(b, Ta, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"Olive\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"T_{ab}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(Ta_b);\n    const Ta_c = foot(c, Ta, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"Olive\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"T_{ac}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(Ta_c);\n    const cTa = circle(Ta, Ta_b, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"Olive\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"c_{Ta}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(cTa);\n\n    const Tb_a = foot(a, Tb, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"Olive\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"T_{ba}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(Tb_a);\n    const Tb_c = foot(c, Tb, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"Olive\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"T_{bc}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(Tb_c);\n    const cTb = circle(Tb, Tb_a, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"Olive\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"c_{Tb}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(cTb);\n\n    const Tc_a = foot(a, Tc, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"Olive\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"T_{ca}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(Tc_a);\n    const Tc_b = foot(b, Tc, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"Olive\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"T_{cb}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(Tc_b);\n    const cTc = circle(Tc, Tc_a, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"Olive\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"c_{Tc}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(cTc);\n\n\n    // out angle bisectors\n    const sa = drop_perp(ta, A, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"tomato\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"s_{a}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(sa);\n    const sb = drop_perp(tb, B, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"tomato\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"s_{b}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(sb);\n    const sc = drop_perp(tc, C, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"tomato\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"s_{c}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(sc);\n\n    // outcircle centers\n    const Ia = intersectLL(sb, sc, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"tomato\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"I_{a}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(Ia);\n    const Ib = intersectLL(sa, sc, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"tomato\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"I_{b}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(Ib);\n    const Ic = intersectLL(sa, sb, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"tomato\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"I_{c}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(Ic);\n\n    // outcenters perpendicular projections onto triangle sides\n    const Spa = foot(a, Ia, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"tomato\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"S'_{a}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(Spa);\n    const Spb = foot(b, Ib, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"tomato\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"S'_{b}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(Spb);\n    const Spc = foot(c, Ic, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"tomato\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"S'_{b}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(Spc);\n\n    // outcircles\n    const ia = circle(Ia, Spa, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"tomato\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"i_{a}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(ia);\n    const ib = circle(Ib, Spb, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"tomato\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"i_{b}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(ib);\n    const ic = circle(Ic, Spc, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"tomato\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"i_{c}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(ic);\n\n    // out angle bisector feet\n    const Sa = intersectLL(sa, a, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"tomato\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"S_{a}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(Sa);\n    const Sb = intersectLL(sb, b, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"tomato\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"S_{b}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(Sb);\n    const Sc = intersectLL(sc, c, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"tomato\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).label(\"S_{c}\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(Sc);\n\n    // circles over segments formed by inner and outer angle bisector feet\n    const cTaSa = circle_over_segment(Ta, Sa, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"IndianRed\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(cTaSa);\n    const cTbSb = circle_over_segment(Tb, Sb, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"IndianRed\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(cTbSb);\n    const cTcSc = circle_over_segment(Tc, Sc, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"IndianRed\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(cTcSc);\n\n    // some parallel lines :)\n    const IMa = line(I, Ma, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"DarkGray\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).width(1.5, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(IMa);\n    const ASpa = line(A, Spa, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"DarkGray\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).width(1.5, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(ASpa);\n\n    const IMb = line(I, Mb, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"DarkGray\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).width(1.5, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(IMb);\n    const BSpb = line(B, Spb, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"DarkGray\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).width(1.5, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(BSpb);\n\n    const IMc = line(I, Mc, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"DarkGray\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).width(1.5, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(IMc);\n    const CSpc = line(C, Spc, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).color(\"DarkGray\", _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW).width(1.5, _objects_js__WEBPACK_IMPORTED_MODULE_2__.NO_REDRAW); elements.push(CSpc);\n\n    elements.map(obj => obj.hide());\n    return elements;\n}\n\n\n\n\n\n//# sourceURL=webpack://ArgoDG/./src/dg/rc.js?");

/***/ }),

/***/ "./src/dg/tool.js":
/*!************************!*\
  !*** ./src/dg/tool.js ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ConstructionToolbar\": () => (/* binding */ ConstructionToolbar),\n/* harmony export */   \"ToolDragFree\": () => (/* binding */ ToolDragFree)\n/* harmony export */ });\n/* harmony import */ var _view_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./view.js */ \"./src/dg/view.js\");\n/* harmony import */ var _rc_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rc.js */ \"./src/dg/rc.js\");\n/* harmony import */ var _tool_images_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./tool_images.js */ \"./src/dg/tool_images.js\");\n\n\n\n\n// -----------------------------------------------------------------------------\n// highlighting specific objects as the mouse moves over them\n// -----------------------------------------------------------------------------\nclass Highlighter {\n    // this should be overridden\n    shouldHighlight(obj) {\n        return false;\n    }\n}\n\nclass HighlighterFreePoints extends Highlighter {\n    shouldHighlight(obj) {\n        return obj.isFreePoint();\n    }\n}\nconst highlighterFreePoints = new HighlighterFreePoints();\n\nclass HighlighterPoints extends Highlighter  {\n    shouldHighlight(obj) {\n        return obj.isPoint();\n    }\n}\nconst highlighterPoints = new HighlighterPoints();\n\nclass HighlighterLines extends Highlighter  {\n    shouldHighlight(obj) {\n        return obj.isLine();\n    }\n}\nconst highlighterLines = new HighlighterLines();\n\nclass HighlighterCircles extends Highlighter  {\n    shouldHighlight(obj) {\n        return obj.isCircle();\n    }\n}\nconst highlighterCircles = new HighlighterCircles();\n\n\n// -----------------------------------------------------------------------------\n// handling of mouse and keyboard events on a view\n// -----------------------------------------------------------------------------\nclass Tool {\n    constructor(view) {\n        this._view = view;\n    }\n\n    mousemove(x, y, worldToScreen, screenToWorld) {\n    }\n\n    mousedown(x, y, worldToScreen, screenToWorld) {\n    }\n\n    mouseup(x, y, worldToScreen, screenToWorld) {\n    }\n    \n    keydown(e, worldToScreen, screenToWorld) {\n    }\n\n\n    highlightAt(x, y, worldToScreen) {\n        if (!this._highlighter)\n            return;\n        this._construction.highlightAt(x, y, worldToScreen, this._highlighter);\n    }\n\n    getObject() {\n        return undefined;\n    }\n}\n\n\nclass ToolDragFree extends Tool {\n    constructor(view, construction) {\n        super(view);\n\n        this._highlighter = highlighterFreePoints;\n        \n        // mouse button is not yet pressed\n        this._mousedown = false;\n        // point dragged by the mouse\n        this._dragPoint = undefined;\n        // point moved by the keyboard\n        this._keyboardTarget = undefined;\n        // construction whose points can be dragged\n        // (if not specified all existing points free points can be dragged)\n        this._construction = construction;\n    }\n\n    mousemove(x, y, worldToScreen, screenToWorld) {\n        if (this._mousedown && this._dragPoint !== undefined) {\n            const [xw, yw] = screenToWorld(x, y);\n            if (!this._dragPoint.moveTo(xw, yw)) {\n                const N = 10;\n                for (let d = 1; d <= N; d++) {\n                    let ring = [];\n                    for (let x = -d; x <= d; x++)\n                        ring.push([x, -d]);\n                    for (let y = -d+1; y <= d; y++)\n                        ring.push([d, y]);\n                    for (let x = d-1; x >= -d; x--)\n                        ring.push([x, d]);\n                    for (let y = d-1; y >= -d+1; y--)\n                        ring.push([-d, y]);\n\n                    for (let i = 0; i < ring.length; i++) {\n                        const [dx, dy] = ring[i];\n                        const [xw, yw] = screenToWorld(x+dx, y+dy);\n                        if (this._dragPoint.moveTo(xw, yw))\n                            return;\n                    }\n                }\n            }\n        }\n        this.highlightAt(x, y, worldToScreen);\n    }\n\n    mousedown(x, y, worldToScreen, screenToWorld) {\n        this._mousedown = true;\n        this._dragPoint = this._construction.findFreePointAt(x, y, worldToScreen);\n        this._keyboardTarget = this._dragPoint;\n    }\n\n    mouseup(x, y, worldToScreen, screenToWorld) {\n        this._mousedown = false;\n        this._dragPoint = undefined;\n    }\n\n    keydown(e, worldToScreen, screenToWorld) {\n        if (!this._keyboardTarget)\n            return;\n        const p = this._keyboardTarget;\n        let [x, y] = [p.x(), p.y()];\n        let [xt, yt] = worldToScreen(x, y);\n        const eps = 2;\n        if (e.key == \"ArrowRight\") {\n            e.preventDefault();\n            xt += 1;\n        }\n        else if (e.key == \"ArrowLeft\") {\n            e.preventDefault();\n            xt -= 1;\n        }\n        else if (e.key == \"ArrowUp\") {\n            e.preventDefault();\n            yt -= 1;\n        }\n        else if (e.key == \"ArrowDown\") {\n            e.preventDefault();\n            yt += 1;\n        }\n\n        [x, y] = screenToWorld(xt, yt)\n        p.moveTo(x, y);\n    }\n}\n\n\nclass Tool_ConstructObject extends Tool {\n    constructor(view, types, construction, callback) {\n        super(view);\n        this._object = undefined;\n        this._types = types;\n        this._selected = [];\n        this._construction = construction;\n        this._callback = callback;\n\n        this._view.message(\"Select a \" + this.typeName(this._types[0]));\n        this._highlighter = this.highlighter(this._types[0]);\n    }\n\n    typeName(t) {\n        if (t == 'p') return \"point\";\n        if (t == 'l') return \"line\";\n        if (t == 'c') return \"circle\";\n    }\n\n    highlighter(t) {\n        if (t == 'p') return highlighterPoints;\n        if (t == 'l') return highlighterLines;\n        if (t == 'c') return highlighterCircles;\n    }\n\n    mouseup(x, y, worldToScreen, screenToWorld) {\n        let obj;\n        const k = this._selected.length;\n        if (this._types[k] == \"p\")\n            obj = this._construction.findPointAt(x, y, worldToScreen);\n        else if (this._types[k] == \"l\")\n            obj = this._construction.findLineAt(x, y, worldToScreen);\n        else if (this._types[k] == \"c\")\n            obj = this._construction.findCircleAt(x, y, worldToScreen);\n        if (!obj)\n            return;\n\n        this._selected.push(obj);\n        \n        if (this._selected.length == this._types.length) {\n            this._object = this.construct(...this._selected);\n            if (this._callback) {\n                if (Array.isArray(this._object))\n                    this._object.forEach(obj => this._callback(obj));\n                else\n                    this._callback(this._object);\n            }\n            this._selected = [];\n        }\n\n        let msg = \"\";\n        this._selected.forEach((obj, i) => {msg += \"Selected \" + this.typeName(this._types[i]) + \" \" + obj.label() + \". \"});\n        msg += \"Select a \" + this.typeName(this._types[this._selected.length]);\n        this._view.message(msg);\n        this._highlighter = this.highlighter(this._types[this._selected.length]);\n    }\n\n    mousemove(x, y, worldToScreen, screenToWorld) {\n        this.highlightAt(x, y, worldToScreen, screenToWorld);\n    }\n    \n    getObject() {\n        return this._object;\n    }\n}\n\n\nclass ToolLine extends Tool_ConstructObject {\n    constructor(view, construction, callback) {\n        super(view, \"pp\", construction, callback);\n    }\n    \n    construct(p1, p2) {\n        return _rc_js__WEBPACK_IMPORTED_MODULE_1__.line(p1, p2);\n    }\n}\n\nclass ToolMidpoint extends Tool_ConstructObject {\n    constructor(view, construction, callback) {\n        super(view, \"pp\", construction, callback);\n    }\n    \n    construct(p1, p2) {\n        return _rc_js__WEBPACK_IMPORTED_MODULE_1__.midpoint(p1, p2);\n    }\n}\n\nclass ToolBisector extends Tool_ConstructObject {\n    constructor(view, construction, callback) {\n        super(view, \"pp\", construction, callback);\n    }\n    \n    construct(p1, p2) {\n        return _rc_js__WEBPACK_IMPORTED_MODULE_1__.bisector(p1, p2);\n    }\n}\n\nclass ToolCircle extends Tool_ConstructObject {\n    constructor(view, construction, callback) {\n        super(view, \"pp\", construction, callback);\n    }\n    \n    construct(p1, p2) {\n        return _rc_js__WEBPACK_IMPORTED_MODULE_1__.circle(p1, p2);\n    }\n}\n\nclass ToolDropPerp extends Tool_ConstructObject {\n    constructor(view, construction, callback) {\n        super(view, \"pl\", construction, callback);\n    }\n\n    construct(p, l) {\n        return _rc_js__WEBPACK_IMPORTED_MODULE_1__.drop_perp(l, p);\n    }\n}\n\nclass ToolParallel extends Tool_ConstructObject {\n    constructor(view, construction, callback) {\n        super(view, \"pl\", construction, callback);\n    }\n\n    construct(p, l) {\n        return _rc_js__WEBPACK_IMPORTED_MODULE_1__.parallel(l, p);\n    }\n}\n\nclass ToolIntersectLL extends Tool_ConstructObject {\n    constructor(view, construction, callback) {\n        super(view, \"ll\", construction, callback);\n    }\n\n    construct(l1, l2) {\n        return _rc_js__WEBPACK_IMPORTED_MODULE_1__.intersectLL(l1, l2);\n    }\n}\n\nclass ToolIntersectLC extends Tool_ConstructObject {\n    constructor(view, construction, callback) {\n        super(view, \"lcp\", construction, callback);\n    }\n\n    construct(l, c, p) {\n        return _rc_js__WEBPACK_IMPORTED_MODULE_1__.intersectLC_other(l, c, p);\n    }\n}\n\nclass ToolIntersectLCBoth extends Tool_ConstructObject {\n    constructor(view, construction, callback) {\n        super(view, \"lc\", construction, callback);\n    }\n\n    construct(l, c) {\n        return _rc_js__WEBPACK_IMPORTED_MODULE_1__.intersectLC_both(l, c);\n    }\n}\n\nclass ToolIntersectCC extends Tool_ConstructObject {\n    constructor(view, construction, callback) {\n        super(view, \"ccp\", construction, callback);\n    }\n\n    construct(c1, c2, p) {\n        return _rc_js__WEBPACK_IMPORTED_MODULE_1__.intersectCC_other(c1, c2, p);\n    }\n}\n\nclass ToolIntersectCCBoth extends Tool_ConstructObject {\n    constructor(view, construction, callback) {\n        super(view, \"cc\", construction, callback);\n    }\n\n    construct(c1, c2, p) {\n        return _rc_js__WEBPACK_IMPORTED_MODULE_1__.intersectCC_both(c1, c2);\n    }\n}\n\n\nclass ConstructionToolbar {\n    constructor(construction, view, element, callback) {\n        this._construction = construction;\n        this._view = view;\n        this._tool_callback = callback;\n        \n        const divTools = document.createElement(\"div\");\n        element.prepend(divTools);\n        \n        const self = this;\n        \n        function createButton(title, src, onClick) {\n            const img = document.createElement(\"img\");\n            img.style.border = \"1px solid #555\";\n            img.style.borderRadius = \"5px\";\n            img.style.margin = \"1px\";\n            img.style.width = \"32px\";\n            img.src = src;\n            img.title = title;\n            img.addEventListener(\"click\", function() {\n                [...divTools.getElementsByTagName(\"img\")].forEach(img => { img.style.filter = \"brightness(100%)\"; });\n                img.style.filter = \"brightness(80%)\";\n                onClick();\n            });\n            divTools.append(img);\n        }\n\n        \n        createButton(\"drag free points\", _tool_images_js__WEBPACK_IMPORTED_MODULE_2__.drag, function() {\n            self._view.message(\"\");\n            self.setTool(new ToolDragFree(self._view, self._construction));\n        });\n\n        createButton(\"line\", _tool_images_js__WEBPACK_IMPORTED_MODULE_2__.line, function() {\n            self.setTool(new ToolLine(self._view, self._construction, self._tool_callback));\n        });\n\n        createButton(\"circle\", _tool_images_js__WEBPACK_IMPORTED_MODULE_2__.circle, function() {\n            self.setTool(new ToolCircle(self._view, self._construction, self._tool_callback));\n        });\n\n        createButton(\"midpoint\", _tool_images_js__WEBPACK_IMPORTED_MODULE_2__.midpoint, function() {\n            self.setTool(new ToolMidpoint(self._view, self._construction, self._tool_callback));\n        });\n\n        createButton(\"segment bisector\", _tool_images_js__WEBPACK_IMPORTED_MODULE_2__.bisector, function() {\n            self.setTool(new ToolBisector(self._view, self._construction, self._tool_callback));\n        });\n\n        createButton(\"drop perpendicular\", _tool_images_js__WEBPACK_IMPORTED_MODULE_2__.perp, function() {\n            self.setTool(new ToolDropPerp(self._view, self._construction, self._tool_callback));\n        });\n\n        createButton(\"parallel\", _tool_images_js__WEBPACK_IMPORTED_MODULE_2__.parallel, function() {\n            self.setTool(new ToolParallel(self._view, self._construction, self._tool_callback));\n        });\n\n        divTools.append(document.createElement(\"br\"));\n        \n        createButton(\"intersect two lines\", _tool_images_js__WEBPACK_IMPORTED_MODULE_2__.intersectLL, function() {\n            self.setTool(new ToolIntersectLL(self._view, self._construction, self._tool_callback));\n        });\n\n        createButton(\"both intersections of line and circle\", _tool_images_js__WEBPACK_IMPORTED_MODULE_2__.intersectLC_both, function() {\n            self.setTool(new ToolIntersectLCBoth(self._view, self._construction, self._tool_callback));\n        });\n\n        createButton(\"other intersection of line and circle\", _tool_images_js__WEBPACK_IMPORTED_MODULE_2__.intersectLC_other, function() {\n            self.setTool(new ToolIntersectLC(self._view, self._construction, self._tool_callback));\n        });\n        \n        createButton(\"both intersections of two circles\", _tool_images_js__WEBPACK_IMPORTED_MODULE_2__.intersectCC_both, function() {\n            self.setTool(new ToolIntersectCCBoth(self._view, self._construction, self._tool_callback));\n        });\n\n        createButton(\"other intersection of two circles\", _tool_images_js__WEBPACK_IMPORTED_MODULE_2__.intersectCC_other, function() {\n            self.setTool(new ToolIntersectCC(self._view, self._construction, self._tool_callback));\n        });\n    }\n\n    setTool(tool) {\n        this._view.setTool(tool);\n    }    \n}\n\n\n\n\n//# sourceURL=webpack://ArgoDG/./src/dg/tool.js?");

/***/ }),

/***/ "./src/dg/tool_images.js":
/*!*******************************!*\
  !*** ./src/dg/tool_images.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"bisector\": () => (/* binding */ bisector),\n/* harmony export */   \"circle\": () => (/* binding */ circle),\n/* harmony export */   \"drag\": () => (/* binding */ drag),\n/* harmony export */   \"intersectCC_both\": () => (/* binding */ intersectCC_both),\n/* harmony export */   \"intersectCC_other\": () => (/* binding */ intersectCC_other),\n/* harmony export */   \"intersectLC_both\": () => (/* binding */ intersectLC_both),\n/* harmony export */   \"intersectLC_other\": () => (/* binding */ intersectLC_other),\n/* harmony export */   \"intersectLL\": () => (/* binding */ intersectLL),\n/* harmony export */   \"line\": () => (/* binding */ line),\n/* harmony export */   \"midpoint\": () => (/* binding */ midpoint),\n/* harmony export */   \"parallel\": () => (/* binding */ parallel),\n/* harmony export */   \"perp\": () => (/* binding */ perp)\n/* harmony export */ });\nconst drag = \"data:image/png;base64,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\";\n\nconst line = \"data:image/png;base64,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\";\n\nconst circle = \"data:image/png;base64,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\";\n\nconst midpoint = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAMAAABg3Am1AAABfGlDQ1BpY2MAACiRfZE9SMNAHMVfU4siFQWLFHHIUJ0sSBVx1CoUoUKoFVp1MLl+QpOGJMXFUXAtOPixWHVwcdbVwVUQBD9AHJ2cFF2kxP8lhRYxHhz34929x907QGhUmGp2TQCqZhmpRFzMZFfF7lcEEMYAYhiSmanPSVISnuPrHj6+3kV5lve5P0dfLm8ywCcSzzLdsIg3iKc3LZ3zPnGIleQc8TnxuEEXJH7kuuLyG+eiwwLPDBnp1DxxiFgsdrDSwaxkqMRTxJGcqlG+kHE5x3mLs1qpsdY9+QuDeW1lmes0R5DAIpYgQYSCGsqowEKUVo0UEynaj3v4hx2/RC6FXGUwciygChWy4wf/g9/dmoXJmJsUjAOBF9v+GAW6d4Fm3ba/j227eQL4n4Erre2vNoCZT9LrbS1yBPRvAxfXbU3ZAy53gPCTLhuyI/lpCoUC8H5G35QFBm+B3jW3t9Y+Th+ANHWVvAEODoGxImWve7y7p7O3f8+0+vsBk6pytKr5MIYAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAAAPxQTFRF////2NjXlJCd29zbUTaEQgDAk4+dQwDAXQD/QgC+2NnYQwDB/f397u7u6Ojo+fn529vak4+c/v7+qampOTk5KSkpdXV109PTICAgAAAAAwMDkJCQrq6uW1tb0NDQGxsbAQEBioqK/Pz8oaGhMTExISEhbW1t6urq8vPxtbO4mpWlxcXG+vr55+fn3t7e+Pj4+vv6h3+ZOwicQgDCPhaMr6y2/v7/1tfURR+PWAD8XAD/UQDsW0aF8fPv/v3/09TRQhqQWgD9UwDvVkCD8PHu/f3/9vf1dmqOPgOwRwDTPg2bnJim///+7e3soJyogXiTs7K4+Pj3+vn/+ff/Sj6iCwAAAAFiS0dEGexutYgAAAAJcEhZcwAALiMAAC4jAXilP3YAAAAHdElNRQfmBRgVCQnjd8BJAAAAyklEQVQYGe3BWVsBYRgG4McYDMZaqU+2ivbQ9pRdoaJR4f//F9NJnc28c+a6zH3D59t2AU0LwIOgHgrpQciFI4YRCUNOixpGVINcTI/H9RicmIlkCv/SmUwaTrI7u3u5BOT2D5TKH0KukFdKFU2IlcpKVY4gd3xSrZ2ewcn5xeXVNf6YN/UGnDRv7+4fHvGLJNw9PbfanW4PNvYJd4PhS/t1NIaNE8Ld2/vHdPZpwcY+ITD/+v5ZgBMChIhlWQCXhCdcEZ6QhM+3qdbucxRge/nozQAAABl0RVh0Q29tbWVudABDcmVhdGVkIHdpdGggR0lNUFeBDhcAAAAldEVYdGRhdGU6Y3JlYXRlADIwMjItMDUtMjRUMTk6MDk6MDkrMDI6MDDFVbOEAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDIyLTA1LTI0VDE5OjA5OjA5KzAyOjAwtAgLOAAAABt0RVh0aWNjOmNvcHlyaWdodABQdWJsaWMgRG9tYWlutpExWwAAACJ0RVh0aWNjOmRlc2NyaXB0aW9uAEdJTVAgYnVpbHQtaW4gc1JHQkxnQRMAAAAVdEVYdGljYzptYW51ZmFjdHVyZXIAR0lNUEyekMoAAAAOdEVYdGljYzptb2RlbABzUkdCW2BJQwAAAABJRU5ErkJggg==\";\n\nconst bisector = \"data:image/png;base64,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\"\n\nconst perp = \"data:image/png;base64,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\";\n\nconst parallel = \"data:image/png;base64,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\";\n\nconst intersectLL = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAAAAAByaaZbAAAACXBIWXMAAC4jAAAuIwF4pT92AAAAB3RJTUUH5gUYFRAvqnrsrAAAAAJiS0dEAACqjSMyAAABx0lEQVRIx5XVWS9DURAA4JP02bOEN7/C//ATvPIHPNHovbSlC60lEXurKCK2ECRSxFL7EktK0bRUVanqXXLGC1Xae+6Z+3Ym8yX3zEzOEGB82aZIQYywQNgi4cCSB3DAvYcDr0ISBw7bKQ745gEFZGsIByLNWRxYHQQc6N4qEkxrg3cxXhBLzpq0wanjf1ET042esDbwz/w9P08YPVGqfQel9TLvRJ/GGkZilHXpqPjxmx7zNYw+UnaVAr259KjX6I/rlrVn/Ts94mmcSuj3IS3GAADow5Bp5oWncRc2FYDeDwhzrzydpqmhSaDhfmEhxTUa6khlac1Zn7j4xjlLwXJCDFXL79zD5zUQQqpV4ATqZV0JIQYn8AH1rF1c6yirqI1zAeXE2RTIwHV9SAIOIB85zBufADA/pjnEeUA+sFu3swAAtO1YH8h7dlvw+z8SQkoPSEGbY1/+Ce52AhtIO63OQ+U3OLzMBNmtlrbjvHSQzHcMkNm0uk6VP7Fbi8QAgvv8/wwsehkPLgkphWthH4CnD7m1YEriwIGL4oBvAVBAttzgwEPRtcAAK4OAA13bOPAmPuNA4VrQAeOzgAJKyxUOPAlpNvgCGUCt2ns2PH8AAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDIyLTA1LTI0VDE5OjE2OjQ3KzAyOjAwIaVCbgAAACV0RVh0ZGF0ZTptb2RpZnkAMjAyMi0wNS0yNFQxOToxNjo0NyswMjowMFD4+tIAAAAbdEVYdGljYzpjb3B5cmlnaHQAUHVibGljIERvbWFpbraRMVsAAAAidEVYdGljYzpkZXNjcmlwdGlvbgBHSU1QIGJ1aWx0LWluIHNSR0JMZ0ETAAAAFXRFWHRpY2M6bWFudWZhY3R1cmVyAEdJTVBMnpDKAAAADnRFWHRpY2M6bW9kZWwAc1JHQltgSUMAAAAASUVORK5CYII=\";\n\nconst intersectLC_both = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAMAAABg3Am1AAABfGlDQ1BpY2MAACiRfZE9SMNAHMVfU4siFQWLFHHIUJ0sSBVx1CoUoUKoFVp1MLl+QpOGJMXFUXAtOPixWHVwcdbVwVUQBD9AHJ2cFF2kxP8lhRYxHhz34929x907QGhUmGp2TQCqZhmpRFzMZFfF7lcEEMYAYhiSmanPSVISnuPrHj6+3kV5lve5P0dfLm8ywCcSzzLdsIg3iKc3LZ3zPnGIleQc8TnxuEEXJH7kuuLyG+eiwwLPDBnp1DxxiFgsdrDSwaxkqMRTxJGcqlG+kHE5x3mLs1qpsdY9+QuDeW1lmes0R5DAIpYgQYSCGsqowEKUVo0UEynaj3v4hx2/RC6FXGUwciygChWy4wf/g9/dmoXJmJsUjAOBF9v+GAW6d4Fm3ba/j227eQL4n4Erre2vNoCZT9LrbS1yBPRvAxfXbU3ZAy53gPCTLhuyI/lpCoUC8H5G35QFBm+B3jW3t9Y+Th+ANHWVvAEODoGxImWve7y7p7O3f8+0+vsBk6pytKr5MIYAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAAAhZQTFRF/////f39/v7+9fX12NjYsrKyoqKimpqak5OTlpaWnp6ep6enxsbG6urq/Pz86enppKSkgYGBioqKrq6uxMTEzc3N09PTyMjIvLy8nZ2dhYWFjo6O+vr69vb2t7e3hISEra2t5eXl+/v78/Pzzs7OlJSU3d3d7+/vmZmZoKCg6Ojox8fHurq6tbW1sLCw9PT08vLy4uLi4+PjkZGRwMDAU1NTCgoKAAAA6+vr3NzcnJycjIyMiIiI5ubmg4OD5+fnNTU1GBgYfHx8iYmJj4+PzMzM8PDwh4eHv7+/8fHx39/ftLS0fn5+HBwcHR0d+Pj4xcXFqKior6+v9/f32trawsLCi4uLsbGx29vb7e3td3d3BgYGZWVl+fn5ExMTAgICEBAQ0NDQvb29paWlqampgoKCJSUlLy8vmJiYwcHB19fXrKysdnZ2Dg4OLi4ukpKSpqamubm50dHRXl5eBQUFf39/2dnZ5OTkWVlZ5ebjy8zK+Pj30dDRVz2GQAqlPxWQjYWc+vv5/fz//v3//v7//Pz6c2qJRwDTXAD/WAD9QhmUy8vK/f3/1NTUl5eX+Pn2ZFSFUADoWwD/QAujubq6m5ejPgikUADrVz6G5ufk9vb1oJuoYlKEc2mJ0NDR+/r/w8PDhoaG7u7u/f799/j2+/v6oaGhgICAy8vLtra2kJCQysrKycnJ3t7e7Ozsn5+f4eHh/v//fNLwIgAAAAFiS0dENzC4uEcAAAAJcEhZcwAALiMAAC4jAXilP3YAAAAHdElNRQfmBRgVGzm9WoA2AAACV0lEQVRIx2NgGAUUAEYmopUyMbOwsrFzcHJx8/DyEaGeX0BQSFhElEVMXEJSSlpchoByWTl5BUUlmF3KKtKqanjdpq6hqYUiIKMtr6MrpKcPMUDJwBBVvZGxCSO6GYqmZuZmUrIWliJ6VtY21ihytnYqmKFl72Bubu7o5OzCputqqK6ELOfm7oEcWEqeXqLemsY+vkANfq7+6Fb7BwTKB0H8xxTMGxIqzB5mI80ezhMRGRVtbh4Ti2EzR1x8gjCTsm1iUjKHkI2xgJyKkRskFtxSfFJdlNA1qKUBLU4Xcg/LCMzM0gpGs1/GRRzhVFl+Fo9sjZxcoIa8RDd/7KGuYg03wljIOb+gsEitON68pBRnHBkIwqOnjB/i/3LTigw33DHKLoIuwuuuj8yt1KmqRuZLcKNrMApDDoia2rr6hkaGpmYGhpYWkIA4F7qGMg4kD7S2tXd0dnWDNfQ0g0TEONE19PYhcfonTJzUMXkKmA2xgUUVPUC8pJEzy9Rp09tnzIQqBgFRdnQbbJ2Rs8qs2XPmzmNgmN8EE1jAhq7Bc+EiZO7iJUsZkDUosGKENKcoZujDncTnzIIhKbEMT04sF2TGELNdboFbQ7YANsEUnOrt5fmxFQALLXEValxyWMVXSOFw1MpVstgldKWxSqy2w+U7RgUNdcySc42zIe4S2MR4LVqaCfbm5MdXEKu4p6xD4iupWLN5IsVjC6YWt+zS9SsWyfAxMSkFb1gpFCaGlCZbmluwWWKrky/lLN3HEeYexp0YjJpSNuJwmKetV2+ZEW/saL06aAEA5SpymkPuM5EAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDIyLTA1LTI0VDE5OjI3OjU3KzAyOjAwmy9PzwAAACV0RVh0ZGF0ZTptb2RpZnkAMjAyMi0wNS0yNFQxOToyNzo1NyswMjowMOpy93MAAAAbdEVYdGljYzpjb3B5cmlnaHQAUHVibGljIERvbWFpbraRMVsAAAAidEVYdGljYzpkZXNjcmlwdGlvbgBHSU1QIGJ1aWx0LWluIHNSR0JMZ0ETAAAAFXRFWHRpY2M6bWFudWZhY3R1cmVyAEdJTVBMnpDKAAAADnRFWHRpY2M6bW9kZWwAc1JHQltgSUMAAAAASUVORK5CYII=\";\n\nconst intersectLC_other = \"data:image/png;base64,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\";\n\nconst intersectCC_both = \"data:image/png;base64,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\";\n\nconst intersectCC_other = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAMAAABg3Am1AAABfGlDQ1BpY2MAACiRfZE9SMNAHMVfU4siFQWLFHHIUJ0sSBVx1CoUoUKoFVp1MLl+QpOGJMXFUXAtOPixWHVwcdbVwVUQBD9AHJ2cFF2kxP8lhRYxHhz34929x907QGhUmGp2TQCqZhmpRFzMZFfF7lcEEMYAYhiSmanPSVISnuPrHj6+3kV5lve5P0dfLm8ywCcSzzLdsIg3iKc3LZ3zPnGIleQc8TnxuEEXJH7kuuLyG+eiwwLPDBnp1DxxiFgsdrDSwaxkqMRTxJGcqlG+kHE5x3mLs1qpsdY9+QuDeW1lmes0R5DAIpYgQYSCGsqowEKUVo0UEynaj3v4hx2/RC6FXGUwciygChWy4wf/g9/dmoXJmJsUjAOBF9v+GAW6d4Fm3ba/j227eQL4n4Erre2vNoCZT9LrbS1yBPRvAxfXbU3ZAy53gPCTLhuyI/lpCoUC8H5G35QFBm+B3jW3t9Y+Th+ANHWVvAEODoGxImWve7y7p7O3f8+0+vsBk6pytKr5MIYAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAAAkNQTFRF/////v7+9PT04ODgxsbGs7Ozra2ttbW1ysrK5OTk9vb28vLyx8fHsLCwxcXF29vb4+Pj2NjYwcHBr6+vzs7O2trasrKy0tLS9fX18fHxzMzM/Pz8ubm58PDw6enp7+/v4uLi4eHh+Pj4/v//1dbW8/Pzv7+/3t7e2dnZtra2t7e30NDQwsLCycfH9sbG/+bm8snJ24eH+fT0u7u75ubm3d3d6urq+/v74Nvb821t/1dX6ra20p2d9kdH/pGR//z85+fnsbGx9/f309PT6Ojo/v7//vDw7np65g4O5AEBviQk4dnZ/f39zc3NyMjI//7/2aSk5AUF8QAAtAkJzbS07OzsrKys+fn5+vr6/97e/lhYsxsbYgwM1BYW+llZ/+Tk7e3t/6en/5WVubCwp6mpyLGx0mVl/83N+Pn2+fr30dHR19fX//7+//j4//v7ycnJ9/j4urm58O7uysXVelu3gGW22dbfvb29vr6+1tfX8vPwakmtUgDzTwDqf2up+vz45eXlw8PD1tbWqqqqakmrUgDxTwDogGuo+/z4/v795eTm19Xb9vf26+vrurq67u7u///+z8rZeFm0gWa33NriwMDA08/baDq+VhnHm4bD+fr439/f/v/++/v5mIW9UgDtWQD/XijD4uLj5OPktqzJVBPOUgDld1W58PHw9fX2vLXLp5q/4N/j/f3/xMTE1dXVoaGhjIyMfX19XV1dAAAABwcHkJCQvLy8Nzc3ZWVlioqKExMTJSUliYmJ3NzctLS0z8/Pdk3CsgAAAAFiS0dEtEQJat0AAAAJcEhZcwAALiMAAC4jAXilP3YAAAAHdElNRQfmBRgXBA1SMK5zAAACe0lEQVRIx2NgGAXDFDAykqCWiZmFlY2NnYOTixhdjNw8vHz8zJwCzIJCwiJchNWLiolLQA1mlJRiFSCgXlpERhaZL8cqiO4saXlOBUUBOSWwuLIKnxKqtKqaOgpfSUNTi09Km0eHVVdPn4HBwNAI3U4mYxMkB5vySpmZQ0LGwtLK2sbWzh7DlQ6OTnDXOMu4AF3i6grmubl7eHp5Y/EXizOU4ePrB9Tr7w/VwBAQGBQcgkVDaFg4hCEuEwEyHqqcITIqOiY2Lh5Tg4+jA5hOcAQFoKsrTEtiUnJKalo61HcZmYjgzBIEUzzZEC5UQ05uXn5oQWERRLC4pLQMroFZG0TKlkdA+TA3+VRIMlT6gZlV1TW1dfWw8GhoBJFNLBhuBWoIbQYbU9XS2tbeAbMcokGNGaaws6u7B8zw62Xw6esHsSZMnDR5CgPMexAnTZWDaZg2fcbMWSCX+c5mYNDpBYvNmTV3AiyCGLRBvvXhgSWyCfPmL1i4CCS7GOhKKReEG6EapHlBwcrYGAoTX7J02fIVIK+v1JJg4DHDiIdeSMSVN8AEnFatXsOwFmRavjaDWiiGhnXrwZRUFlxkwgQGiAbJDRs3mWEmPkiKdyhHyRlg9zpt3rJ1G5p61e1QX0kLOWAmsx1btuw0R1VvDM9As2WkMaJu1+49e5GzKKMDOz/cIT5qUugaJDX59qlrcTBB1fjIrpNpQJLm6jNFVS8xFWS9qt9+mSx1F4d9IprsB5xQDZyqjexgF81ssNGMXKY6On48U/kUlNCd4MSnJeADda2E335FwkUlI7NQeb5Gg5y6eKOalARRBal0qFQ5H4uQELMTI21K6lEwoAAAvu2AEin5SFEAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDIyLTA1LTI0VDIxOjA0OjEzKzAyOjAwfhORUgAAACV0RVh0ZGF0ZTptb2RpZnkAMjAyMi0wNS0yNFQyMTowNDoxMyswMjowMA9OKe4AAAAbdEVYdGljYzpjb3B5cmlnaHQAUHVibGljIERvbWFpbraRMVsAAAAidEVYdGljYzpkZXNjcmlwdGlvbgBHSU1QIGJ1aWx0LWluIHNSR0JMZ0ETAAAAFXRFWHRpY2M6bWFudWZhY3R1cmVyAEdJTVBMnpDKAAAADnRFWHRpY2M6bW9kZWwAc1JHQltgSUMAAAAASUVORK5CYII=\";\n\n\n\n\n//# sourceURL=webpack://ArgoDG/./src/dg/tool_images.js?");

/***/ }),

/***/ "./src/dg/view.js":
/*!************************!*\
  !*** ./src/dg/view.js ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ListView\": () => (/* binding */ ListView),\n/* harmony export */   \"View\": () => (/* binding */ View)\n/* harmony export */ });\n/* harmony import */ var _latex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./latex.js */ \"./src/dg/latex.js\");\n/* harmony import */ var _canvas_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./canvas.js */ \"./src/dg/canvas.js\");\n/* harmony import */ var _tool_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./tool.js */ \"./src/dg/tool.js\");\n\n\n\n\n// -----------------------------------------------------------------------------\n// drawing view enables drawing objects given in the world coordinate system\n// -----------------------------------------------------------------------------\nclass View {\n    constructor(element, options, xmin, xmax, ymin, ymax) {\n        if (arguments.length == 2) {\n            [xmin, xmax] = [-5, 5];\n            [ymin, ymax] = [-5, 5];\n        }\n        this._canvas = new _canvas_js__WEBPACK_IMPORTED_MODULE_1__.Canvas(element, options);\n        this.setVisibleRange(xmin, xmax, ymin, ymax);\n        \n        // constructions that are shown by this view\n        this._constructions = [];\n\n        // tool that react to the mouse and keyboard events\n        this._tool = undefined;\n\n        // panning tool\n        this._startPan = undefined;\n        \n        this.addEventListener('mousemove', this.mousemove.bind(this), false);\n        this.addEventListener('mousedown', this.mousedown.bind(this), false);\n        this.addEventListener('mouseup', this.mouseup.bind(this), false);\n        document.body.addEventListener('keydown', this.keydown.bind(this), false);\n    }\n\n    setConstruction(construction) {\n        this._constructions = [construction];\n        construction.drawView(this);\n    }\n\n    addConstruction(construction) {\n        this._constructions.push(construction);\n        construction.drawView(this);\n    }\n\n    setVisibleRange(xmin, xmax, ymin, ymax) {\n        this._xmin = xmin;\n        this._xmax = xmax;\n        this._ymin = ymin;\n        this._ymax = ymax;\n        this._scalex = (this._canvas.width()) / (xmax - xmin);\n        this._scaley = (this._canvas.height()) / (ymax - ymin);\n        this._x0 = -xmin * this._scalex;\n        this._y0 = ymax * this._scaley;\n    }\n\n    drawObject(obj) {\n        obj.draw(this);\n    }\n\n    drawObjects(objects) {\n        // draw points above other objects\n        objects.filter(o => !o.isPoint()).forEach(obj => {this.drawObject(obj);});\n        objects.filter(o => o.isPoint()).forEach(obj => {this.drawObject(obj);});\n    }\n\n    redraw() {\n        this.clear();\n        this._constructions.forEach(construction => {\n            construction.drawView(this);\n        });\n    }\n\n    zoom(factor) {\n        const w = this._xmax - this._xmin;\n        const h = this._ymax - this._ymin;\n        const cx = (this._xmin + this._xmax) / 2;\n        const cy = (this._ymin + this._ymax) / 2;\n        this.setVisibleRange(cx - w/(2 * factor), cx + w/(2 * factor),\n                             cy - h/(2 * factor), cy + h/(2 * factor));\n        this.redraw();\n    }\n\n    pan(startPan, endPan) {\n        const dX = endPan.X - startPan.X;\n        const dY = endPan.Y - startPan.Y;\n        const w = this._canvas.width();\n        const h = this._canvas.height();\n        const dx = -dX / w * (this._xmax - this._xmin);\n        const dy = dY / w * (this._xmax - this._xmin);\n        this.setVisibleRange(this._xmin + dx, this._xmax + dx,\n                             this._ymin + dy, this._ymax + dy);\n        this.redraw();\n    }\n\n    canvas() {\n        return this._canvas;\n    }\n\n    addEventListener(event, fun) {\n        this._canvas.addEventListener(event, fun);\n    }\n\n    clear() {\n        this._canvas.clear();\n    }\n\n    worldToScreen(x, y) {\n        return [this._x0 + x * this._scalex, this._y0 - y * this._scaley];\n    }\n\n    screenToWorld(x, y) {\n        return [(x - this._x0) / this._scalex, (this._y0 - y) / this._scaley];\n    }\n\n    point(x, y, options) {\n        options = options || {}\n        const size = options.size || 1;\n        const [xt, yt] = this.worldToScreen(x, y);\n        this._canvas.circle(xt, yt, 4 * size, options.color, undefined, undefined, true)\n    }\n\n    text(x, y, txt) {\n        const [xt, yt] = this.worldToScreen(x, y);\n        const displace = 8;\n        this._canvas.latex(xt + displace, yt + displace, txt);\n    }\n    \n    segment(x1, y1, x2, y2, options) {\n        options = options || {}\n        const [x1t, y1t] = this.worldToScreen(x1, y1);\n        const [x2t, y2t] = this.worldToScreen(x2, y2);\n        this._canvas.segment(x1t, y1t, x2t, y2t, options.color, options.width, options.dash);\n    }\n\n    segment_complement(x1, y1, x2, y2, options) {\n        options = options || {}\n        const [x1t, y1t] = this.worldToScreen(x1, y1);\n        const [x2t, y2t] = this.worldToScreen(x2, y2);\n        this._canvas.segment_complement(x1t, y1t, x2t, y2t, options.color, options.width, options.dash);\n    }\n    \n    line(x1, y1, x2, y2, options) {\n        options = options || {}\n        const [x1t, y1t] = this.worldToScreen(x1, y1);\n        const [x2t, y2t] = this.worldToScreen(x2, y2);\n        this._canvas.line(x1t, y1t, x2t, y2t, options.color, options.width, options.dash);\n    }\n\n    circle(x, y, r, options) {\n        options = options || {};\n        const [xt, yt] = this.worldToScreen(x, y);\n        const rt = r * this._scalex; // FIXME: different scales\n        this._canvas.circle(xt, yt, rt, options.color, options.width, options.dash);\n    }\n\n    arc(x, y, r, start_angle, end_angle, counterclockwise, options) {\n        options = options || {};\n        const [xt, yt] = this.worldToScreen(x, y);\n        const rt = r * this._scalex; // FIXME: different scales\n        this._canvas.arc(xt, yt, rt, start_angle, end_angle, counterclockwise, options.color, options.width, options.dash);\n    }\n\n    line_label(x1, y1, x2, y2, color, label) {\n        const [x1t, y1t] = this.worldToScreen(x1, y1);\n        const [x2t, y2t] = this.worldToScreen(x2, y2);\n        this._canvas.line_label(x1t, y1t, x2t, y2t, color, label);\n    }\n\n    message(msg) {\n        this._canvas.message(msg);\n    }\n\n    addMessage(msg) {\n        this._canvas.addMessage(msg);\n    }\n\n    setTool(tool) {\n        this._tool = tool;\n    }    \n\n    getMousePosition(e) {\n        return {X: e.offsetX, Y: e.offsetY};\n    }\n    \n    mousemove(e) {\n        // mouse position\n        const p = this.getMousePosition(e);\n        \n        // panning\n        if (this._startPan) {\n            this.pan(this._startPan, p);\n            this._startPan = p;\n        }\n\n        // specific actions by the current tool \n        if (this._tool)\n            this._tool.mousemove(p.X, p.Y,\n                                 this.worldToScreen.bind(this),\n                                 this.screenToWorld.bind(this));\n    }\n\n    findObjectsAt(x, y) {\n        let objects = [];\n        this._constructions.forEach(construction => {\n            const c_objects = construction.findObjectsAt(x, y,\n                                                         this.worldToScreen.bind(this));\n            objects.push(...c_objects);\n        });\n        return objects;\n    }\n\n    mousedown(e) {\n        // mouse position\n        const p = this.getMousePosition(e);\n        \n        // panning\n        if (e.ctrlKey)\n            this._startPan = p;\n\n        // show description\n        if (e.shiftKey) {\n            const p = this.getMousePosition(e);\n            const objects = this.findObjectsAt(p.X, p.Y);\n            \n            this.message(\"\");\n            objects.forEach(obj => {\n                this.addMessage(obj.describe());\n            });\n        }\n        \n        // specific actions by the current tool \n        if (this._tool)\n            this._tool.mousedown(p.X, p.Y,\n                                 this.worldToScreen.bind(this),\n                                 this.screenToWorld.bind(this));\n    }\n\n    mouseup(e) {\n        // mouse position\n        const p = this.getMousePosition(e);\n        \n        // panning\n        if (this._startPan) {\n            this.pan(this._startPan, p);\n            this._startPan = undefined;\n        }\n\n        // reset message\n        if (e.shiftKey)\n            this.message(\"\");\n\n        // specific actions by the current tool \n        if (this._tool)\n            this._tool.mouseup(p.X, p.Y,\n                               this.worldToScreen.bind(this),\n                               this.screenToWorld.bind(this));\n    }\n\n    keydown(e) {\n        // zooming\n        if (e.ctrlKey && e.code == 'NumpadAdd') { // numpad +\n            e.preventDefault();\n            this.zoom(1.5);\n        } else if (e.ctrlKey && e.code == 'NumpadSubtract') { // numpad -\n            e.preventDefault();\n            this.zoom(1 / 1.5);\n        }\n\n        // specific actions by the current tool \n        if (this._tool)\n            this._tool.keydown(e,\n                               this.worldToScreen.bind(this),\n                               this.screenToWorld.bind(this));\n    }\n}\n\n\nclass ListView {\n    constructor(element) {\n        this._element = element;\n        this._constructions = [];\n    }\n\n    addConstruction(construction) {\n        this._constructions.push(construction);\n        construction.drawView(this);\n    }\n    \n    drawObjects(objects) {\n        const table = document.createElement(\"table\");\n        table.classList.add(\"objects\");\n        this._element.append(table);\n        let tr = document.createElement(\"tr\");\n        table.append(tr);\n        const th1 = document.createElement(\"th\");\n        th1.innerHTML = \"Label\";\n        tr.append(th1);\n        const th2 = document.createElement(\"th\");\n        th2.innerHTML = \"Description\";\n        tr.append(th2);\n        \n        objects.forEach(obj => {\n            tr = document.createElement(\"tr\");\n            table.append(tr);\n            const td1 = document.createElement(\"td\");\n            tr.append(td1);\n            td1.innerHTML = obj.label();\n            const td2 = document.createElement(\"td\");\n            tr.append(td2);\n            td2.innerHTML = obj.description();\n\n            tr.addEventListener(\"mouseenter\", () => { obj.highlightOn(); });\n            tr.addEventListener(\"mouseleave\", () => { obj.highlightOff(); });\n            td1.addEventListener(\"click\", (e) => {\n                const input = document.createElement(\"input\");\n                input.type = \"text\";\n                input.value = obj.label();\n                td1.innerHTML = \"\";\n                td1.append(input);\n                input.focus();\n                input.addEventListener(\"blur\", (e) => {\n                    obj.label(input.value);\n                });\n            });\n        });\n    }\n\n    redraw() {\n        this.clear();\n        this._constructions.forEach(construction => {\n            construction.drawView(this);\n        });\n    }\n\n    clear() {\n        this._element.innerHTML = \"\";\n    }\n}\n\n\n\n\n//# sourceURL=webpack://ArgoDG/./src/dg/view.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/chunk loaded */
/******/ 	(() => {
/******/ 		var deferred = [];
/******/ 		__webpack_require__.O = (result, chunkIds, fn, priority) => {
/******/ 			if(chunkIds) {
/******/ 				priority = priority || 0;
/******/ 				for(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];
/******/ 				deferred[i] = [chunkIds, fn, priority];
/******/ 				return;
/******/ 			}
/******/ 			var notFulfilled = Infinity;
/******/ 			for (var i = 0; i < deferred.length; i++) {
/******/ 				var [chunkIds, fn, priority] = deferred[i];
/******/ 				var fulfilled = true;
/******/ 				for (var j = 0; j < chunkIds.length; j++) {
/******/ 					if ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {
/******/ 						chunkIds.splice(j--, 1);
/******/ 					} else {
/******/ 						fulfilled = false;
/******/ 						if(priority < notFulfilled) notFulfilled = priority;
/******/ 					}
/******/ 				}
/******/ 				if(fulfilled) {
/******/ 					deferred.splice(i--, 1)
/******/ 					var r = fn();
/******/ 					if (r !== undefined) result = r;
/******/ 				}
/******/ 			}
/******/ 			return result;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"DG": 0
/******/ 		};
/******/ 		
/******/ 		// no chunk on demand loading
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		__webpack_require__.O.j = (chunkId) => (installedChunks[chunkId] === 0);
/******/ 		
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = (parentChunkLoadingFunction, data) => {
/******/ 			var [chunkIds, moreModules, runtime] = data;
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0;
/******/ 			if(chunkIds.some((id) => (installedChunks[id] !== 0))) {
/******/ 				for(moduleId in moreModules) {
/******/ 					if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 						__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 					}
/******/ 				}
/******/ 				if(runtime) var result = runtime(__webpack_require__);
/******/ 			}
/******/ 			if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			for(;i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					installedChunks[chunkId][0]();
/******/ 				}
/******/ 				installedChunks[chunkId] = 0;
/******/ 			}
/******/ 			return __webpack_require__.O(result);
/******/ 		}
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunkArgoDG"] = self["webpackChunkArgoDG"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/dg.js");
/******/ 	__webpack_exports__ = __webpack_require__.O(__webpack_exports__);
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});